var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":true},"build":"SFTimeSignalDemo","ref":false,"files":[{"name":"SFTimeSignalDemo.c","type":"source","group":"model","path":"/Users/deshazere/General-Atomics/fusion/projects/IRAD-1340-API/redis-simulink/bus_sfunction_builder/SFTimeSignalDemo_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * SFTimeSignalDemo.c\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"SFTimeSignalDemo\".\n *\n * Model version              : 1.47\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\n * C source code generated on : Mon Aug 12 04:40:31 2024\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#include \"SFTimeSignalDemo.h\"\n#include \"rtwtypes.h\"\n#include <math.h>\n#include \"rt_logging_mmi.h\"\n#include \"SFTimeSignalDemo_capi.h\"\n#include \"SFTimeSignalDemo_private.h\"\n#include <string.h>\n#include \"SFTimeSignalDemo_dt.h\"\n\n/* Block signals (default storage) */\nB_SFTimeSignalDemo_T SFTimeSignalDemo_B;\n\n/* Block states (default storage) */\nDW_SFTimeSignalDemo_T SFTimeSignalDemo_DW;\n\n/* Real-time model */\nstatic RT_MODEL_SFTimeSignalDemo_T SFTimeSignalDemo_M_;\nRT_MODEL_SFTimeSignalDemo_T *const SFTimeSignalDemo_M = &SFTimeSignalDemo_M_;\n\n/* Model step function */\nvoid SFTimeSignalDemo_step(void)\n{\n  /* Clock: '<Root>/Clock' */\n  SFTimeSignalDemo_B.Time = SFTimeSignalDemo_M->Timing.t[0];\n\n  /* Sin: '<Root>/Sine Wave' */\n  SFTimeSignalDemo_B.SineWave = sin(SFTimeSignalDemo_M->Timing.t[0]);\n\n  /* Matfile logging */\n  rt_UpdateTXYLogVars(SFTimeSignalDemo_M->rtwLogInfo,\n                      (SFTimeSignalDemo_M->Timing.t));\n\n  /* External mode */\n  rtExtModeUploadCheckTrigger(2);\n\n  {                                    /* Sample time: [0.0s, 0.0s] */\n    rtExtModeUpload(0, (real_T)SFTimeSignalDemo_M->Timing.t[0]);\n  }\n\n  {                                    /* Sample time: [1.0s, 0.0s] */\n    rtExtModeUpload(1, (real_T)(((SFTimeSignalDemo_M->Timing.clockTick1+\n      SFTimeSignalDemo_M->Timing.clockTickH1* 4294967296.0)) * 1.0));\n  }\n\n  /* signal main to stop simulation */\n  {                                    /* Sample time: [0.0s, 0.0s] */\n    if ((rtmGetTFinal(SFTimeSignalDemo_M)!=-1) &&\n        !((rtmGetTFinal(SFTimeSignalDemo_M)-SFTimeSignalDemo_M->Timing.t[0]) >\n          SFTimeSignalDemo_M->Timing.t[0] * (DBL_EPSILON))) {\n      rtmSetErrorStatus(SFTimeSignalDemo_M, \"Simulation finished\");\n    }\n\n    if (rtmGetStopRequested(SFTimeSignalDemo_M)) {\n      rtmSetErrorStatus(SFTimeSignalDemo_M, \"Simulation finished\");\n    }\n  }\n\n  /* Update absolute time for base rate */\n  /* The \"clockTick0\" counts the number of times the code of this task has\n   * been executed. The absolute time is the multiplication of \"clockTick0\"\n   * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\n   * overflow during the application lifespan selected.\n   * Timer of this task consists of two 32 bit unsigned integers.\n   * The two integers represent the low bits Timing.clockTick0 and the high bits\n   * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.\n   */\n  if (!(++SFTimeSignalDemo_M->Timing.clockTick0)) {\n    ++SFTimeSignalDemo_M->Timing.clockTickH0;\n  }\n\n  SFTimeSignalDemo_M->Timing.t[0] = SFTimeSignalDemo_M->Timing.clockTick0 *\n    SFTimeSignalDemo_M->Timing.stepSize0 +\n    SFTimeSignalDemo_M->Timing.clockTickH0 *\n    SFTimeSignalDemo_M->Timing.stepSize0 * 4294967296.0;\n\n  {\n    /* Update absolute timer for sample time: [1.0s, 0.0s] */\n    /* The \"clockTick1\" counts the number of times the code of this task has\n     * been executed. The resolution of this integer timer is 1.0, which is the step size\n     * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\n     * application lifespan selected.\n     * Timer of this task consists of two 32 bit unsigned integers.\n     * The two integers represent the low bits Timing.clockTick1 and the high bits\n     * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.\n     */\n    SFTimeSignalDemo_M->Timing.clockTick1++;\n    if (!SFTimeSignalDemo_M->Timing.clockTick1) {\n      SFTimeSignalDemo_M->Timing.clockTickH1++;\n    }\n  }\n}\n\n/* Model initialize function */\nvoid SFTimeSignalDemo_initialize(void)\n{\n  /* Registration code */\n\n  /* initialize real-time model */\n  (void) memset((void *)SFTimeSignalDemo_M, 0,\n                sizeof(RT_MODEL_SFTimeSignalDemo_T));\n\n  {\n    /* Setup solver object */\n    rtsiSetSimTimeStepPtr(&SFTimeSignalDemo_M->solverInfo,\n                          &SFTimeSignalDemo_M->Timing.simTimeStep);\n    rtsiSetTPtr(&SFTimeSignalDemo_M->solverInfo, &rtmGetTPtr(SFTimeSignalDemo_M));\n    rtsiSetStepSizePtr(&SFTimeSignalDemo_M->solverInfo,\n                       &SFTimeSignalDemo_M->Timing.stepSize0);\n    rtsiSetErrorStatusPtr(&SFTimeSignalDemo_M->solverInfo, (&rtmGetErrorStatus\n      (SFTimeSignalDemo_M)));\n    rtsiSetRTModelPtr(&SFTimeSignalDemo_M->solverInfo, SFTimeSignalDemo_M);\n  }\n\n  rtsiSetSimTimeStep(&SFTimeSignalDemo_M->solverInfo, MAJOR_TIME_STEP);\n  rtsiSetIsMinorTimeStepWithModeChange(&SFTimeSignalDemo_M->solverInfo, false);\n  rtsiSetIsContModeFrozen(&SFTimeSignalDemo_M->solverInfo, false);\n  rtsiSetSolverName(&SFTimeSignalDemo_M->solverInfo,\"FixedStepDiscrete\");\n  rtmSetTPtr(SFTimeSignalDemo_M, &SFTimeSignalDemo_M->Timing.tArray[0]);\n  rtmSetTFinal(SFTimeSignalDemo_M, 50.0);\n  SFTimeSignalDemo_M->Timing.stepSize0 = 1.0;\n\n  /* Setup for data logging */\n  {\n    static RTWLogInfo rt_DataLoggingInfo;\n    rt_DataLoggingInfo.loggingInterval = (NULL);\n    SFTimeSignalDemo_M->rtwLogInfo = &rt_DataLoggingInfo;\n  }\n\n  /* Setup for data logging */\n  {\n    rtliSetLogXSignalInfo(SFTimeSignalDemo_M->rtwLogInfo, (NULL));\n    rtliSetLogXSignalPtrs(SFTimeSignalDemo_M->rtwLogInfo, (NULL));\n    rtliSetLogT(SFTimeSignalDemo_M->rtwLogInfo, \"tout\");\n    rtliSetLogX(SFTimeSignalDemo_M->rtwLogInfo, \"\");\n    rtliSetLogXFinal(SFTimeSignalDemo_M->rtwLogInfo, \"\");\n    rtliSetLogVarNameModifier(SFTimeSignalDemo_M->rtwLogInfo, \"rt_\");\n    rtliSetLogFormat(SFTimeSignalDemo_M->rtwLogInfo, 4);\n    rtliSetLogMaxRows(SFTimeSignalDemo_M->rtwLogInfo, 0);\n    rtliSetLogDecimation(SFTimeSignalDemo_M->rtwLogInfo, 1);\n    rtliSetLogY(SFTimeSignalDemo_M->rtwLogInfo, \"\");\n    rtliSetLogYSignalInfo(SFTimeSignalDemo_M->rtwLogInfo, (NULL));\n    rtliSetLogYSignalPtrs(SFTimeSignalDemo_M->rtwLogInfo, (NULL));\n  }\n\n  /* External mode info */\n  SFTimeSignalDemo_M->Sizes.checksums[0] = (3983486012U);\n  SFTimeSignalDemo_M->Sizes.checksums[1] = (942521878U);\n  SFTimeSignalDemo_M->Sizes.checksums[2] = (480808705U);\n  SFTimeSignalDemo_M->Sizes.checksums[3] = (1430772357U);\n\n  {\n    static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE;\n    static RTWExtModeInfo rt_ExtModeInfo;\n    static const sysRanDType *systemRan[1];\n    SFTimeSignalDemo_M->extModeInfo = (&rt_ExtModeInfo);\n    rteiSetSubSystemActiveVectorAddresses(&rt_ExtModeInfo, systemRan);\n    systemRan[0] = &rtAlwaysEnabled;\n    rteiSetModelMappingInfoPtr(SFTimeSignalDemo_M->extModeInfo,\n      &SFTimeSignalDemo_M->SpecialInfo.mappingInfo);\n    rteiSetChecksumsPtr(SFTimeSignalDemo_M->extModeInfo,\n                        SFTimeSignalDemo_M->Sizes.checksums);\n    rteiSetTPtr(SFTimeSignalDemo_M->extModeInfo, rtmGetTPtr(SFTimeSignalDemo_M));\n  }\n\n  /* block I/O */\n  (void) memset(((void *) &SFTimeSignalDemo_B), 0,\n                sizeof(B_SFTimeSignalDemo_T));\n\n  /* states (dwork) */\n  (void) memset((void *)&SFTimeSignalDemo_DW, 0,\n                sizeof(DW_SFTimeSignalDemo_T));\n\n  /* data type transition information */\n  {\n    static DataTypeTransInfo dtInfo;\n    (void) memset((char_T *) &dtInfo, 0,\n                  sizeof(dtInfo));\n    SFTimeSignalDemo_M->SpecialInfo.mappingInfo = (&dtInfo);\n    dtInfo.numDataTypes = 19;\n    dtInfo.dataTypeSizes = &rtDataTypeSizes[0];\n    dtInfo.dataTypeNames = &rtDataTypeNames[0];\n\n    /* Block I/O transition table */\n    dtInfo.BTransTable = &rtBTransTable;\n  }\n\n  /* Initialize DataMapInfo substructure containing ModelMap for C API */\n  SFTimeSignalDemo_InitializeDataMapInfo();\n\n  /* Matfile logging */\n  rt_StartDataLoggingWithStartTime(SFTimeSignalDemo_M->rtwLogInfo, 0.0,\n    rtmGetTFinal(SFTimeSignalDemo_M), SFTimeSignalDemo_M->Timing.stepSize0,\n    (&rtmGetErrorStatus(SFTimeSignalDemo_M)));\n}\n\n/* Model terminate function */\nvoid SFTimeSignalDemo_terminate(void)\n{\n  /* (no terminate code required) */\n}\n"},{"name":"SFTimeSignalDemo.h","type":"header","group":"model","path":"/Users/deshazere/General-Atomics/fusion/projects/IRAD-1340-API/redis-simulink/bus_sfunction_builder/SFTimeSignalDemo_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * SFTimeSignalDemo.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"SFTimeSignalDemo\".\n *\n * Model version              : 1.47\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\n * C source code generated on : Mon Aug 12 04:40:31 2024\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef SFTimeSignalDemo_h_\n#define SFTimeSignalDemo_h_\n#ifndef SFTimeSignalDemo_COMMON_INCLUDES_\n#define SFTimeSignalDemo_COMMON_INCLUDES_\n#include \"rtwtypes.h\"\n#include \"rtw_extmode.h\"\n#include \"sysran_types.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n#include \"rt_logging.h\"\n#include \"rt_nonfinite.h\"\n#include \"math.h\"\n#include \"dt_info.h\"\n#include \"ext_work.h\"\n#endif                                 /* SFTimeSignalDemo_COMMON_INCLUDES_ */\n\n#include \"SFTimeSignalDemo_types.h\"\n#include \"rtw_modelmap.h\"\n#include <float.h>\n#include <string.h>\n#include <stddef.h>\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetDataMapInfo\n#define rtmGetDataMapInfo(rtm)         ((rtm)->DataMapInfo)\n#endif\n\n#ifndef rtmSetDataMapInfo\n#define rtmSetDataMapInfo(rtm, val)    ((rtm)->DataMapInfo = (val))\n#endif\n\n#ifndef rtmGetFinalTime\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\n#endif\n\n#ifndef rtmGetRTWExtModeInfo\n#define rtmGetRTWExtModeInfo(rtm)      ((rtm)->extModeInfo)\n#endif\n\n#ifndef rtmGetRTWLogInfo\n#define rtmGetRTWLogInfo(rtm)          ((rtm)->rtwLogInfo)\n#endif\n\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\n#endif\n\n#ifndef rtmSetStopRequested\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\n#endif\n\n#ifndef rtmGetStopRequestedPtr\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\n#endif\n\n#ifndef rtmGetT\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\n#endif\n\n#ifndef rtmGetTFinal\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\n#endif\n\n#ifndef rtmGetTPtr\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\n#endif\n\n/* Block signals (default storage) */\ntypedef struct {\n  real_T Time;                         /* '<Root>/Clock' */\n  real_T SineWave;                     /* '<Root>/Sine Wave' */\n} B_SFTimeSignalDemo_T;\n\n/* Block states (default storage) for system '<Root>' */\ntypedef struct {\n  struct {\n    void *LoggedData[2];\n  } Scope_PWORK;                       /* '<Root>/Scope' */\n} DW_SFTimeSignalDemo_T;\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_SFTimeSignalDemo_T {\n  const char_T *errorStatus;\n  RTWLogInfo *rtwLogInfo;\n  RTWExtModeInfo *extModeInfo;\n  RTWSolverInfo solverInfo;\n\n  /*\n   * DataMapInfo:\n   * The following substructure contains information regarding\n   * structures generated in the model's C API.\n   */\n  struct {\n    rtwCAPI_ModelMappingInfo mmi;\n  } DataMapInfo;\n\n  /*\n   * Sizes:\n   * The following substructure contains sizes information\n   * for many of the model attributes such as inputs, outputs,\n   * dwork, sample times, etc.\n   */\n  struct {\n    uint32_T checksums[4];\n  } Sizes;\n\n  /*\n   * SpecialInfo:\n   * The following substructure contains special information\n   * related to other components that are dependent on RTW.\n   */\n  struct {\n    const void *mappingInfo;\n  } SpecialInfo;\n\n  /*\n   * Timing:\n   * The following substructure contains information regarding\n   * the timing information for the model.\n   */\n  struct {\n    uint32_T clockTick0;\n    uint32_T clockTickH0;\n    time_T stepSize0;\n    uint32_T clockTick1;\n    uint32_T clockTickH1;\n    time_T tFinal;\n    SimTimeStep simTimeStep;\n    boolean_T stopRequestedFlag;\n    time_T *t;\n    time_T tArray[2];\n  } Timing;\n};\n\n/* Block signals (default storage) */\nextern B_SFTimeSignalDemo_T SFTimeSignalDemo_B;\n\n/* Block states (default storage) */\nextern DW_SFTimeSignalDemo_T SFTimeSignalDemo_DW;\n\n/* Model entry point functions */\nextern void SFTimeSignalDemo_initialize(void);\nextern void SFTimeSignalDemo_step(void);\nextern void SFTimeSignalDemo_terminate(void);\n\n/* Function to get C API Model Mapping Static Info */\nextern const rtwCAPI_ModelMappingStaticInfo*\n  SFTimeSignalDemo_GetCAPIStaticMap(void);\n\n/* Real-time Model object */\nextern RT_MODEL_SFTimeSignalDemo_T *const SFTimeSignalDemo_M;\n\n/*-\n * These blocks were eliminated from the model due to optimizations:\n *\n * Block '<Root>/Clock1' : Unused code path elimination\n */\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'SFTimeSignalDemo'\n */\n#endif                                 /* SFTimeSignalDemo_h_ */\n"},{"name":"SFTimeSignalDemo_private.h","type":"header","group":"model","path":"/Users/deshazere/General-Atomics/fusion/projects/IRAD-1340-API/redis-simulink/bus_sfunction_builder/SFTimeSignalDemo_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * SFTimeSignalDemo_private.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"SFTimeSignalDemo\".\n *\n * Model version              : 1.47\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\n * C source code generated on : Mon Aug 12 04:40:31 2024\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef SFTimeSignalDemo_private_h_\n#define SFTimeSignalDemo_private_h_\n#include \"rtwtypes.h\"\n#include \"builtin_typeid_types.h\"\n#include \"multiword_types.h\"\n#include \"SFTimeSignalDemo_types.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n\n/* Private macros used by the generated code to access rtModel */\n#ifndef rtmIsMajorTimeStep\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\n#endif\n\n#ifndef rtmIsMinorTimeStep\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\n#endif\n\n#ifndef rtmSetTFinal\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\n#endif\n\n#ifndef rtmSetTPtr\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\n#endif\n#endif                                 /* SFTimeSignalDemo_private_h_ */\n"},{"name":"SFTimeSignalDemo_types.h","type":"header","group":"model","path":"/Users/deshazere/General-Atomics/fusion/projects/IRAD-1340-API/redis-simulink/bus_sfunction_builder/SFTimeSignalDemo_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * SFTimeSignalDemo_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"SFTimeSignalDemo\".\n *\n * Model version              : 1.47\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\n * C source code generated on : Mon Aug 12 04:40:31 2024\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef SFTimeSignalDemo_types_h_\n#define SFTimeSignalDemo_types_h_\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_SFTimeSignalDemo_T RT_MODEL_SFTimeSignalDemo_T;\n\n#endif                                 /* SFTimeSignalDemo_types_h_ */\n"},{"name":"builtin_typeid_types.h","type":"header","group":"utility","path":"/Users/deshazere/General-Atomics/fusion/projects/IRAD-1340-API/redis-simulink/bus_sfunction_builder/SFTimeSignalDemo_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * builtin_typeid_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"SFTimeSignalDemo\".\n *\n * Model version              : 1.47\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\n * C source code generated on : Mon Aug 12 04:40:31 2024\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef BUILTIN_TYPEID_TYPES_H\n#define BUILTIN_TYPEID_TYPES_H\n#ifndef BUILTIN_TYPEID_TYPES\n#define BUILTIN_TYPEID_TYPES\n\n/* Enumeration of built-in data types */\ntypedef enum {\n  SS_DOUBLE = 0,\n  SS_SINGLE = 1,\n  SS_INT8 = 2,\n  SS_UINT8 = 3,\n  SS_INT16 = 4,\n  SS_UINT16 = 5,\n  SS_INT32 = 6,\n  SS_UINT32 = 7,\n  SS_BOOLEAN = 8\n} BuiltInDTypeId;\n\n#define SS_NUM_BUILT_IN_DTYPE          ((int)SS_BOOLEAN+1)\n\n/* Enumeration for MAT-file logging code */\ntypedef int DTypeId;\n\n/* Enumeration of pre-defined data types */\ntypedef enum {\n  SS_FCN_CALL = 9,\n  SS_INTEGER = 10,\n  SS_POINTER = 11,\n  SS_INTERNAL_DTYPE2 = 12,\n  SS_TIMER_UINT32_PAIR = 13,\n  SS_CONNECTION_TYPE = 14\n} PreDefinedDTypeId;\n\n#endif                                 /* BUILTIN_TYPEID_TYPES */\n#endif                                 /* BUILTIN_TYPEID_TYPES_H */\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"/Users/deshazere/General-Atomics/fusion/projects/IRAD-1340-API/redis-simulink/bus_sfunction_builder/SFTimeSignalDemo_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * multiword_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"SFTimeSignalDemo\".\n *\n * Model version              : 1.47\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\n * C source code generated on : Mon Aug 12 04:40:31 2024\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef MULTIWORD_TYPES_H\n#define MULTIWORD_TYPES_H\n#include \"rtwtypes.h\"\n\n/*\n * Definitions supporting external data access\n */\ntypedef int32_T chunk_T;\ntypedef uint32_T uchunk_T;\n\n/*\n * MultiWord supporting definitions\n */\ntypedef long int long_T;\n\n/*\n * MultiWord types\n */\ntypedef struct {\n  uint32_T chunks[2];\n} int64m_T;\n\ntypedef struct {\n  int64m_T re;\n  int64m_T im;\n} cint64m_T;\n\ntypedef struct {\n  uint32_T chunks[2];\n} uint64m_T;\n\ntypedef struct {\n  uint64m_T re;\n  uint64m_T im;\n} cuint64m_T;\n\ntypedef struct {\n  uint32_T chunks[3];\n} int96m_T;\n\ntypedef struct {\n  int96m_T re;\n  int96m_T im;\n} cint96m_T;\n\ntypedef struct {\n  uint32_T chunks[3];\n} uint96m_T;\n\ntypedef struct {\n  uint96m_T re;\n  uint96m_T im;\n} cuint96m_T;\n\ntypedef struct {\n  uint32_T chunks[4];\n} int128m_T;\n\ntypedef struct {\n  int128m_T re;\n  int128m_T im;\n} cint128m_T;\n\ntypedef struct {\n  uint32_T chunks[4];\n} uint128m_T;\n\ntypedef struct {\n  uint128m_T re;\n  uint128m_T im;\n} cuint128m_T;\n\ntypedef struct {\n  uint32_T chunks[5];\n} int160m_T;\n\ntypedef struct {\n  int160m_T re;\n  int160m_T im;\n} cint160m_T;\n\ntypedef struct {\n  uint32_T chunks[5];\n} uint160m_T;\n\ntypedef struct {\n  uint160m_T re;\n  uint160m_T im;\n} cuint160m_T;\n\ntypedef struct {\n  uint32_T chunks[6];\n} int192m_T;\n\ntypedef struct {\n  int192m_T re;\n  int192m_T im;\n} cint192m_T;\n\ntypedef struct {\n  uint32_T chunks[6];\n} uint192m_T;\n\ntypedef struct {\n  uint192m_T re;\n  uint192m_T im;\n} cuint192m_T;\n\ntypedef struct {\n  uint32_T chunks[7];\n} int224m_T;\n\ntypedef struct {\n  int224m_T re;\n  int224m_T im;\n} cint224m_T;\n\ntypedef struct {\n  uint32_T chunks[7];\n} uint224m_T;\n\ntypedef struct {\n  uint224m_T re;\n  uint224m_T im;\n} cuint224m_T;\n\ntypedef struct {\n  uint32_T chunks[8];\n} int256m_T;\n\ntypedef struct {\n  int256m_T re;\n  int256m_T im;\n} cint256m_T;\n\ntypedef struct {\n  uint32_T chunks[8];\n} uint256m_T;\n\ntypedef struct {\n  uint256m_T re;\n  uint256m_T im;\n} cuint256m_T;\n\ntypedef struct {\n  uint32_T chunks[9];\n} int288m_T;\n\ntypedef struct {\n  int288m_T re;\n  int288m_T im;\n} cint288m_T;\n\ntypedef struct {\n  uint32_T chunks[9];\n} uint288m_T;\n\ntypedef struct {\n  uint288m_T re;\n  uint288m_T im;\n} cuint288m_T;\n\ntypedef struct {\n  uint32_T chunks[10];\n} int320m_T;\n\ntypedef struct {\n  int320m_T re;\n  int320m_T im;\n} cint320m_T;\n\ntypedef struct {\n  uint32_T chunks[10];\n} uint320m_T;\n\ntypedef struct {\n  uint320m_T re;\n  uint320m_T im;\n} cuint320m_T;\n\ntypedef struct {\n  uint32_T chunks[11];\n} int352m_T;\n\ntypedef struct {\n  int352m_T re;\n  int352m_T im;\n} cint352m_T;\n\ntypedef struct {\n  uint32_T chunks[11];\n} uint352m_T;\n\ntypedef struct {\n  uint352m_T re;\n  uint352m_T im;\n} cuint352m_T;\n\ntypedef struct {\n  uint32_T chunks[12];\n} int384m_T;\n\ntypedef struct {\n  int384m_T re;\n  int384m_T im;\n} cint384m_T;\n\ntypedef struct {\n  uint32_T chunks[12];\n} uint384m_T;\n\ntypedef struct {\n  uint384m_T re;\n  uint384m_T im;\n} cuint384m_T;\n\ntypedef struct {\n  uint32_T chunks[13];\n} int416m_T;\n\ntypedef struct {\n  int416m_T re;\n  int416m_T im;\n} cint416m_T;\n\ntypedef struct {\n  uint32_T chunks[13];\n} uint416m_T;\n\ntypedef struct {\n  uint416m_T re;\n  uint416m_T im;\n} cuint416m_T;\n\ntypedef struct {\n  uint32_T chunks[14];\n} int448m_T;\n\ntypedef struct {\n  int448m_T re;\n  int448m_T im;\n} cint448m_T;\n\ntypedef struct {\n  uint32_T chunks[14];\n} uint448m_T;\n\ntypedef struct {\n  uint448m_T re;\n  uint448m_T im;\n} cuint448m_T;\n\ntypedef struct {\n  uint32_T chunks[15];\n} int480m_T;\n\ntypedef struct {\n  int480m_T re;\n  int480m_T im;\n} cint480m_T;\n\ntypedef struct {\n  uint32_T chunks[15];\n} uint480m_T;\n\ntypedef struct {\n  uint480m_T re;\n  uint480m_T im;\n} cuint480m_T;\n\ntypedef struct {\n  uint32_T chunks[16];\n} int512m_T;\n\ntypedef struct {\n  int512m_T re;\n  int512m_T im;\n} cint512m_T;\n\ntypedef struct {\n  uint32_T chunks[16];\n} uint512m_T;\n\ntypedef struct {\n  uint512m_T re;\n  uint512m_T im;\n} cuint512m_T;\n\ntypedef struct {\n  uint32_T chunks[17];\n} int544m_T;\n\ntypedef struct {\n  int544m_T re;\n  int544m_T im;\n} cint544m_T;\n\ntypedef struct {\n  uint32_T chunks[17];\n} uint544m_T;\n\ntypedef struct {\n  uint544m_T re;\n  uint544m_T im;\n} cuint544m_T;\n\ntypedef struct {\n  uint32_T chunks[18];\n} int576m_T;\n\ntypedef struct {\n  int576m_T re;\n  int576m_T im;\n} cint576m_T;\n\ntypedef struct {\n  uint32_T chunks[18];\n} uint576m_T;\n\ntypedef struct {\n  uint576m_T re;\n  uint576m_T im;\n} cuint576m_T;\n\ntypedef struct {\n  uint32_T chunks[19];\n} int608m_T;\n\ntypedef struct {\n  int608m_T re;\n  int608m_T im;\n} cint608m_T;\n\ntypedef struct {\n  uint32_T chunks[19];\n} uint608m_T;\n\ntypedef struct {\n  uint608m_T re;\n  uint608m_T im;\n} cuint608m_T;\n\ntypedef struct {\n  uint32_T chunks[20];\n} int640m_T;\n\ntypedef struct {\n  int640m_T re;\n  int640m_T im;\n} cint640m_T;\n\ntypedef struct {\n  uint32_T chunks[20];\n} uint640m_T;\n\ntypedef struct {\n  uint640m_T re;\n  uint640m_T im;\n} cuint640m_T;\n\ntypedef struct {\n  uint32_T chunks[21];\n} int672m_T;\n\ntypedef struct {\n  int672m_T re;\n  int672m_T im;\n} cint672m_T;\n\ntypedef struct {\n  uint32_T chunks[21];\n} uint672m_T;\n\ntypedef struct {\n  uint672m_T re;\n  uint672m_T im;\n} cuint672m_T;\n\ntypedef struct {\n  uint32_T chunks[22];\n} int704m_T;\n\ntypedef struct {\n  int704m_T re;\n  int704m_T im;\n} cint704m_T;\n\ntypedef struct {\n  uint32_T chunks[22];\n} uint704m_T;\n\ntypedef struct {\n  uint704m_T re;\n  uint704m_T im;\n} cuint704m_T;\n\ntypedef struct {\n  uint32_T chunks[23];\n} int736m_T;\n\ntypedef struct {\n  int736m_T re;\n  int736m_T im;\n} cint736m_T;\n\ntypedef struct {\n  uint32_T chunks[23];\n} uint736m_T;\n\ntypedef struct {\n  uint736m_T re;\n  uint736m_T im;\n} cuint736m_T;\n\ntypedef struct {\n  uint32_T chunks[24];\n} int768m_T;\n\ntypedef struct {\n  int768m_T re;\n  int768m_T im;\n} cint768m_T;\n\ntypedef struct {\n  uint32_T chunks[24];\n} uint768m_T;\n\ntypedef struct {\n  uint768m_T re;\n  uint768m_T im;\n} cuint768m_T;\n\ntypedef struct {\n  uint32_T chunks[25];\n} int800m_T;\n\ntypedef struct {\n  int800m_T re;\n  int800m_T im;\n} cint800m_T;\n\ntypedef struct {\n  uint32_T chunks[25];\n} uint800m_T;\n\ntypedef struct {\n  uint800m_T re;\n  uint800m_T im;\n} cuint800m_T;\n\ntypedef struct {\n  uint32_T chunks[26];\n} int832m_T;\n\ntypedef struct {\n  int832m_T re;\n  int832m_T im;\n} cint832m_T;\n\ntypedef struct {\n  uint32_T chunks[26];\n} uint832m_T;\n\ntypedef struct {\n  uint832m_T re;\n  uint832m_T im;\n} cuint832m_T;\n\ntypedef struct {\n  uint32_T chunks[27];\n} int864m_T;\n\ntypedef struct {\n  int864m_T re;\n  int864m_T im;\n} cint864m_T;\n\ntypedef struct {\n  uint32_T chunks[27];\n} uint864m_T;\n\ntypedef struct {\n  uint864m_T re;\n  uint864m_T im;\n} cuint864m_T;\n\ntypedef struct {\n  uint32_T chunks[28];\n} int896m_T;\n\ntypedef struct {\n  int896m_T re;\n  int896m_T im;\n} cint896m_T;\n\ntypedef struct {\n  uint32_T chunks[28];\n} uint896m_T;\n\ntypedef struct {\n  uint896m_T re;\n  uint896m_T im;\n} cuint896m_T;\n\ntypedef struct {\n  uint32_T chunks[29];\n} int928m_T;\n\ntypedef struct {\n  int928m_T re;\n  int928m_T im;\n} cint928m_T;\n\ntypedef struct {\n  uint32_T chunks[29];\n} uint928m_T;\n\ntypedef struct {\n  uint928m_T re;\n  uint928m_T im;\n} cuint928m_T;\n\ntypedef struct {\n  uint32_T chunks[30];\n} int960m_T;\n\ntypedef struct {\n  int960m_T re;\n  int960m_T im;\n} cint960m_T;\n\ntypedef struct {\n  uint32_T chunks[30];\n} uint960m_T;\n\ntypedef struct {\n  uint960m_T re;\n  uint960m_T im;\n} cuint960m_T;\n\ntypedef struct {\n  uint32_T chunks[31];\n} int992m_T;\n\ntypedef struct {\n  int992m_T re;\n  int992m_T im;\n} cint992m_T;\n\ntypedef struct {\n  uint32_T chunks[31];\n} uint992m_T;\n\ntypedef struct {\n  uint992m_T re;\n  uint992m_T im;\n} cuint992m_T;\n\ntypedef struct {\n  uint32_T chunks[32];\n} int1024m_T;\n\ntypedef struct {\n  int1024m_T re;\n  int1024m_T im;\n} cint1024m_T;\n\ntypedef struct {\n  uint32_T chunks[32];\n} uint1024m_T;\n\ntypedef struct {\n  uint1024m_T re;\n  uint1024m_T im;\n} cuint1024m_T;\n\ntypedef struct {\n  uint32_T chunks[33];\n} int1056m_T;\n\ntypedef struct {\n  int1056m_T re;\n  int1056m_T im;\n} cint1056m_T;\n\ntypedef struct {\n  uint32_T chunks[33];\n} uint1056m_T;\n\ntypedef struct {\n  uint1056m_T re;\n  uint1056m_T im;\n} cuint1056m_T;\n\ntypedef struct {\n  uint32_T chunks[34];\n} int1088m_T;\n\ntypedef struct {\n  int1088m_T re;\n  int1088m_T im;\n} cint1088m_T;\n\ntypedef struct {\n  uint32_T chunks[34];\n} uint1088m_T;\n\ntypedef struct {\n  uint1088m_T re;\n  uint1088m_T im;\n} cuint1088m_T;\n\ntypedef struct {\n  uint32_T chunks[35];\n} int1120m_T;\n\ntypedef struct {\n  int1120m_T re;\n  int1120m_T im;\n} cint1120m_T;\n\ntypedef struct {\n  uint32_T chunks[35];\n} uint1120m_T;\n\ntypedef struct {\n  uint1120m_T re;\n  uint1120m_T im;\n} cuint1120m_T;\n\ntypedef struct {\n  uint32_T chunks[36];\n} int1152m_T;\n\ntypedef struct {\n  int1152m_T re;\n  int1152m_T im;\n} cint1152m_T;\n\ntypedef struct {\n  uint32_T chunks[36];\n} uint1152m_T;\n\ntypedef struct {\n  uint1152m_T re;\n  uint1152m_T im;\n} cuint1152m_T;\n\ntypedef struct {\n  uint32_T chunks[37];\n} int1184m_T;\n\ntypedef struct {\n  int1184m_T re;\n  int1184m_T im;\n} cint1184m_T;\n\ntypedef struct {\n  uint32_T chunks[37];\n} uint1184m_T;\n\ntypedef struct {\n  uint1184m_T re;\n  uint1184m_T im;\n} cuint1184m_T;\n\ntypedef struct {\n  uint32_T chunks[38];\n} int1216m_T;\n\ntypedef struct {\n  int1216m_T re;\n  int1216m_T im;\n} cint1216m_T;\n\ntypedef struct {\n  uint32_T chunks[38];\n} uint1216m_T;\n\ntypedef struct {\n  uint1216m_T re;\n  uint1216m_T im;\n} cuint1216m_T;\n\ntypedef struct {\n  uint32_T chunks[39];\n} int1248m_T;\n\ntypedef struct {\n  int1248m_T re;\n  int1248m_T im;\n} cint1248m_T;\n\ntypedef struct {\n  uint32_T chunks[39];\n} uint1248m_T;\n\ntypedef struct {\n  uint1248m_T re;\n  uint1248m_T im;\n} cuint1248m_T;\n\ntypedef struct {\n  uint32_T chunks[40];\n} int1280m_T;\n\ntypedef struct {\n  int1280m_T re;\n  int1280m_T im;\n} cint1280m_T;\n\ntypedef struct {\n  uint32_T chunks[40];\n} uint1280m_T;\n\ntypedef struct {\n  uint1280m_T re;\n  uint1280m_T im;\n} cuint1280m_T;\n\ntypedef struct {\n  uint32_T chunks[41];\n} int1312m_T;\n\ntypedef struct {\n  int1312m_T re;\n  int1312m_T im;\n} cint1312m_T;\n\ntypedef struct {\n  uint32_T chunks[41];\n} uint1312m_T;\n\ntypedef struct {\n  uint1312m_T re;\n  uint1312m_T im;\n} cuint1312m_T;\n\ntypedef struct {\n  uint32_T chunks[42];\n} int1344m_T;\n\ntypedef struct {\n  int1344m_T re;\n  int1344m_T im;\n} cint1344m_T;\n\ntypedef struct {\n  uint32_T chunks[42];\n} uint1344m_T;\n\ntypedef struct {\n  uint1344m_T re;\n  uint1344m_T im;\n} cuint1344m_T;\n\ntypedef struct {\n  uint32_T chunks[43];\n} int1376m_T;\n\ntypedef struct {\n  int1376m_T re;\n  int1376m_T im;\n} cint1376m_T;\n\ntypedef struct {\n  uint32_T chunks[43];\n} uint1376m_T;\n\ntypedef struct {\n  uint1376m_T re;\n  uint1376m_T im;\n} cuint1376m_T;\n\ntypedef struct {\n  uint32_T chunks[44];\n} int1408m_T;\n\ntypedef struct {\n  int1408m_T re;\n  int1408m_T im;\n} cint1408m_T;\n\ntypedef struct {\n  uint32_T chunks[44];\n} uint1408m_T;\n\ntypedef struct {\n  uint1408m_T re;\n  uint1408m_T im;\n} cuint1408m_T;\n\ntypedef struct {\n  uint32_T chunks[45];\n} int1440m_T;\n\ntypedef struct {\n  int1440m_T re;\n  int1440m_T im;\n} cint1440m_T;\n\ntypedef struct {\n  uint32_T chunks[45];\n} uint1440m_T;\n\ntypedef struct {\n  uint1440m_T re;\n  uint1440m_T im;\n} cuint1440m_T;\n\ntypedef struct {\n  uint32_T chunks[46];\n} int1472m_T;\n\ntypedef struct {\n  int1472m_T re;\n  int1472m_T im;\n} cint1472m_T;\n\ntypedef struct {\n  uint32_T chunks[46];\n} uint1472m_T;\n\ntypedef struct {\n  uint1472m_T re;\n  uint1472m_T im;\n} cuint1472m_T;\n\ntypedef struct {\n  uint32_T chunks[47];\n} int1504m_T;\n\ntypedef struct {\n  int1504m_T re;\n  int1504m_T im;\n} cint1504m_T;\n\ntypedef struct {\n  uint32_T chunks[47];\n} uint1504m_T;\n\ntypedef struct {\n  uint1504m_T re;\n  uint1504m_T im;\n} cuint1504m_T;\n\ntypedef struct {\n  uint32_T chunks[48];\n} int1536m_T;\n\ntypedef struct {\n  int1536m_T re;\n  int1536m_T im;\n} cint1536m_T;\n\ntypedef struct {\n  uint32_T chunks[48];\n} uint1536m_T;\n\ntypedef struct {\n  uint1536m_T re;\n  uint1536m_T im;\n} cuint1536m_T;\n\ntypedef struct {\n  uint32_T chunks[49];\n} int1568m_T;\n\ntypedef struct {\n  int1568m_T re;\n  int1568m_T im;\n} cint1568m_T;\n\ntypedef struct {\n  uint32_T chunks[49];\n} uint1568m_T;\n\ntypedef struct {\n  uint1568m_T re;\n  uint1568m_T im;\n} cuint1568m_T;\n\ntypedef struct {\n  uint32_T chunks[50];\n} int1600m_T;\n\ntypedef struct {\n  int1600m_T re;\n  int1600m_T im;\n} cint1600m_T;\n\ntypedef struct {\n  uint32_T chunks[50];\n} uint1600m_T;\n\ntypedef struct {\n  uint1600m_T re;\n  uint1600m_T im;\n} cuint1600m_T;\n\ntypedef struct {\n  uint32_T chunks[51];\n} int1632m_T;\n\ntypedef struct {\n  int1632m_T re;\n  int1632m_T im;\n} cint1632m_T;\n\ntypedef struct {\n  uint32_T chunks[51];\n} uint1632m_T;\n\ntypedef struct {\n  uint1632m_T re;\n  uint1632m_T im;\n} cuint1632m_T;\n\ntypedef struct {\n  uint32_T chunks[52];\n} int1664m_T;\n\ntypedef struct {\n  int1664m_T re;\n  int1664m_T im;\n} cint1664m_T;\n\ntypedef struct {\n  uint32_T chunks[52];\n} uint1664m_T;\n\ntypedef struct {\n  uint1664m_T re;\n  uint1664m_T im;\n} cuint1664m_T;\n\ntypedef struct {\n  uint32_T chunks[53];\n} int1696m_T;\n\ntypedef struct {\n  int1696m_T re;\n  int1696m_T im;\n} cint1696m_T;\n\ntypedef struct {\n  uint32_T chunks[53];\n} uint1696m_T;\n\ntypedef struct {\n  uint1696m_T re;\n  uint1696m_T im;\n} cuint1696m_T;\n\ntypedef struct {\n  uint32_T chunks[54];\n} int1728m_T;\n\ntypedef struct {\n  int1728m_T re;\n  int1728m_T im;\n} cint1728m_T;\n\ntypedef struct {\n  uint32_T chunks[54];\n} uint1728m_T;\n\ntypedef struct {\n  uint1728m_T re;\n  uint1728m_T im;\n} cuint1728m_T;\n\ntypedef struct {\n  uint32_T chunks[55];\n} int1760m_T;\n\ntypedef struct {\n  int1760m_T re;\n  int1760m_T im;\n} cint1760m_T;\n\ntypedef struct {\n  uint32_T chunks[55];\n} uint1760m_T;\n\ntypedef struct {\n  uint1760m_T re;\n  uint1760m_T im;\n} cuint1760m_T;\n\ntypedef struct {\n  uint32_T chunks[56];\n} int1792m_T;\n\ntypedef struct {\n  int1792m_T re;\n  int1792m_T im;\n} cint1792m_T;\n\ntypedef struct {\n  uint32_T chunks[56];\n} uint1792m_T;\n\ntypedef struct {\n  uint1792m_T re;\n  uint1792m_T im;\n} cuint1792m_T;\n\ntypedef struct {\n  uint32_T chunks[57];\n} int1824m_T;\n\ntypedef struct {\n  int1824m_T re;\n  int1824m_T im;\n} cint1824m_T;\n\ntypedef struct {\n  uint32_T chunks[57];\n} uint1824m_T;\n\ntypedef struct {\n  uint1824m_T re;\n  uint1824m_T im;\n} cuint1824m_T;\n\ntypedef struct {\n  uint32_T chunks[58];\n} int1856m_T;\n\ntypedef struct {\n  int1856m_T re;\n  int1856m_T im;\n} cint1856m_T;\n\ntypedef struct {\n  uint32_T chunks[58];\n} uint1856m_T;\n\ntypedef struct {\n  uint1856m_T re;\n  uint1856m_T im;\n} cuint1856m_T;\n\ntypedef struct {\n  uint32_T chunks[59];\n} int1888m_T;\n\ntypedef struct {\n  int1888m_T re;\n  int1888m_T im;\n} cint1888m_T;\n\ntypedef struct {\n  uint32_T chunks[59];\n} uint1888m_T;\n\ntypedef struct {\n  uint1888m_T re;\n  uint1888m_T im;\n} cuint1888m_T;\n\ntypedef struct {\n  uint32_T chunks[60];\n} int1920m_T;\n\ntypedef struct {\n  int1920m_T re;\n  int1920m_T im;\n} cint1920m_T;\n\ntypedef struct {\n  uint32_T chunks[60];\n} uint1920m_T;\n\ntypedef struct {\n  uint1920m_T re;\n  uint1920m_T im;\n} cuint1920m_T;\n\ntypedef struct {\n  uint32_T chunks[61];\n} int1952m_T;\n\ntypedef struct {\n  int1952m_T re;\n  int1952m_T im;\n} cint1952m_T;\n\ntypedef struct {\n  uint32_T chunks[61];\n} uint1952m_T;\n\ntypedef struct {\n  uint1952m_T re;\n  uint1952m_T im;\n} cuint1952m_T;\n\ntypedef struct {\n  uint32_T chunks[62];\n} int1984m_T;\n\ntypedef struct {\n  int1984m_T re;\n  int1984m_T im;\n} cint1984m_T;\n\ntypedef struct {\n  uint32_T chunks[62];\n} uint1984m_T;\n\ntypedef struct {\n  uint1984m_T re;\n  uint1984m_T im;\n} cuint1984m_T;\n\ntypedef struct {\n  uint32_T chunks[63];\n} int2016m_T;\n\ntypedef struct {\n  int2016m_T re;\n  int2016m_T im;\n} cint2016m_T;\n\ntypedef struct {\n  uint32_T chunks[63];\n} uint2016m_T;\n\ntypedef struct {\n  uint2016m_T re;\n  uint2016m_T im;\n} cuint2016m_T;\n\ntypedef struct {\n  uint32_T chunks[64];\n} int2048m_T;\n\ntypedef struct {\n  int2048m_T re;\n  int2048m_T im;\n} cint2048m_T;\n\ntypedef struct {\n  uint32_T chunks[64];\n} uint2048m_T;\n\ntypedef struct {\n  uint2048m_T re;\n  uint2048m_T im;\n} cuint2048m_T;\n\n#endif                                 /* MULTIWORD_TYPES_H */\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"/Users/deshazere/General-Atomics/fusion/projects/IRAD-1340-API/redis-simulink/bus_sfunction_builder/SFTimeSignalDemo_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.c\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"SFTimeSignalDemo\".\n *\n * Model version              : 1.47\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\n * C source code generated on : Mon Aug 12 04:40:31 2024\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n#include \"rt_nonfinite.h\"\n#include \"math.h\"\n\nreal_T rtNaN = -(real_T)NAN;\nreal_T rtInf = (real_T)INFINITY;\nreal_T rtMinusInf = -(real_T)INFINITY;\nreal32_T rtNaNF = -(real32_T)NAN;\nreal32_T rtInfF = (real32_T)INFINITY;\nreal32_T rtMinusInfF = -(real32_T)INFINITY;\n\n/* Test if value is infinite */\nboolean_T rtIsInf(real_T value)\n{\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n}\n\n/* Test if single-precision value is infinite */\nboolean_T rtIsInfF(real32_T value)\n{\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n}\n\n/* Test if value is not a number */\nboolean_T rtIsNaN(real_T value)\n{\n  return (boolean_T)(isnan(value) != 0);\n}\n\n/* Test if single-precision value is not a number */\nboolean_T rtIsNaNF(real32_T value)\n{\n  return (boolean_T)(isnan(value) != 0);\n}\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/Users/deshazere/General-Atomics/fusion/projects/IRAD-1340-API/redis-simulink/bus_sfunction_builder/SFTimeSignalDemo_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"SFTimeSignalDemo\".\n *\n * Model version              : 1.47\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\n * C source code generated on : Mon Aug 12 04:40:31 2024\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef rt_nonfinite_h_\n#define rt_nonfinite_h_\n#include \"rtwtypes.h\"\n\nextern real_T rtInf;\nextern real_T rtMinusInf;\nextern real_T rtNaN;\nextern real32_T rtInfF;\nextern real32_T rtMinusInfF;\nextern real32_T rtNaNF;\nextern boolean_T rtIsInf(real_T value);\nextern boolean_T rtIsInfF(real32_T value);\nextern boolean_T rtIsNaN(real_T value);\nextern boolean_T rtIsNaNF(real32_T value);\n\n#endif                                 /* rt_nonfinite_h_ */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/Users/deshazere/General-Atomics/fusion/projects/IRAD-1340-API/redis-simulink/bus_sfunction_builder/SFTimeSignalDemo_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtwtypes.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"SFTimeSignalDemo\".\n *\n * Model version              : 1.47\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\n * C source code generated on : Mon Aug 12 04:40:31 2024\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n#include \"tmwtypes.h\"\n#ifndef POINTER_T\n#define POINTER_T\n\ntypedef void * pointer_T;\n\n#endif\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n#endif                                 /* RTWTYPES_H */\n"},{"name":"SFTimeSignalDemo_capi.c","type":"source","group":"interface","path":"/Users/deshazere/General-Atomics/fusion/projects/IRAD-1340-API/redis-simulink/bus_sfunction_builder/SFTimeSignalDemo_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n * SFTimeSignalDemo_capi.c\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"SFTimeSignalDemo\".\n *\n * Model version              : 1.47\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\n * C source code generated on : Mon Aug 12 04:40:31 2024\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#include \"rtw_capi.h\"\n#ifdef HOST_CAPI_BUILD\n#include \"SFTimeSignalDemo_capi_host.h\"\n#define sizeof(s)                      ((size_t)(0xFFFF))\n#undef rt_offsetof\n#define rt_offsetof(s,el)              ((uint16_T)(0xFFFF))\n#define TARGET_CONST\n#define TARGET_STRING(s)               (s)\n#else                                  /* HOST_CAPI_BUILD */\n#include \"builtin_typeid_types.h\"\n#include \"SFTimeSignalDemo.h\"\n#include \"SFTimeSignalDemo_capi.h\"\n#include \"SFTimeSignalDemo_private.h\"\n#ifdef LIGHT_WEIGHT_CAPI\n#define TARGET_CONST\n#define TARGET_STRING(s)               ((NULL))\n#else\n#define TARGET_CONST                   const\n#define TARGET_STRING(s)               (s)\n#endif\n#endif                                 /* HOST_CAPI_BUILD */\n\n/* Block output signal information */\nstatic const rtwCAPI_Signals rtBlockSignals[] = {\n  /* addrMapIndex, sysNum, blockPath,\n   * signalName, portNumber, dataTypeIndex, dimIndex, fxpIndex, sTimeIndex\n   */\n  { 0, 0, TARGET_STRING(\"SFTimeSignalDemo/Clock\"),\n    TARGET_STRING(\"Time\"), 0, 0, 0, 0, 0 },\n\n  { 1, 0, TARGET_STRING(\"SFTimeSignalDemo/Sine Wave\"),\n    TARGET_STRING(\"SineWave\"), 0, 0, 0, 0, 0 },\n\n  {\n    0, 0, (NULL), (NULL), 0, 0, 0, 0, 0\n  }\n};\n\n/* Individual block tuning is not valid when inline parameters is *\n * selected. An empty map is produced to provide a consistent     *\n * interface independent  of inlining parameters.                 *\n */\nstatic const rtwCAPI_BlockParameters rtBlockParameters[] = {\n  /* addrMapIndex, blockPath,\n   * paramName, dataTypeIndex, dimIndex, fixPtIdx\n   */\n  {\n    0, (NULL), (NULL), 0, 0, 0\n  }\n};\n\n/* Block states information */\nstatic const rtwCAPI_States rtBlockStates[] = {\n  /* addrMapIndex, contStateStartIndex, blockPath,\n   * stateName, pathAlias, dWorkIndex, dataTypeIndex, dimIndex,\n   * fixPtIdx, sTimeIndex, isContinuous, hierInfoIdx, flatElemIdx\n   */\n  {\n    0, -1, (NULL), (NULL), (NULL), 0, 0, 0, 0, 0, 0, -1, 0\n  }\n};\n\n/* Tunable variable parameters */\nstatic const rtwCAPI_ModelParameters rtModelParameters[] = {\n  /* addrMapIndex, varName, dataTypeIndex, dimIndex, fixPtIndex */\n  { 0, (NULL), 0, 0, 0 }\n};\n\n#ifndef HOST_CAPI_BUILD\n\n/* Declare Data Addresses statically */\nstatic void* rtDataAddrMap[] = {\n  &SFTimeSignalDemo_B.Time,            /* 0: Signal */\n  &SFTimeSignalDemo_B.SineWave,        /* 1: Signal */\n};\n\n/* Declare Data Run-Time Dimension Buffer Addresses statically */\nstatic int32_T* rtVarDimsAddrMap[] = {\n  (NULL)\n};\n\n#endif\n\n/* Data Type Map - use dataTypeMapIndex to access this structure */\nstatic TARGET_CONST rtwCAPI_DataTypeMap rtDataTypeMap[] = {\n  /* cName, mwName, numElements, elemMapIndex, dataSize, slDataId, *\n   * isComplex, isPointer, enumStorageType */\n  { \"double\", \"real_T\", 0, 0, sizeof(real_T), (uint8_T)SS_DOUBLE, 0, 0, 0 }\n};\n\n#ifdef HOST_CAPI_BUILD\n#undef sizeof\n#endif\n\n/* Structure Element Map - use elemMapIndex to access this structure */\nstatic TARGET_CONST rtwCAPI_ElementMap rtElementMap[] = {\n  /* elementName, elementOffset, dataTypeIndex, dimIndex, fxpIndex */\n  { (NULL), 0, 0, 0, 0 },\n};\n\n/* Dimension Map - use dimensionMapIndex to access elements of ths structure*/\nstatic const rtwCAPI_DimensionMap rtDimensionMap[] = {\n  /* dataOrientation, dimArrayIndex, numDims, vardimsIndex */\n  { rtwCAPI_SCALAR, 0, 2, 0 }\n};\n\n/* Dimension Array- use dimArrayIndex to access elements of this array */\nstatic const uint_T rtDimensionArray[] = {\n  1,                                   /* 0 */\n  1                                    /* 1 */\n};\n\n/* C-API stores floating point values in an array. The elements of this  *\n * are unique. This ensures that values which are shared across the model*\n * are stored in the most efficient way. These values are referenced by  *\n *           - rtwCAPI_FixPtMap.fracSlopePtr,                            *\n *           - rtwCAPI_FixPtMap.biasPtr,                                 *\n *           - rtwCAPI_SampleTimeMap.samplePeriodPtr,                    *\n *           - rtwCAPI_SampleTimeMap.sampleOffsetPtr                     */\nstatic const real_T rtcapiStoredFloats[] = {\n  0.0\n};\n\n/* Fixed Point Map */\nstatic const rtwCAPI_FixPtMap rtFixPtMap[] = {\n  /* fracSlopePtr, biasPtr, scaleType, wordLength, exponent, isSigned */\n  { (NULL), (NULL), rtwCAPI_FIX_RESERVED, 0, 0, (boolean_T)0 },\n};\n\n/* Sample Time Map - use sTimeIndex to access elements of ths structure */\nstatic const rtwCAPI_SampleTimeMap rtSampleTimeMap[] = {\n  /* samplePeriodPtr, sampleOffsetPtr, tid, samplingMode */\n  { (const void *) &rtcapiStoredFloats[0], (const void *) &rtcapiStoredFloats[0],\n    (int8_T)0, (uint8_T)0 }\n};\n\nstatic rtwCAPI_ModelMappingStaticInfo mmiStatic = {\n  /* Signals:{signals, numSignals,\n   *           rootInputs, numRootInputs,\n   *           rootOutputs, numRootOutputs},\n   * Params: {blockParameters, numBlockParameters,\n   *          modelParameters, numModelParameters},\n   * States: {states, numStates},\n   * Maps:   {dataTypeMap, dimensionMap, fixPtMap,\n   *          elementMap, sampleTimeMap, dimensionArray},\n   * TargetType: targetType\n   */\n  { rtBlockSignals, 2,\n    (NULL), 0,\n    (NULL), 0 },\n\n  { rtBlockParameters, 0,\n    rtModelParameters, 0 },\n\n  { rtBlockStates, 0 },\n\n  { rtDataTypeMap, rtDimensionMap, rtFixPtMap,\n    rtElementMap, rtSampleTimeMap, rtDimensionArray },\n  \"float\",\n\n  { 3983486012U,\n    942521878U,\n    480808705U,\n    1430772357U },\n  (NULL), 0,\n  (boolean_T)0\n};\n\n/* Function to get C API Model Mapping Static Info */\nconst rtwCAPI_ModelMappingStaticInfo*\n  SFTimeSignalDemo_GetCAPIStaticMap(void)\n{\n  return &mmiStatic;\n}\n\n/* Cache pointers into DataMapInfo substructure of RTModel */\n#ifndef HOST_CAPI_BUILD\n\nvoid SFTimeSignalDemo_InitializeDataMapInfo(void)\n{\n  /* Set C-API version */\n  rtwCAPI_SetVersion(SFTimeSignalDemo_M->DataMapInfo.mmi, 1);\n\n  /* Cache static C-API data into the Real-time Model Data structure */\n  rtwCAPI_SetStaticMap(SFTimeSignalDemo_M->DataMapInfo.mmi, &mmiStatic);\n\n  /* Cache static C-API logging data into the Real-time Model Data structure */\n  rtwCAPI_SetLoggingStaticMap(SFTimeSignalDemo_M->DataMapInfo.mmi, (NULL));\n\n  /* Cache C-API Data Addresses into the Real-Time Model Data structure */\n  rtwCAPI_SetDataAddressMap(SFTimeSignalDemo_M->DataMapInfo.mmi, rtDataAddrMap);\n\n  /* Cache C-API Data Run-Time Dimension Buffer Addresses into the Real-Time Model Data structure */\n  rtwCAPI_SetVarDimsAddressMap(SFTimeSignalDemo_M->DataMapInfo.mmi,\n    rtVarDimsAddrMap);\n\n  /* Cache the instance C-API logging pointer */\n  rtwCAPI_SetInstanceLoggingInfo(SFTimeSignalDemo_M->DataMapInfo.mmi, (NULL));\n\n  /* Set reference to submodels */\n  rtwCAPI_SetChildMMIArray(SFTimeSignalDemo_M->DataMapInfo.mmi, (NULL));\n  rtwCAPI_SetChildMMIArrayLen(SFTimeSignalDemo_M->DataMapInfo.mmi, 0);\n}\n\n#else                                  /* HOST_CAPI_BUILD */\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  void SFTimeSignalDemo_host_InitializeDataMapInfo\n    (SFTimeSignalDemo_host_DataMapInfo_T *dataMap, const char *path)\n  {\n    /* Set C-API version */\n    rtwCAPI_SetVersion(dataMap->mmi, 1);\n\n    /* Cache static C-API data into the Real-time Model Data structure */\n    rtwCAPI_SetStaticMap(dataMap->mmi, &mmiStatic);\n\n    /* host data address map is NULL */\n    rtwCAPI_SetDataAddressMap(dataMap->mmi, (NULL));\n\n    /* host vardims address map is NULL */\n    rtwCAPI_SetVarDimsAddressMap(dataMap->mmi, (NULL));\n\n    /* Set Instance specific path */\n    rtwCAPI_SetPath(dataMap->mmi, path);\n    rtwCAPI_SetFullPath(dataMap->mmi, (NULL));\n\n    /* Set reference to submodels */\n    rtwCAPI_SetChildMMIArray(dataMap->mmi, (NULL));\n    rtwCAPI_SetChildMMIArrayLen(dataMap->mmi, 0);\n  }\n\n#ifdef __cplusplus\n\n}\n\n#endif\n#endif                                 /* HOST_CAPI_BUILD */\n\n/* EOF: SFTimeSignalDemo_capi.c */\n"},{"name":"SFTimeSignalDemo_capi.h","type":"header","group":"interface","path":"/Users/deshazere/General-Atomics/fusion/projects/IRAD-1340-API/redis-simulink/bus_sfunction_builder/SFTimeSignalDemo_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n * SFTimeSignalDemo_capi.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"SFTimeSignalDemo\".\n *\n * Model version              : 1.47\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\n * C source code generated on : Mon Aug 12 04:40:31 2024\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef SFTimeSignalDemo_capi_h_\n#define SFTimeSignalDemo_capi_h_\n#include \"SFTimeSignalDemo.h\"\n\nextern void SFTimeSignalDemo_InitializeDataMapInfo(void);\n\n#endif                                 /* SFTimeSignalDemo_capi_h_ */\n\n/* EOF: SFTimeSignalDemo_capi.h */\n"},{"name":"SFTimeSignalDemo_dt.h","type":"header","group":"interface","path":"/Users/deshazere/General-Atomics/fusion/projects/IRAD-1340-API/redis-simulink/bus_sfunction_builder/SFTimeSignalDemo_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n * SFTimeSignalDemo_dt.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"SFTimeSignalDemo\".\n *\n * Model version              : 1.47\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\n * C source code generated on : Mon Aug 12 04:40:31 2024\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#include \"ext_types.h\"\n\n/* data type size table */\nstatic uint_T rtDataTypeSizes[] = {\n  sizeof(real_T),\n  sizeof(real32_T),\n  sizeof(int8_T),\n  sizeof(uint8_T),\n  sizeof(int16_T),\n  sizeof(uint16_T),\n  sizeof(int32_T),\n  sizeof(uint32_T),\n  sizeof(boolean_T),\n  sizeof(fcn_call_T),\n  sizeof(int_T),\n  sizeof(pointer_T),\n  sizeof(action_T),\n  2*sizeof(uint32_T),\n  sizeof(int32_T),\n  sizeof(uint_T),\n  sizeof(char_T),\n  sizeof(uchar_T),\n  sizeof(time_T)\n};\n\n/* data type name table */\nstatic const char_T * rtDataTypeNames[] = {\n  \"real_T\",\n  \"real32_T\",\n  \"int8_T\",\n  \"uint8_T\",\n  \"int16_T\",\n  \"uint16_T\",\n  \"int32_T\",\n  \"uint32_T\",\n  \"boolean_T\",\n  \"fcn_call_T\",\n  \"int_T\",\n  \"pointer_T\",\n  \"action_T\",\n  \"timer_uint32_pair_T\",\n  \"physical_connection\",\n  \"uint_T\",\n  \"char_T\",\n  \"uchar_T\",\n  \"time_T\"\n};\n\n/* data type transitions for block I/O structure */\nstatic DataTypeTransition rtBTransitions[] = {\n  { (char_T *)(&SFTimeSignalDemo_B.Time), 0, 0, 2 }\n  ,\n\n  { (char_T *)(&SFTimeSignalDemo_DW.Scope_PWORK.LoggedData[0]), 11, 0, 2 }\n};\n\n/* data type transition table for block I/O structure */\nstatic DataTypeTransitionTable rtBTransTable = {\n  2U,\n  rtBTransitions\n};\n\n/* [EOF] SFTimeSignalDemo_dt.h */\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/Users/deshazere/General-Atomics/fusion/projects/IRAD-1340-API/redis-simulink/bus_sfunction_builder/SFTimeSignalDemo_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n *  rtmodel.h:\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"SFTimeSignalDemo\".\n *\n * Model version              : 1.47\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\n * C source code generated on : Mon Aug 12 04:40:31 2024\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef rtmodel_h_\n#define rtmodel_h_\n#include \"SFTimeSignalDemo.h\"\n#define GRTINTERFACE                   0\n#endif                                 /* rtmodel_h_ */\n"},{"name":"SFTimeSignalDemo_capi_host.h","type":"header","group":"other","path":"/Users/deshazere/General-Atomics/fusion/projects/IRAD-1340-API/redis-simulink/bus_sfunction_builder/SFTimeSignalDemo_grt_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef SFTimeSignalDemo_cap_host_h__\n#define SFTimeSignalDemo_cap_host_h__\n#ifdef HOST_CAPI_BUILD\n#include \"rtw_capi.h\"\n#include \"rtw_modelmap.h\"\n\ntypedef struct {\n  rtwCAPI_ModelMappingInfo mmi;\n} SFTimeSignalDemo_host_DataMapInfo_T;\n\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  void SFTimeSignalDemo_host_InitializeDataMapInfo\n    (SFTimeSignalDemo_host_DataMapInfo_T *dataMap, const char *path);\n\n#ifdef __cplusplus\n\n}\n\n#endif\n#endif                                 /* HOST_CAPI_BUILD */\n#endif                                 /* SFTimeSignalDemo_cap_host_h__ */\n\n/* EOF: SFTimeSignalDemo_capi_host.h */\n"},{"name":"ext_svr.c","type":"source","group":"legacy","path":"/Applications/MATLAB_R2024a.app/rtw/c/src/ext_mode/common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2021 The MathWorks, Inc.\n *\n * File: ext_svr.c     \n *\n * Abstract:\n *  External mode server interface (TCPIP example).  Provides functions\n *  that get called by main routine (model-name.c):\n *    o ExtParseArgsAndInitUD:  parse args and create UserData\n *    o ExtWaitForStartPkt:     return true if waiting for host to start\n *    o rt_ExtModeInit:         external mode initialization\n *    o rt_ExtModeSleep:        pause the process\n *    o rt_PktServerWork:       server for setting/getting packets from host\n *    o rt_PktServer:           server dispatcher - for multi-tasking targets\n *    o rt_UploadServerWork:    server for setting data upload packets on host\n *    o rt_UploadServer:        server dispatcher - for multi-tasking targets\n *    o rt_ExtModeShutdown:     external mode termination\n *\n *  Parameter downloading and data uploading supported for single and\n *  multi-tasking targets.\n */\n\n/*****************\n * Include files *\n *****************/\n\n/*ANSI C headers*/\n#ifndef EXTMODE_DISABLEPRINTF  \n#include <stdio.h>\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#if defined(VXWORKS)\n /*VxWorks headers*/\n# include <selectLib.h>\n# include <sockLib.h>\n# include <inetLib.h>\n# include <ioLib.h>\n# include <taskLib.h>\n#endif\n\n/*Real Time Workshop headers*/\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"rtw_extmode.h\"\n\n#include \"ext_types.h\"\n#include \"ext_share.h\"\n#include \"ext_test.h\"\n#include \"ext_svr_transport.h\"\n#include \"updown.h\"\n#include \"updown_util.h\"\n#include \"dt_info.h\"\n\n\n/*Uncomment to test 4 byte reals*/\n/*#define real_T float*/\n\n/***********************\n * Logical definitions *\n ***********************/\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\n/**********************\n * External Variables *\n **********************/\nextern int_T           volatile startModel;\nextern TargetSimStatus volatile modelStatus;\n#ifdef VXWORKS\nextern SEM_ID uploadSem;\nextern SEM_ID pktSem;\n#endif\nextern boolean_T host_upstatus_is_uploading;\n\n/********************\n * Global Variables *\n ********************/\n\n/*\n * Flags.\n */\nPRIVATE boolean_T   connected       = false;\nPRIVATE boolean_T   commInitialized = false;\nboolean_T gblSetParamPktReceived = false;\n\n/*\n * Pointer to opaque user data (defined by ext_svr_transport.c).\n */\nPRIVATE ExtUserData *extUD          = NULL;\n\n/*\n * Buffer used to receive packets.\n */\nPRIVATE int_T pktBufSize = 0;\nPRIVATE char  *pktBuf    = NULL;\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n#ifndef EXTMODE_DISABLEPRINTF \nPRIVATE char ERRMSG_PROCESSSELECTSIGNAL[] = \n            \"\\nError in UploadLogInfoInit(). Most likely a memory\\n\"\n            \"allocation error or an attempt to re-initialize the\\n\"\n            \"signal selection during the data logging process\\n\"\n            \"(i.e., multiple EXT_SELECT_SIGNAL packets were received\\n\"\n            \"before the logging session terminated or an\\n\"\n            \"EXT_CANCEL_LOGGING packet was received)\\n\";\n\nPRIVATE char ERRMSG_PROCESSSELECTTRIGGER[] = \n            \"\\nError in UploadInitTrigger(). Most likely a memory\\n\"\n            \"allocation error or an attempt to re-initialize the\\n\"\n            \"trigger selection during the data logging process\\n\"\n            \"(i.e., multiple EXT_SELECT_TRIGGER packets were received\\n\"\n            \"before the logging session terminated or an\\n\"\n            \"EXT_CANCEL_LOGGING packet was received)\\n\";\n#else\nPRIVATE char ERRMSG_PROCESSSELECTSIGNAL[] = \"\";\nPRIVATE char ERRMSG_PROCESSSELECTTRIGGER[] = \"\";\n#endif\n#endif\n\n/********************\n *  If DAEMON_MODE  *\n ********************/\n#ifdef DAEMON_MODE\n/*\n * This defines the size of each data chunk (in bytes) that the\n * daemon acknowledgment scheme uses for large data\n */\nconst int_T daemonChunkSize = 32;\n#endif\n\nPRIVATE boolean_T SendPktHdrToHost(const ExtModeAction action,\n                                         const int size);\n\n/*******************\n * Local Functions *\n *******************/\n\n/* Function: GrowRecvBufIfNeeded ===============================================\n * Abstract:\n *  Allocate or increase the size of buffer for receiving packets from target.\n */\nPRIVATE boolean_T GrowRecvBufIfNeeded(const int pktSize)\n{\n    if (pktSize > pktBufSize) {\n        if (pktBuf != NULL) {\n            free(pktBuf);\n            pktBufSize = 0;\n        }\n\n        pktBuf = (char *)malloc(pktSize);\n        if (pktBuf == NULL) return(EXT_ERROR);\n\n        pktBufSize = pktSize;\n    }\n    return(EXT_NO_ERROR);\n} /* end GrowRecvBufIfNeeded */\n\n\n/* Function: GetPktHdr =========================================================\n * Abstract:\n *  Attempts to retrieve a packet header from the host.  If a header is in \n *  fact retrieved, the reference arg, 'hdrAvail' will be returned as true.\n *\n *  EXT_NO_ERROR is returned on success, EXT_ERROR is returned on failure.\n *\n * NOTES:\n *  o It is not necessarily an error for 'hdrAvail' to be returned as false.\n *    It typically means that we were polling for packets and none were\n *    available.\n */\nPRIVATE boolean_T GetPktHdr(PktHeader *pktHdr, boolean_T *hdrAvail)\n{\n    int_T     nGot      = 0; /* assume */\n    int_T     nGotTotal = 0;\n    int_T     pktSize   = sizeof(PktHeader);\n    boolean_T error     = EXT_NO_ERROR;\n    \n    /* Get the header. */\n    while(nGotTotal < pktSize) {\n        error = ExtGetHostPkt(extUD,\n            pktSize - nGotTotal, &nGot, (char_T *)((char_T *)pktHdr + nGotTotal));\n        if (error) goto EXIT_POINT;\n\n        nGotTotal += nGot;\n\n        if (nGotTotal == 0) break;\n    }\n    assert((nGot == 0) || (nGotTotal == pktSize));\n\nEXIT_POINT:\n    *hdrAvail = (boolean_T)(nGot > 0);\n    return(error);\n} /* end GetPktHdr */\n\n\n/* Function: ClearPkt ==========================================================\n * Abstract:\n *  Remove the data from the communication line one byte at a time.  This\n *  function is called when there was not enough memory to receive an entire\n *  packet.  Since the data was never received, it must be discarded so that\n *  other packets can be sent.\n */\nPRIVATE void ClearPkt(const int pktSize)\n{\n    int_T     nGot;\n    boolean_T error     = EXT_NO_ERROR;\n    int_T     nGotTotal = 0;\n    char      buffer;\n\n    /* Get and discard the data one char at a time. */\n    while(nGotTotal < pktSize) {\n        error = ExtGetHostPkt(extUD, 1, &nGot, (char_T *)&buffer);\n        if (error) {\n#ifndef EXTMODE_DISABLEPRINTF            \n            fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n            goto EXIT_POINT;\n        }\n        nGotTotal += nGot;\n    }\n\nEXIT_POINT:\n    return;\n\n} /* end ClearPkt */\n\n#ifdef DAEMON_MODE\n/* Function: ClearPktUsingAck ==================================================\n * Abstract:\n *  Derived from ClearPkt(). For the general behaviour see ClearPkt() above.\n *  This variant is used by DAEMON_MODE to clear data in small chunks.\n *  After receiving each chunk reply with a EXT_DAEMON_ACK.\n */\nPRIVATE void ClearPktUsingAck(const int pktSize)\n{\n    int_T     nGot;\n    boolean_T error     = EXT_NO_ERROR;\n    int_T     nGotTotal = 0;\n    char      buffer;\n    \n    int_T     i;\n    int_T     nChunks   = pktSize/daemonChunkSize;\n    int_T     bytesLeft = pktSize%daemonChunkSize;\n\n    /* Get and discard the data one char at a time.\n\t * Receive chunks here, and reply with ack after receiving each chunk\n\t */\n    for(i=0; i<nChunks; i++){\n        nGotTotal = 0;\n        while(nGotTotal < daemonChunkSize){\n            error = ExtGetHostPkt(extUD,\n                        1,\n                        &nGot,\n                        (char_T *)&buffer);\n            if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n                fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n                goto EXIT_POINT;\n            }\n            nGotTotal += nGot;\n        }\n        SendPktHdrToHost(EXT_DAEMON_ACK, 0);\n    }\n    \n    /*\n\t * Receive the bytes left over and reply with an ack after you receive all\n\t */\n    nGotTotal=0;\n    if(bytesLeft != 0){\n        while(nGotTotal<bytesLeft){\n            error = ExtGetHostPkt(extUD,\n                        1,\n                        &nGot,\n                        (char_T *)&buffer);\n            if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n                fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n                goto EXIT_POINT;\n            }\n        nGotTotal += nGot;\n        }\n        SendPktHdrToHost(EXT_DAEMON_ACK, 0);\n    }\n\nEXIT_POINT:\n    return;\n\n} /* end ClearPktUsingAck */\n#endif\n\n\n/* Function: GetPkt ============================================================\n * Abstract:\n *  Receive nBytes from the host.  Return a buffer containing the bytes or\n *  NULL if an error occurs.  Note that the pointer returned is that of the\n *  global pktBuf.  If the buf needs to be grown to accommodate the package,\n *  it is realloc'd.  This function will try to get the requested number\n *  of bytes indefinitely - it is assumed that the data is either already there,\n *  or will show up in a \"reasonable\" amount of time.\n */\nPRIVATE const char *GetPkt(const int pktSize)\n{\n    int_T     nGot;\n    boolean_T error     = EXT_NO_ERROR;\n    int_T     nGotTotal = 0;\n\n    error = GrowRecvBufIfNeeded(pktSize);\n    if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"Previous pkt from host thrown away due to lack of memory.\\n\");\n#endif\n        ClearPkt(pktSize);\n        goto EXIT_POINT;\n    }\n    \n    /* Get the data. */\n    while(nGotTotal < pktSize) {\n        error = ExtGetHostPkt(extUD,\n            pktSize - nGotTotal, &nGot, (char_T *)(pktBuf + nGotTotal));\n        if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n            fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n            goto EXIT_POINT;\n        }\n\n    nGotTotal += nGot;\n    }\n\nEXIT_POINT:\n    return((error == EXT_NO_ERROR) ? pktBuf : NULL);\n} /* end GetPkt */\n\n#ifdef DAEMON_MODE\n/* Function: GetPktUsingAck ============================================================\n * Abstract:\n *  Derived from GetPkt(). For the general behaviour see GetPkt() above.\n *  This variant is used by DAEMON_MODE to fetch data in small chunks.\n *  After receiving each chunk reply with a EXT_DAEMON_ACK.\n */\nPRIVATE const char *GetPktUsingAck(const int pktSize)\n{\n    int_T     nGot;\n    boolean_T error     = EXT_NO_ERROR;\n    int_T     nGotTotal = 0;\n    \n    int_T     i;\n    int_T     nChunks   = pktSize/daemonChunkSize;\n    int_T     bytesLeft = pktSize%daemonChunkSize;\n\n    error = GrowRecvBufIfNeeded(pktSize);\n    if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"Previous pkt from host thrown away due to lack of memory.\\n\");\n#endif\n        ClearPktUsingAck(pktSize);\n        goto EXIT_POINT;\n    }\n    \n    /*\n\t * Receive chunks here, and reply with ack after receiving each chunk\n\t */\n    for(i=0; i<nChunks; i++){\n        nGotTotal = 0;\n        while(nGotTotal < daemonChunkSize){\n            error = ExtGetHostPkt(extUD,\n                        daemonChunkSize - nGotTotal,\n                        &nGot,\n                        (char_T *)(pktBuf + i*daemonChunkSize + nGotTotal));\n            if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n                fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n            goto EXIT_POINT;\n            }\n            nGotTotal += nGot;\n        }\n        SendPktHdrToHost(EXT_DAEMON_ACK, 0);\n    }\n    \n    /*\n\t * Receive the bytes left over and reply with an ack after you receive all\n\t */\n    nGotTotal=0;\n    if(bytesLeft != 0){\n        while(nGotTotal<bytesLeft){\n            error = ExtGetHostPkt(extUD,\n                        bytesLeft - nGotTotal,\n                        &nGot,\n                        (char_T *)(pktBuf + i*daemonChunkSize + nGotTotal));\n            if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n                fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n                goto EXIT_POINT;\n            }\n        nGotTotal += nGot;\n        }\n        SendPktHdrToHost(EXT_DAEMON_ACK, 0);\n    }\n\nEXIT_POINT:\n    return((error == EXT_NO_ERROR) ? pktBuf : NULL);\n} /* end GetPktUsingAck */\n#endif\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Forward declaration */\nvoid UploadServerWork(int32_T, int_T numSampTimes);\n#endif\n\n/* Function: DisconnectFromHost ================================================\n * Abstract:\n *  Disconnect from the host.\n */\nPRIVATE void DisconnectFromHost(int_T numSampTimes)\n{\n    int i;\n    boolean_T upload_signals = host_upstatus_is_uploading;\n\n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadPrepareForFinalFlush(i);\n\n#if defined(VXWORKS)\n        /*\n         * UploadPrepareForFinalFlush() has already called semGive(uploadSem)\n         * two times.  Now the server thread will wait until the upload thread\n         * has processed all of the data in the buffers for the final upload\n         * and exhausted the uploadSem semaphores.  If the server thread\n         * attempts to call UploadServerWork() while the upload thread is in\n         * the middle of processing the buffers, the target code may crash\n         * with a NULL pointer exception (the buffers are destroyed after\n         * calling UploadLogInfoTerm).\n         */\n        while(semTake(uploadSem, NO_WAIT) != ERROR) {\n            semGive(uploadSem);\n            taskDelay(1000);\n        }\n#else\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        if (upload_signals) {\n            UploadServerWork(i, numSampTimes);\n        }\n#endif\n#endif\n\n        UploadLogInfoTerm(i, numSampTimes);\n    }\n    \n    connected       = false;\n    commInitialized = false;\n    \n    ExtCloseConnection(extUD);\n} /* end DisconnectFromHost */\n\n\n/* Function: ForceDisconnectFromHost ===========================================\n * Abstract:\n *  Force a disconnect from the host.  This is not a graceful shutdown and\n *  should only be used when the integrity of the external mode connection\n *  is in question.  To shutdown the connection gracefully, use\n *  DisconnectFromHost().\n */\nPRIVATE void ForceDisconnectFromHost(int_T numSampTimes)\n{\n    int i;\n    connected       = false;\n    commInitialized = false;\n\n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadEndLoggingSession(i, numSampTimes);\n    }\n\n    ExtForceDisconnect(extUD);\n} /* end ForceDisconnectFromHost */\n\n\n/* Function: ProcessConnectPkt =================================================\n * Abstract:\n *  Process the EXT_CONNECT packet and send response to host.\n */\nPRIVATE boolean_T ProcessConnectPkt(RTWExtModeInfo *ei)\n{\n    int_T                   nSet;\n    PktHeader               pktHdr;\n    int_T                   tmpBufSize;\n    uint32_T                *tmpBuf = NULL;\n    boolean_T               error   = EXT_NO_ERROR;\n    \n    const DataTypeTransInfo *dtInfo    = (const DataTypeTransInfo *) rteiGetModelMappingInfo(ei);\n    uint_T                  *dtSizes   = dtGetDataTypeSizes(dtInfo);\n    int_T                   nDataTypes = dtGetNumDataTypes(dtInfo);\n\n    assert(connected);\n    assert(!commInitialized);\n\n    /*\n     * Send the 1st of two EXT_CONNECT_RESPONSE packets to the host. \n     * The packet consists purely of the pktHeader.  In this special\n     * case the pktSize actually contains the number of bits per byte\n     * (not always 8 - see TI compiler for C30 and C40).\n     */\n    pktHdr.type = (uint32_T)EXT_CONNECT_RESPONSE;\n    pktHdr.size = (uint32_T)8; /* 8 bits per byte */\n\n    error = ExtSetHostPkt(extUD,sizeof(pktHdr),(char_T *)&pktHdr,&nSet);\n    if (error || (nSet != sizeof(pktHdr))) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\n            \"ExtSetHostPkt() failed for 1st EXT_CONNECT_RESPONSE.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n\n    /* Send 2nd EXT_CONNECT_RESPONSE packet containing the following \n     * fields:\n     *\n     * CS1 - checksum 1 (uint32_T)\n     * CS2 - checksum 2 (uint32_T)\n     * CS3 - checksum 3 (uint32_T)\n     * CS4 - checksum 4 (uint32_T)\n     *\n     * intCodeOnly   - flag indicating if target is integer only (uint32_T)\n     * \n     * MWChunkSize   - multiword data type chunk size on target (uint32_T)\n     * \n     * targetStatus  - the status of the target (uint32_T)\n     *\n     * nDataTypes    - # of data types        (uint32_T)\n     * dataTypeSizes - 1 per nDataTypes       (uint32_T[])\n     */\n\n    {\n        int nPktEls    = 4 +                        /* checkSums       */\n                         1 +                        /* intCodeOnly     */\n                         1 +                        /* MW chunk size   */\n                         1 +                        /* targetStatus    */\n                         1 +                        /* nDataTypes      */\n                         dtGetNumDataTypes(dtInfo); /* data type sizes */\n\n        tmpBufSize = nPktEls * sizeof(uint32_T);\n        tmpBuf     = (uint32_T *)malloc(tmpBufSize);\n        if (tmpBuf == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;\n        }\n    }\n    \n    /* Send packet header. */\n    pktHdr.type = EXT_CONNECT_RESPONSE;\n    pktHdr.size = tmpBufSize;\n\n    error = ExtSetHostPkt(extUD,sizeof(pktHdr),(char_T *)&pktHdr,&nSet);\n    if (error || (nSet != sizeof(pktHdr))) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\n            \"ExtSetHostPkt() failed for 2nd EXT_CONNECT_RESPONSE.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n   \n    /* Checksums, target status & SL_DOUBLESize. */\n    tmpBuf[0] = rteiGetChecksum0(ei);\n    tmpBuf[1] = rteiGetChecksum1(ei);\n    tmpBuf[2] = rteiGetChecksum2(ei);\n    tmpBuf[3] = rteiGetChecksum3(ei);\n\n#if INTEGER_CODE == 0\n    tmpBuf[4] = (uint32_T)0;\n#else\n    tmpBuf[4] = (uint32_T)1;\n#endif\n\n    tmpBuf[5] = (uint32_T)sizeof(uchunk_T);\n    \n    tmpBuf[6] = (uint32_T)modelStatus;\n\n    /* nDataTypes and dataTypeSizes */\n    {        \n        int i;\n        tmpBuf[7] = (uint32_T)nDataTypes;\n        for (i=0; i<nDataTypes; i++) {\n            tmpBuf[8+i] = (uint32_T)dtSizes[i];\n        }\n    }\n    \n    /* Send the packet. */\n    error = ExtSetHostPkt(extUD,tmpBufSize,(char_T *)tmpBuf,&nSet);\n    if (error || (nSet != tmpBufSize)) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\n            \"ExtSetHostPkt() failed.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n\n    commInitialized = true;\n\nEXIT_POINT:\n    free(tmpBuf);\n    return(error);\n} /* end ProcessConnectPkt */\n\n\n/* Function: SendPktHdrToHost ==================================================\n * Abstract:\n *  Send a packet header to the host.\n */\nPRIVATE boolean_T SendPktHdrToHost(\n    const ExtModeAction action,\n    const int           size)  /* # of bytes to follow pkt header */\n{\n    int_T     nSet;\n    PktHeader pktHdr;\n    boolean_T error = EXT_NO_ERROR;\n\n    pktHdr.type = (uint32_T)action;\n    pktHdr.size = size;\n\n    error = ExtSetHostPkt(extUD,sizeof(pktHdr),(char_T *)&pktHdr,&nSet);\n    if (error || (nSet != sizeof(pktHdr))) {\n        error = EXT_ERROR;\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"ExtSetHostPkt() failed.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n\nEXIT_POINT:\n    return(error);\n} /* end SendPktHdrToHost */\n\n\n/* Function: SendPktDataToHost =================================================\n * Abstract:\n *  Send packet data to host. You are responsible for sending a header\n *  prior to sending the header.\n */\nPRIVATE boolean_T SendPktDataToHost(const char *data, const int size)\n{\n    int_T     nSet;\n    boolean_T error = EXT_NO_ERROR;\n\n    error = ExtSetHostPkt(extUD,size,data,&nSet);\n    if (error || (nSet != size)) {\n        error = EXT_ERROR;\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"ExtSetHostPkt() failed.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n\nEXIT_POINT:\n    return(error);\n} /* end SendPktDataToHost */\n\n\n/* Function: SendPktToHost =====================================================\n * Abstract:\n *  Send a packet to the host.  Packets can be of two forms:\n *      o packet header only\n *          the type is used as a flag to notify Simulink of an event\n *          that has taken place on the target (event == action == type)\n *      o pkt header, followed by data\n */\nPUBLIC boolean_T SendPktToHost(\n    const ExtModeAction action,\n    const int           size,  /* # of bytes to follow pkt header */\n    const char          *data)\n{\n    boolean_T error = EXT_NO_ERROR;\n    \n#ifdef VXWORKS\n    semTake(pktSem, WAIT_FOREVER);\n#endif\n\n    error = SendPktHdrToHost(action,size);\n    if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n    if (data != NULL) {\n        error = SendPktDataToHost(data, size);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n    } else {\n        assert(size == 0);\n    }\n\nEXIT_POINT:\n#ifdef VXWORKS\n    semGive(pktSem);\n#endif\n    return(error);\n} /* end SendPktToHost */\n\n\n/* Function:  SendResponseStatus ===============================================\n *  \n */\nPRIVATE boolean_T SendResponseStatus(const ExtModeAction  response,\n                                     const ResponseStatus status,\n                                     int32_T upInfoIdx)\n{\n    int32_T   msg[2];\n    boolean_T error = EXT_NO_ERROR;\n\n    msg[0] = (int32_T)status;\n    msg[1] = upInfoIdx;\n\n    error = SendPktToHost(response,2*sizeof(int32_T),(char_T *)&msg);\n    return(error);\n\n} /* end SendResponseStatus */\n\n\n#ifndef EXTMODE_DISABLEPARAMETERTUNING\n/* Function: ProcessSetParamPkt ================================================\n * Receive and process the EXT_SETPARAM packet.\n */\nPRIVATE boolean_T ProcessSetParamPkt(RTWExtModeInfo *ei,\n                                     const int pktSize)\n{\n    int32_T    msg;\n    const char *pkt;\n    boolean_T  error = EXT_NO_ERROR;\n\n    /*\n     * Receive packet and set parameters.\n     */\n    \n#ifdef DAEMON_MODE\n    pkt = GetPktUsingAck(pktSize);\n#else\n    pkt = GetPkt(pktSize);\n#endif\n\n    if (pkt == NULL) {\n        msg = (int32_T)NOT_ENOUGH_MEMORY;\n        SendPktToHost(EXT_SETPARAM_RESPONSE,sizeof(int32_T),(char_T *)&msg);\n        error = EXT_ERROR; \n        goto EXIT_POINT;\n    }\n    SetParam(ei, pkt);\n\n    msg = (int32_T)STATUS_OK;\n    error = SendPktToHost(EXT_SETPARAM_RESPONSE,sizeof(int32_T),(char_T *)&msg);\n    if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\nEXIT_POINT:\n    return(error);\n} /* end ProcessSetParamPkt */\n#endif /* ifndef EXTMODE_DISABLEPARAMETERTUNING */\n\n#ifndef EXTMODE_DISABLEPARAMETERTUNING \n/* Function: ProcessGetParamsPkt ===============================================\n *  Respond to the hosts request for the parameters by gathering up all the\n *  params and sending them to the host.\n */\nPRIVATE boolean_T ProcessGetParamsPkt(RTWExtModeInfo *ei)\n{\n    int_T                         i;\n    int_T                         nBytesTotal;\n    boolean_T                     error    = EXT_NO_ERROR;\n    const DataTypeTransInfo       *dtInfo  = (const DataTypeTransInfo *) rteiGetModelMappingInfo(ei);\n    const DataTypeTransitionTable *dtTable = dtGetParamDataTypeTrans(dtInfo);\n\n    if (dtTable != NULL) {\n        /*\n         * We've got some params in the model.  Send their values to the\n         * host.\n         */\n        int_T        nTrans   = dtGetNumTransitions(dtTable);\n        const uint_T *dtSizes = dtGetDataTypeSizes(dtInfo);\n\n #ifdef VERBOSE\n    #ifndef EXTMODE_DISABLEPRINTF             \n        printf(\"\\nUploading initial parameters....\\n\");\n #endif\n#endif \n\n        /*\n         * Take pass 1 through the transitions to figure out how many\n         * bytes we're going to send.\n         */\n        nBytesTotal = 0;\n        for (i=0; i<nTrans; i++) {\n            int_T dt     = dtTransGetDataType(dtTable, i);\n            int_T dtSize = dtSizes[dt];\n            int_T nEls   = dtTransNEls(dtTable, i); /* complexity accounted for in trans tbl num of els */\n            int_T nBytes = dtSize * nEls;\n\n            nBytesTotal += nBytes;\n        }\n\n        /*\n         * Send the packet header.\n         */\n        error = SendPktHdrToHost(EXT_GETPARAMS_RESPONSE,nBytesTotal);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n        /*\n         * Take pass 2 through the transitions and send the parameters.\n         */\n        for (i=0; i<nTrans; i++) {\n            char_T *tranAddress  = dtTransGetAddress(dtTable, i);\n            int_T  dt            = dtTransGetDataType(dtTable, i);\n            int_T  dtSize        = dtSizes[dt];\n            int_T  nEls          = dtTransNEls(dtTable, i); /* complexity accounted for in trans tbl num of els */\n            int_T  nBytes        = dtSize * nEls;\n\n            error = SendPktDataToHost(tranAddress, nBytes);\n            if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        }\n    } else {\n        /*\n         * We've got no params in the model.\n         */\n        error = SendPktHdrToHost(EXT_GETPARAMS_RESPONSE,0);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n    }\n\nEXIT_POINT:\n    return(error);\n} /* end ProcessGetParamsPkt */\n#endif /* ifndef EXTMODE_DISABLEPARAMETERTUNING */\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: ProcessSelectTriggerSignalPkt ===========================================\n * Receive and process the EXT_SELECT_TRIGGER or EXT_SELECT_SIGNALS packet.\n */\nPRIVATE boolean_T ProcessSelectTriggerSignalPkt(const ExtModeAction ACTION_ID, \n                                                RTWExtModeInfo *ei,\n                                                const int pktSize,\n                                                int_T numSampTimes,\n                                                char* errMsg)\n{\n    const char *pkt;\n    int32_T    upInfoIdx;\n    boolean_T  error = EXT_NO_ERROR;\n\n#ifdef DAEMON_MODE\n    pkt = GetPktUsingAck(pktSize);\n#else\n    pkt = GetPkt(pktSize);\n#endif\n\n    if (pkt == NULL) {\n        SendResponseStatus(ACTION_ID, NOT_ENOUGH_MEMORY, -1);\n        return(EXT_ERROR);\n    }\n\n    (void)memcpy(&upInfoIdx, pkt, sizeof(int32_T)); /* Extract upInfoIdx */\n    switch(ACTION_ID) {\n    case EXT_SELECT_TRIGGER_RESPONSE:\n#ifndef EXTMODE_DISABLEPRINTF  \n        PRINT_VERBOSE(\n                    (\"got EXT_SELECT_TRIGGER packet for upInfoIdx : %d\\n\", upInfoIdx));\n#endif\n        error = UploadInitTrigger(ei, pkt+sizeof(int32_T), upInfoIdx);\n        break;\n    case EXT_SELECT_SIGNALS_RESPONSE:\n#ifndef EXTMODE_DISABLEPRINTF  \n        PRINT_VERBOSE(\n                    (\"got EXT_SELECT_SIGNALS packet for upInfoIdx : %d\\n\", upInfoIdx));\n#endif\n        error = UploadLogInfoInit(ei, numSampTimes, pkt+sizeof(int32_T), upInfoIdx);\n        break;\n    default:\n        break;\n    }\n\n    if (error != EXT_NO_ERROR) {\n        SendResponseStatus(ACTION_ID, NOT_ENOUGH_MEMORY, upInfoIdx);\n#ifndef EXTMODE_DISABLEPRINTF            \n        printf(\"%s\\n\", errMsg);\n#endif\n        return(error);\n    }\n\n    error = SendResponseStatus(ACTION_ID, STATUS_OK, upInfoIdx);\n    return(error); /* Can be EXT_NO_ERROR */\n} /* end ProcessSelectTriggerSignalPkt */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: ProcessCancelLoggingArmTriggerPkt ===========================================\n * Receive and process the EXT_CANCEL_LOGGING or EXT_ARM_TRIGGER packet.\n */\nPRIVATE boolean_T ProcessCancelLoggingArmTriggerPkt(const ExtModeAction ACTION_ID, \n                        const int pktSize, \n                        int_T numSampTimes)\n{\n    const char *pkt;\n    int32_T    upInfoIdx;\n    boolean_T  error = EXT_NO_ERROR;\n\n#ifdef DAEMON_MODE\n    pkt = GetPktUsingAck(pktSize);\n#else\n    pkt = GetPkt(pktSize);\n#endif\n\n    if (pkt == NULL) {\n        SendResponseStatus(ACTION_ID, NOT_ENOUGH_MEMORY, -1);\n        return(EXT_ERROR);\n    }\n            \n    (void)memcpy(&upInfoIdx, pkt, sizeof(int32_T)); /* Extract upInfoIdx */\n        \n    switch(ACTION_ID) {\n    case EXT_CANCEL_LOGGING_RESPONSE:\n#ifndef EXTMODE_DISABLEPRINTF   \n        PRINT_VERBOSE(\n                (\"got EXT_CANCEL_LOGGING packet for upInfoIdx : %d\\n\", upInfoIdx));\n#endif\n        UploadCancelLogging(upInfoIdx);\n        break;\n    case EXT_ARM_TRIGGER_RESPONSE:\n#ifndef EXTMODE_DISABLEPRINTF\n        PRINT_VERBOSE(\n                (\"got EXT_ARM_TRIGGER packet for upInfoIdx : %d\\n\", upInfoIdx));\n#endif\n        UploadArmTrigger(upInfoIdx, numSampTimes);\n        break;\n    default:\n        break;\n    }\n\n    error = SendResponseStatus(ACTION_ID, STATUS_OK, upInfoIdx);\n    return(error); /* Can be EXT_NO_ERROR */\n} /* end ProcessCancelLoggingArmTriggerPkt */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n#ifdef EXTMODE_DISABLEPARAMETERTUNING\nPRIVATE boolean_T AcknowledgeSetParamPkt(const int pktSize)\n{\n    int32_T    msg;\n    const char *pkt;\n    boolean_T  error = EXT_NO_ERROR;\n\n    pkt = GetPkt(pktSize);\n    msg = (int32_T)STATUS_OK;\n    error = SendPktToHost(EXT_SETPARAM_RESPONSE, sizeof(int32_T), (char_T *)&msg);\n    return(error);\n}\n#endif /* ifdef EXTMODE_DISABLEPARAMETERTUNING */\n\n#ifdef EXTMODE_DISABLESIGNALMONITORING\nPRIVATE boolean_T AcknowledgeSignalActionPkt(const int pktSize, const ExtModeAction ACTION_ID)\n{\n    const char *pkt;\n    int32_T    upInfoIdx;\n    boolean_T  error = EXT_NO_ERROR;\n\n    pkt = GetPkt(pktSize);\n    (void)memcpy(&upInfoIdx, pkt, sizeof(int32_T));\n    error = SendResponseStatus(ACTION_ID, STATUS_OK, upInfoIdx);\n    return(error);\n} \n#endif /* ifdef EXTMODE_DISABLESIGNALMONITORING */\n\n/*********************\n * Visible Functions *\n *********************/\n\n\n/* Function: ExtParseArgsAndInitUD =============================================\n * Abstract:\n *  Pass remaining arguments (main program should have NULL'ed out any args\n *  that it processed) to external mode.\n *  \n *  The actual, transport-specific parsing routine (implemented in\n *  ext_svr_transport.c) MUST NULL out all entries of argv that it processes.\n *  The main program depends on this in order to determine if any unhandled\n *  command line options were specified (i.e., if the main program detects\n *  any non-null fields after the parse, it throws an error).\n *\n *  Returns an error string on failure, NULL on success.\n *\n * NOTES:\n *  The external mode UserData is created here so that the specified command-\n *  line options can be stored.\n */\nPUBLIC const char_T *ExtParseArgsAndInitUD(const int_T  argc,\n                                           const char_T *argv[])\n{\n    const char_T *error = NULL;\n    \n    /*\n     * Create the user data.\n     */\n    extUD = ExtUserDataCreate();\n    if (extUD == NULL) {\n        error = \"Could not create external mode user data.  Out of memory.\\n\";\n        goto EXIT_POINT;\n    }\n\n    /*\n     * Parse the transport-specific args.\n     */\n    error = ExtProcessArgs(extUD,argc,argv);\n    if (error != NULL) goto EXIT_POINT;\n        \nEXIT_POINT:\n    if (error != NULL) {\n        ExtUserDataDestroy(extUD);\n        extUD = NULL;\n    }\n    return(error);\n} /* end ExtParseArgsAndInitUD */\n\n\n/* Function: ExtWaitForStartPkt ================================================\n * Abstract:\n *  Return true if waiting for host to tell us when to start.\n */\nPUBLIC boolean_T ExtWaitForStartPkt(void)\n{\n    return(ExtWaitForStartPktFromHost(extUD));\n} /* end ExtWaitForStartPkt */\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: UploadServerWork =================================================\n * Abstract:\n *  Upload model signals to host for a single upInfo.\n */\nvoid UploadServerWork(int32_T upInfoIdx, int_T numSampTimes)\n{\n    int_T         i;\n    ExtBufMemList upList;\n    boolean_T     error = EXT_NO_ERROR;\n\n#ifdef VXWORKS\n    /*\n     * Don't spin the CPU unless we've got data to upload.\n     * The upload.c/UploadBufAddTimePoint function gives the sem\n     * each time that data is added.\n     */\ntaskUnsafe();\n    semTake(uploadSem, WAIT_FOREVER);\ntaskSafe();\n#endif\n\n    if (!connected) goto EXIT_POINT;\n    \n    UploadBufGetData(&upList, upInfoIdx, numSampTimes);\n    while(upList.nActiveBufs > 0) {\n        for (i=0; i<upList.nActiveBufs; i++) {\n            const BufMem *bufMem = &upList.bufs[i];\n\n            /*\n             * We call SendPktDataToHost() instead of SendPktToHost() because\n             * the packet header is combined with packet payload.  We do this\n             * to avoid the overhead of making two calls for each upload\n             * packet - one for the head and one for the payload.\n             */\n            error = SendPktDataToHost(\n                bufMem->section1,\n                bufMem->nBytes1);\n            if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF                    \n                fprintf(stderr,\"SendPktDataToHost() failed on data upload.\\n\");\n#endif\n                goto EXIT_POINT;\n            }\n            \n            if (bufMem->nBytes2 > 0) {\n\n                error = SendPktDataToHost(\n                    bufMem->section2,\n                    bufMem->nBytes2);\n                if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF                        \n                    fprintf(stderr,\"SendPktDataToHost() failed on data upload.\\n\");\n#endif\n                    goto EXIT_POINT;\n                }\n            }\n            /* confirm that the data was sent */\n            UploadBufDataSent(upList.tids[i], upInfoIdx);\n        }\n        UploadBufGetData(&upList, upInfoIdx, numSampTimes);\n    }\n    \nEXIT_POINT:\n    if (error != EXT_NO_ERROR) {\n        /* An error in this function is caused by a physical failure in the\n         * external mode connection.  We assume this failure caused the host\n         * to disconnect.  The target must be disconnected and returned to a\n         * state where it is running and can be re-connected to by the host.\n         */\n        ForceDisconnectFromHost(numSampTimes);\n    }\n}\n/* end UploadServerWork */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: rt_UploadServerWork ===============================================\n * Abstract:\n *  Wrapper function that calls UploadServerWork once for each upInfo\n */\nPUBLIC void rt_UploadServerWork(int_T numSampTimes)\n{\n    int i;\n    \n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadServerWork(i, numSampTimes);\n    }\n} /* end rt_UploadServerWork */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/* Function: rt_ExtModeInit ====================================================\n * Abstract:\n *  Called once at program startup to do any initialization related to external\n *  mode. \n */\nPUBLIC boolean_T rt_ExtModeInit(void)\n{\n    int i;\n    boolean_T error = EXT_NO_ERROR;\n\n#ifdef TMW_EXTMODE_TESTING_REQ\n#  ifndef TMW_EXTMODE_TESTING\n#ifndef EXTMODE_DISABLEPRINTF \n    fprintf(stderr,\"Error: External mode tests should use the external mode test harness.\\n\");\n#endif\n    error = EXT_ERROR;\n#  endif\n#endif\n    if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n    error = ExtInit(extUD);\n    if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadLogInfoReset(i);\n    }\n\n    rtExtModeTestingInit();\n\nEXIT_POINT:\n    return(error);\n} /* end rt_ExtModeInit */\n\n\n/* Function: rt_ExtModeSleep ===================================================\n * Abstract:\n *  Called by grt_main, ert_main, and grt_malloc_main  to \"pause\".  It attempts\n *  to do this in a way that does not hog the processor.\n */\n#ifndef VXWORKS\nPUBLIC void rt_ExtModeSleep(\n    long sec,  /* number of seconds to wait       */\n    long usec) /* number of micro seconds to wait */\n{\n    ExtModeSleep(extUD,sec,usec);\n} /* end rt_ExtModeSleep */\n#endif\n\n\n/* Function: rt_PktServerWork ==================================================\n * Abstract:\n *  If not connected, establish communication of the packet line and the\n *  data upload line.  If connected, send/receive packets and parameters\n *  on the packet line.\n */\nPUBLIC void rt_PktServerWork(RTWExtModeInfo *ei,\n                             int_T          numSampTimes,\n                             boolean_T      *stopReq)\n{\n    PktHeader  pktHdr;\n    boolean_T  hdrAvail;\n    boolean_T  error             = EXT_NO_ERROR;\n    boolean_T  disconnectOnError = false;\n    \n    /*\n     * If not connected, attempt to make connection to host.\n     */\n    if (!connected) {\n        rtExtModeTestingKillIfOrphaned(false);\n\n        error = ExtOpenConnection(extUD,&connected);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n    }\n\n    /*\n     * If ExtOpenConnection is not blocking and there are no pending\n     * requests to open a connection, we'll still be unconnected.\n     */\n    if (!connected) goto EXIT_POINT; /* nothing to do */\n    \n    /*\n     * Process packets.\n     */\n\n    /* Wait for a packet. */\n    error = GetPktHdr(&pktHdr, &hdrAvail);\n    if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr, \"\\nError occurred getting packet header.\\n\");\n#endif\n        disconnectOnError = true;\n        goto EXIT_POINT;\n    }\n    rtExtModeTestingKillIfOrphaned(hdrAvail);\n    \n    if (!hdrAvail) goto EXIT_POINT; /* nothing to do */\n\n    /*\n     * This is the first packet.  Should contain the string:\n     * 'ext-mode'.  Its contents are not important to us.\n     * It is used as a flag to start the handshaking process.\n     */\n    if (!commInitialized) {\n        pktHdr.type = EXT_CONNECT;\n    }\n\n    /* \n     * At this point we know that we have a packet: process it.\n     */\n#ifdef VXWORKS\n    taskSafe();\n#endif\n    switch(pktHdr.type) {\n\n    case EXT_GET_TIME:\n    {\n        /* Skip verbosity print out - we get too many of these */\n        /*PRINT_VERBOSE((\"got EXT_GET_TIME packet.\\n\"));*/\n        time_T t = rteiGetT(ei);\n        \n        error = SendPktToHost(\n            EXT_GET_TIME_RESPONSE,sizeof(time_T),\n            (char_T *)&t);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n    }\n\n    case EXT_ARM_TRIGGER:\n    {\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        error = ProcessCancelLoggingArmTriggerPkt(EXT_ARM_TRIGGER_RESPONSE, pktHdr.size, numSampTimes);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#else\n        error = AcknowledgeSignalActionPkt(pktHdr.size, EXT_ARM_TRIGGER_RESPONSE);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_SELECT_SIGNALS:\n    {\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        error = ProcessSelectTriggerSignalPkt(EXT_SELECT_SIGNALS_RESPONSE, ei, pktHdr.size, numSampTimes, ERRMSG_PROCESSSELECTSIGNAL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#else\n        error = AcknowledgeSignalActionPkt(pktHdr.size, EXT_SELECT_SIGNALS_RESPONSE);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_SELECT_TRIGGER: \n    {\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        error = ProcessSelectTriggerSignalPkt(EXT_SELECT_TRIGGER_RESPONSE, ei, pktHdr.size, -1, ERRMSG_PROCESSSELECTTRIGGER);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#else\n        error = AcknowledgeSignalActionPkt(pktHdr.size, EXT_SELECT_TRIGGER_RESPONSE);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_CONNECT:\n    {\n        PRINT_VERBOSE((\"got EXT_CONNECT packet.\\n\"));\n        error = ProcessConnectPkt(ei);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n    }\n\n    case EXT_SETPARAM:\n    {\n#ifndef EXTMODE_DISABLEPARAMETERTUNING\n        PRINT_VERBOSE((\"got EXT_SETPARAM packet.\\n\"));\n        if (pktHdr.size == 0) {\n            gblSetParamPktReceived = true;\n        } else {\n            error = ProcessSetParamPkt(ei, pktHdr.size);\n            if (error != EXT_NO_ERROR) {\n                goto EXIT_POINT;\n            }\n            else {\n                gblSetParamPktReceived = true;\n            }\n        }\n#else\n        PRINT_VERBOSE((\"discard EXT_SETPARAM packet.\\n\"));\n        error = AcknowledgeSetParamPkt(pktHdr.size);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_GETPARAMS:\n    {\n#ifndef EXTMODE_DISABLEPARAMETERTUNING\n        PRINT_VERBOSE((\"got EXT_GETPARAMS packet.\\n\"));\n        error = ProcessGetParamsPkt(ei);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_DISCONNECT_REQUEST:\n    {\n        PRINT_VERBOSE((\"got EXT_DISCONNECT_REQUEST packet.\\n\"));\n        \n        /*\n         * Note that from the target's point of view this is\n         * more a \"notify\" than a \"request\".  The host needs to\n         * have this acknowledged before it can begin closing\n         * the connection.\n         */\n        error = SendPktToHost(EXT_DISCONNECT_REQUEST_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n        DisconnectFromHost(numSampTimes);\n\n        break;\n    }\n\n    case EXT_DISCONNECT_REQUEST_NO_FINAL_UPLOAD:\n    {\n        PRINT_VERBOSE((\"got EXT_DISCONNECT_REQUEST_NO_FINAL_UPLOAD packet.\\n\"));\n        \n        /*\n         * The target receives this packet when the host is\n         * immediately terminating the extmode communication due\n         * to some error.  The target should not send back a\n         * response or a final upload of data because the host is\n         * expecting neither.  The target must be disconnected and\n         * returned to a state where it is running and can be\n         * re-connected to by the host.\n         */\n        ForceDisconnectFromHost(numSampTimes);\n\n        break;\n    }\n\n    case EXT_MODEL_START:\n        PRINT_VERBOSE((\"got EXT_MODEL_START packet.\\n\"));\n#ifdef VXWORKS\n        {\n            extern SEM_ID startStopSem;\n            semGive(startStopSem);\n        }\n#endif\n        startModel = true;\n        error = SendPktToHost(EXT_MODEL_START_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n\n    case EXT_MODEL_STOP:\n        PRINT_VERBOSE((\"got EXT_MODEL_STOP packet.\\n\"));\n        *stopReq = true;\n        break;\n#ifndef EXTMODE_DISABLETESTING\n    case EXT_MODEL_PAUSE:\n        PRINT_VERBOSE((\"got EXT_MODEL_PAUSE packet.\\n\"));\n        modelStatus = TARGET_STATUS_PAUSED;\n        startModel  = false;\n\n        error = SendPktToHost(EXT_MODEL_PAUSE_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n    case EXT_MODEL_STEP:\n        PRINT_VERBOSE((\"got EXT_MODEL_STEP packet.\\n\"));\n        if ((modelStatus == TARGET_STATUS_PAUSED) && !startModel) {\n            startModel = true;\n        }\n        \n        error = SendPktToHost(EXT_MODEL_STEP_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n    case EXT_MODEL_CONTINUE:\n        PRINT_VERBOSE((\"got EXT_MODEL_CONTINUE packet.\\n\"));\n        if (modelStatus == TARGET_STATUS_PAUSED) {\n            modelStatus = TARGET_STATUS_RUNNING;\n            startModel  = false;\n        }\n        \n        error = SendPktToHost(EXT_MODEL_CONTINUE_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n\n    case EXT_CANCEL_LOGGING:\n    {\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        error = ProcessCancelLoggingArmTriggerPkt(EXT_CANCEL_LOGGING_RESPONSE, pktHdr.size, numSampTimes);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#else\n        error = AcknowledgeSignalActionPkt(pktHdr.size, EXT_CANCEL_LOGGING_RESPONSE);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    default:\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"received invalid packet.\\n\");\n#endif\n        break;\n    } /* end switch */\n\nEXIT_POINT:\n    if (error != EXT_NO_ERROR) {\n        if (disconnectOnError) {\n#ifndef EXTMODE_DISABLEPRINTF                \n            fprintf(stderr,\n                \"Error occurred in rt_PktServerWork.\\n\"\n                \"Disconnecting from host!\\n\");\n#endif\n            /* An error in this function which causes disconnectOnError to be\n             * set to true is caused by a physical failure in the external mode\n             * connection.  We assume this failure caused the host to disconnect.\n             * The target must be disconnected and returned to a state\n             * where it is running and can be re-connected to by the host.\n             */\n            ForceDisconnectFromHost(numSampTimes);\n        }\n    }\n#ifdef VXWORKS\n    taskUnsafe();\n#endif\n} /* end rt_PktServerWork */\n\n\n/* Function: rt_PktServer ======================================================\n * Abstract:\n *  Call rt_PktServerWork forever.   Used only for RTOS (e.g., Tornado/VxWorks\n *  when running as a low priority task.\n */\n#ifdef VXWORKS\nPUBLIC void rt_PktServer(RTWExtModeInfo *ei,\n                         int_T          numSampTimes,\n                         boolean_T      *stopReq)\n{\n    for(;;) {\n        rt_PktServerWork(ei,numSampTimes,stopReq); \n    }\n}\n#endif\n\n\n/* Function: rt_UploadServer ===================================================\n * Abstract:\n *  Call rt_UploadServerWork forever.   Used only for RTOS (e.g.,\n *  Tornado/VxWorks when running as a low priority task.\n */\n#ifdef VXWORKS\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPUBLIC void rt_UploadServer(int_T numSampTimes)\n{\n    for(;;) {\n        rt_UploadServerWork(numSampTimes);\n    }\n} /* end rt_UploadServer */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n#endif\n\n\n/* Function: rt_SetPortInExtUD =================================================\n * Abstract:\n *  Set the port in the external mode user data structure.\n */\n#ifdef VXWORKS\nPUBLIC void rt_SetPortInExtUD(const int_T port)\n{\n    ExtUserDataSetPort(extUD, port);\n} /* end rt_SetPortInExtUD */\n#endif\n\n/* Function: ExtModeShutdown ==================================================\n * Abstract:\n *  Called when target program terminates to enable cleanup of external \n *  mode for a given upInfo.\n */\nPRIVATE void ExtModeShutdown(int32_T upInfoIdx, int_T numSampTimes)\n{\n    /*\n     * Make sure buffers are flushed so that the final points get to\n     * host (this is important for the case of the target reaching tfinal\n     * while data uploading is in progress).\n     */\n    UploadPrepareForFinalFlush(upInfoIdx);\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n    UploadServerWork(upInfoIdx, numSampTimes);\n#endif\n\n    UploadLogInfoTerm(upInfoIdx, numSampTimes);\n\n    if (pktBuf != NULL) {\n        free(pktBuf);\n        pktBuf = NULL;\n    }\n\n} /* end ExtModeShutdown */\n\n/* Function: rt_ExtModeShutdown ================================================\n * Abstract:\n *  Called when target program terminates to enable cleanup of external \n *  mode.\n */\nPUBLIC boolean_T rt_ExtModeShutdown(int_T numSampTimes)\n{\n    int i;\n    boolean_T error = EXT_NO_ERROR;\n\n    for (i=0; i<NUM_UPINFOS; i++) {\n        ExtModeShutdown(i, numSampTimes);\n    }\n\n    if (commInitialized) {\n        error = SendPktToHost(EXT_MODEL_SHUTDOWN, 0, NULL);\n        if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF                \n            fprintf(stderr,\n                \"\\nError sending EXT_MODEL_SHUTDOWN packet to host.\\n\");\n#endif\n        }\n        commInitialized = false;\n    }\n    if (connected) {\n        connected = false;\n        modelStatus = TARGET_STATUS_WAITING_TO_START;        \n    }\n\n    ExtShutDown(extUD);\n    ExtUserDataDestroy(extUD);\n    \n    rtExtModeTestingRemoveBatMarker();\n    \n    return(error);\n} /* end rt_ExtModeShutdown */\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: rt_UploadCheckTrigger =============================================\n * Abstract:\n *  Wrapper function that calls UploadCheckTrigger once for each upInfo\n */\nPUBLIC void rt_UploadCheckTrigger(int_T numSampTimes)\n{\n    int i;\n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadCheckTrigger(i, numSampTimes);\n    }\n} /* end rt_UploadCheckTrigger */\n\n/* Function: rt_UploadCheckEndTrigger ==========================================\n * Abstract:\n *  Wrapper function that calls UploadCheckTrigger once for each upInfo\n */\nPUBLIC void rt_UploadCheckEndTrigger(void)\n{\n    int i;\n    \n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadCheckEndTrigger(i);\n    }\n} /* end rt_UploadCheckEndTrigger */\n\n/* Function: rt_UploadBufAddTimePoint ==========================================\n * Abstract:\n *  Wrapper function that calls UploadBufAddTimePoint once for each upInfo\n */\nPUBLIC void rt_UploadBufAddTimePoint(int_T tid, real_T taskTime)\n{\n    int i;\n    \n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadBufAddTimePoint(tid, taskTime, i);\n    }\n} /* end rt_UploadBufAddTimePoint */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/* [EOF] ext_svr.c */\n"},{"name":"ext_work.c","type":"source","group":"legacy","path":"/Applications/MATLAB_R2024a.app/rtw/c/src/ext_mode/common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2021 The MathWorks, Inc.\n *\n * File: ext_work.c     \n *\n * Abstract:\n *   \n */\n\n#if !defined(EXTMODE_DISABLEPRINTF) || !defined(EXTMODE_DISABLE_ARGS_PROCESSING)\n#include <stdio.h>\n#endif\n\n#include <stdlib.h>        /* for exit() */\n#include <string.h>        /* optional for strcmp */\n\n#include \"rtwtypes.h\"\n#include \"rtw_extmode.h\"\n\n#include \"ext_types.h\"\n#include \"ext_share.h\"\n#include \"updown.h\"\n#include \"ext_svr.h\"\n#include \"ext_svr_transport.h\"\n#include \"ext_work.h\" /* includes all VxWorks headers */\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\nint_T           volatile startModel  = false;\nTargetSimStatus volatile modelStatus = TARGET_STATUS_WAITING_TO_START;\n\n#ifdef VXWORKS\nSEM_ID volatile uploadSem = NULL;\nSEM_ID volatile commSem   = NULL;\nSEM_ID volatile pktSem    = NULL;\nint_T           extern_pkt_tid;\nint_T           extern_upload_tid;\n\nvoid rtExtModeTornadoStartup(RTWExtModeInfo *ei,\n                             int_T          numSampTimes,\n                             boolean_T      *stopReqPtr,\n                             int_T          priority,\n                             int32_T        stack_size,\n                             SEM_ID         startStopSem)\n{\n    uploadSem = semBCreate(SEM_Q_PRIORITY, SEM_EMPTY);\n    commSem   = semBCreate(SEM_Q_PRIORITY, SEM_FULL);\n    pktSem    = semBCreate(SEM_Q_PRIORITY, SEM_FULL);\n\n    rt_ExtModeInit();\n\n    extern_pkt_tid = taskSpawn(\"tExternPkt\",\n        priority+(numSampTimes), VX_FP_TASK, stack_size, (FUNCPTR)rt_PktServer, \n        (int_T) ei, (int_T) numSampTimes, (int_T) stopReqPtr, 0, 0, 0, 0, 0, 0, 0);\n    if (extern_pkt_tid == ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF\n        printf(\"handle taskpawn error\");\n#endif\n    }\n\n    extern_upload_tid = taskSpawn(\"tExternUpload\",\n        priority+(numSampTimes)+1,VX_FP_TASK, stack_size,(FUNCPTR)rt_UploadServer,\n        (int_T) numSampTimes, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    if (extern_upload_tid == ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF\n        printf(\"handle taskpawn error\");\n#endif\n    }\n\n    /*\n     * Pause until receive model start packet - if external mode.\n     * Make sure the external mode tasks are running so that \n     * we are listening for commands from the host.\n     */\n    if (ExtWaitForStartPkt()) {\n#ifndef EXTMODE_DISABLEPRINTF\n        printf(\"\\nWaiting for start packet from host.\\n\");\n#endif\n        semTake(startStopSem, WAIT_FOREVER);\n    }\n    modelStatus = TARGET_STATUS_RUNNING;\n}\n\nvoid rtExtModeTornadoCleanup(int_T numSampTimes)\n{\n    taskDelete(extern_upload_tid);\n    taskDelete(extern_pkt_tid);\n    rt_ExtModeShutdown(numSampTimes);\n    semDelete(uploadSem);\n    semDelete(commSem);\n    semDelete(pktSem);\n}\n\n/* Function ====================================================================\n *  Used by Tornado/VxWorks to set the port number used by external mode.\n *  Tornado does not parse the port number the same way as the other code\n *  formats.  Instead, the port number is specified as an argument to the\n *  spawn command which passes it into rt_main().  This function is called\n *  by rt_main() to set the port number in the external mode user data\n *  structure.\n */\nvoid rtExtModeTornadoSetPortInExtUD(const int_T port)\n{\n    rt_SetPortInExtUD(port);\n}\n\n#else /* VXWORKS == 0 */\n\n/* Function ====================================================================\n * Pause the process (w/o hogging the cpu) until receive step packet (which\n * means the startModel flag moves to true) or until we are no longer\n * in the paused state.  The packet/upload server must continue to process\n * events (otherwise the host would not be able to communicate with the target).\n */\nvoid rtExtModePauseIfNeeded(RTWExtModeInfo *ei,\n                            int_T          numSampTimes,\n                            boolean_T      *stopReqPtr)\n{\n    while((modelStatus == TARGET_STATUS_PAUSED) && \n          !startModel && !(*stopReqPtr)) {\n        rt_ExtModeSleep(0L, 375000L);\n        rt_PktServerWork(ei,numSampTimes,stopReqPtr);\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        rt_UploadServerWork(numSampTimes);\n#endif\n    }\n    startModel = false; /* reset to false - if we were stepped we want to\n                         *                  stop again next time we get\n                         *                  back here.\n                         */\n} /* end rtExtModePauseIfNeeded */\n\n/* Function ====================================================================\n * Pause the process (w/o hogging the cpu) until receive start packet\n * from the host.  The packet/upload server must continue to process\n * events (otherwise the host would not be able to communicate with the target).\n */\nvoid rtExtModeWaitForStartPkt(RTWExtModeInfo *ei,\n                              int_T          numSampTimes,\n                              boolean_T      *stopReqPtr)\n{\n    /*\n     * Pause until receive model start packet.\n     */\n    if (ExtWaitForStartPkt()) {\n        while(!startModel && !(*stopReqPtr)) {\n            rt_ExtModeSleep(0L, 375000L);\n            rt_PktServerWork(ei,numSampTimes,stopReqPtr);\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n            rt_UploadServerWork(numSampTimes);\n#endif\n        }\n    }\n    if (modelStatus != TARGET_STATUS_PAUSED) {\n        modelStatus = TARGET_STATUS_RUNNING;\n    } else {\n        /* leave in pause mode */\n    }\n}\n#endif\n\nvoid rtExtModeOneStep(RTWExtModeInfo *ei,\n                      int_T          numSampTimes,\n                      boolean_T      *stopReqPtr)\n{\n    /*\n     * In a multi-tasking environment, this would be removed from the base rate\n     * and called as a \"background\" task.\n     */\n    if (modelStatus != TARGET_STATUS_PAUSED) {\n        rt_PktServerWork(ei,numSampTimes,stopReqPtr);\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        rt_UploadServerWork(numSampTimes);\n#endif\n    }\n}\n\nvoid rtExtModeUpload(int_T tid, real_T taskTime)\n{\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n    rt_UploadBufAddTimePoint(tid, taskTime);\n#endif\n}\n\nvoid rtExtModeCheckEndTrigger(void)\n{\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n    rt_UploadCheckEndTrigger();\n#endif\n}\n\nvoid rtExtModeUploadCheckTrigger(int_T numSampTimes)\n{\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n    rt_UploadCheckTrigger(numSampTimes);\n#endif\n}\n\nvoid rtExtModeCheckInit(int_T numSampTimes)\n{\n    UNUSED_PARAMETER(numSampTimes);\n    if (rt_ExtModeInit() != EXT_NO_ERROR){\n#ifndef EXTMODE_DISABLEPRINTF            \n            printf(\"Error calling rt_ExtModeInit!\\n\");\n            exit(EXIT_FAILURE);         /*Error out if rt_ExtModeInit() returns EXT_ERROR. */\n#endif\n    }\n}\n\nvoid rtExtModeShutdown(int_T numSampTimes)\n{\n    rt_ExtModeShutdown(numSampTimes);\n}\n\nvoid rtExtModeParseArgs(int_T        argc, \n                        const char_T *argv[],\n                        real_T       *unused)\n{\n    UNUSED_PARAMETER(unused);\n\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    /* Some targets do not support command line args, so bypass the args \n     * processing and directly call into ExtParseArgsAndInitUD.\n     */\n\n    /* initialize external mode */\n    ExtParseArgsAndInitUD(0, NULL);\n\n#else   \n\n    /*\n     * Parse the external mode arguments.\n     */\n    {\n        const char_T *extParseErrorPkt = ExtParseArgsAndInitUD(argc, argv);\n        if (extParseErrorPkt != NULL) {\n#ifndef EXTMODE_DISABLEPRINTF            \n            printf(\n                \"\\nError processing External Mode command line arguments:\\n\");\n            printf(\"\\t%s\",extParseErrorPkt);\n#endif\n            exit(EXIT_FAILURE);\n        }\n    }\n#endif  /* EXTMODE_DISABLE_ARGS_PROCESSING */\n}\n\n/* Start of ERT specific functions and data */\n\n#ifndef EXTMODE_DISABLE_ARGS_PROCESSING\nstatic void displayUsage(void)\n{\n#ifndef EXTMODE_DISABLEPRINTF    \n    (void) printf(\"usage: model_name -tf <finaltime> -w -port <TCPport>\\n\");\n    (void) printf(\"arguments:\\n\");\n    (void) printf(\"  -tf <finaltime> - overrides final time specified in \"\n                  \"Simulink (inf for no limit).\\n\");\n    (void) printf(\"  -w              - waits for Simulink to start model \"\n                  \"in External Mode.\\n\");\n    (void) printf(\"  -port <TCPport> - overrides 17725 default port in \"\n                  \"External Mode, valid range 256 to 65535.\\n\");\n#endif    \n}\n#endif\n\nstatic const real_T RUN_FOREVER = (real_T)-1;\n#if INTEGER_CODE == 0\nstatic real_T finaltime = (real_T)-2; /* default to stop time in Sim Params. */\n#else\nstatic real_T finaltime = (real_T)-1; /* default to stop time inf */\n#endif\n\nvoid rtERTExtModeSetTFinal(real_T *rtmTFinal)\n{\n    if (finaltime >= (real_T)0 || finaltime == RUN_FOREVER) {\n        *rtmTFinal = finaltime;\n    }\n}\n\nvoid rtSetTFinalForExtMode(real_T *rtmTFinal)\n{\n    rtERTExtModeSetTFinal(rtmTFinal);\n}\n\nvoid rtParseArgsForExtMode(int_T        argc, \n                           const char_T *argv[])\n{\n\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    /* Some targets do not support command line args, so bypass the args \n     * processing and directly call into ExtParseArgsAndInitUD.\n     */\n\n    /* initialize external mode */\n    ExtParseArgsAndInitUD(0, NULL);\n\n#else    \n    /* parse command line args */\n\n    int_T  oldStyle_argc;\n    const char_T *oldStyle_argv[5];\n\n    if ((argc > 1) && (argv[1][0] != '-')) {\n        /* at least one command line argument has been provided without\n           specifying an option with '-', using the old style */\n        if ( argc > 3 ) {\n            displayUsage();\n            exit(EXIT_FAILURE);\n        }\n\n        /* using the old style the first argument is always the final time */\n        oldStyle_argc = 3;\n        oldStyle_argv[0] = argv[0];\n        oldStyle_argv[1] = \"-tf\";\n        oldStyle_argv[2] = argv[1];\n\n        if (argc == 3) {\n            oldStyle_argc = 5;\n\n            oldStyle_argv[3] = \"-port\";\n            oldStyle_argv[4] = argv[2];\n\n        }\n\n        argc = oldStyle_argc;\n        argv = oldStyle_argv;\n\n    }\n\n    {\n        /* new style: */\n        double    tmpDouble;\n        char_T tmpStr2[201];\n        int_T  count      = 1;\n        int_T  parseError = false;\n\n        /*\n         * Parse the standard RTW parameters.  Let all unrecognized parameters\n         * pass through to external mode for parsing.  NULL out all args handled\n         * so that the external mode parsing can ignore them.\n         */\n        while(count < argc) {\n            const char_T *option = argv[count++];\n            \n            /* final time */\n            if ((strcmp(option, \"-tf\") == 0) && (count != argc)) {\n                const char_T *tfStr = argv[count++];\n                \n                sscanf(tfStr, \"%200s\", tmpStr2);\n                if (strcmp(tmpStr2, \"inf\") == 0) {\n                    tmpDouble = RUN_FOREVER;\n                } else {\n                    char_T tmpstr[2];\n\n#if INTEGER_CODE == 0\n                    if ( (sscanf(tmpStr2,\"%lf%1s\", &tmpDouble, tmpstr) != 1) ||\n                         (tmpDouble < (real_T)0) ) {\n    #ifndef EXTMODE_DISABLEPRINTF\n                        (void)printf(\"finaltime must be a positive, real value or inf\\n\");\n    #endif\n                        parseError = true;\n                        break;\n                    }\n#else\n                    if ( (sscanf(tmpStr2,\"%d%1s\", &tmpDouble, tmpstr) != 1) ||\n                         (tmpDouble < (real_T)0) ) {\n    #ifndef EXTMODE_DISABLEPRINTF\n                        (void)printf(\"tmpDouble = %d\\n\", tmpDouble);\n                        (void)printf(\"finaltime must be a positive, integer value or inf\\n\");\n    #endif\n                        parseError = true;\n                        break;\n                    }\n#endif\n                }\n                finaltime = (real_T) tmpDouble;\n\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n            }\n        }\n\n        if (parseError) {\n    #ifndef EXTMODE_DISABLEPRINTF        \n            (void)printf(\"\\nUsage: model_name -option1 val1 -option2 val2 -option3 \"\n                         \"...\\n\\n\");\n            (void)printf(\"\\t-tf 20 - sets final time to 20 seconds\\n\");\n    #endif        \n\n            exit(EXIT_FAILURE);\n        }\n\n        /*\n         * Parse the external mode arguments.\n         */\n        {\n            const char_T *extParseErrorPkt = ExtParseArgsAndInitUD(argc, argv);\n            if (extParseErrorPkt != NULL) {\n    #ifndef EXTMODE_DISABLEPRINTF           \n                printf(\n                    \"\\nError processing External Mode command line arguments:\\n\");\n                printf(\"\\t%s\",extParseErrorPkt);\n    #endif\n                exit(EXIT_FAILURE);\n            }\n        }\n\n        /*\n         * Check for unprocessed (\"unhandled\") args.\n         */\n        {\n            int i;\n            for (i=1; i<argc; i++) {\n                if (argv[i] != NULL) {\n    #ifndef EXTMODE_DISABLEPRINTF                \n                    printf(\"Unexpected command line argument: %s\\n\",argv[i]);\n    #endif\n                    exit(EXIT_FAILURE);\n                }\n            }\n        }\n    }\n\n    if (finaltime == RUN_FOREVER) {\n        #ifndef EXTMODE_DISABLEPRINTF\n                printf (\"\\n**warning: the simulation will run with no stop time due \"\n                \"to external mode with '-tf inf' argument.\\n\");\n        #endif\n    }\n\n#endif /* EXTMODE_DISABLE_ARGS_PROCESSING */\n}\n\nvoid rtERTExtModeStartMsg(void)\n{\n#ifndef EXTMODE_DISABLEPRINTF    \n    (void)printf(\"\\n** starting the model **\\n\");\n#endif\n}\n\n/* End of ERT specific functions and data */\n\n/* [EOF] ext_work.c */\n"},{"name":"mem_mgr.c","type":"source","group":"legacy","path":"/Applications/MATLAB_R2024a.app/rtw/c/src/ext_mode/common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2019 The MathWorks, Inc.\n *\n * File: mem_mgr.c     $Revision.2 $\n *\n * Abstract:\n */\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef VERBOSE\n#include <stdio.h>\n#endif\n\n#include \"rtwtypes.h\"\n\n#include \"updown_util.h\"\n#include \"ext_types.h\"\n#include \"ext_share.h\"\n\n#include \"mem_mgr.h\"\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\nPRIVATE char MemoryBuffer[EXTMODE_STATIC_SIZE];\n\nPRIVATE MemBufHdr *FreeQueue = NULL;\nPRIVATE MemBufHdr InUseQueue = {NULL, NULL, NULL, 0};\n\n#ifdef VERBOSE\nuint32_T numBytesAllocated = 0;\n#endif\n\nPRIVATE void insertMemBufRight(MemBufHdr *buf, MemBufHdr *queue)\n{\n    assert(queue != NULL);\n    assert(buf != NULL);\n\n    buf->memBufPrev = queue;\n    buf->memBufNext = queue->memBufNext;\n\n    if (buf->memBufNext != NULL) {\n\tbuf->memBufNext->memBufPrev = buf;\n    }\n\n    queue->memBufNext = buf;\n}\n\nPRIVATE void removeMemBuf(MemBufHdr *buf)\n{\n    MemBufHdr *rightMemBuf;\n    MemBufHdr *leftMemBuf;\n\n    assert(buf != NULL);\n\n    rightMemBuf = buf->memBufNext;\n    leftMemBuf  = buf->memBufPrev;\n\n    if (rightMemBuf != NULL) {\n\trightMemBuf->memBufPrev = leftMemBuf;\n    }\n    if (leftMemBuf != NULL) {\n\tleftMemBuf->memBufNext = rightMemBuf;\n    }\n\n    buf->memBufNext = NULL;\n    buf->memBufPrev = NULL;\n}\n\nPRIVATE boolean_T moveRight(MemBufHdr *buf)\n{\n    MemBufHdr *buf2;\n\n    assert(buf != NULL);\n\n    if (buf->memBufNext == NULL) {\n\treturn false;\n    } else {\n\tbuf2 = buf->memBufNext;\n\tremoveMemBuf(buf);\n\tinsertMemBufRight(buf,buf2);\n    }\n    return true;    \n}\n\nPRIVATE boolean_T sortRight(MemBufHdr *buf)\n{\n    assert(buf != NULL);\n\n    if ((buf->memBufNext != NULL) && (buf > buf->memBufNext)) {\n\treturn moveRight(buf);\n    }\n    return false;\n}\n\nPRIVATE boolean_T sortLeft(MemBufHdr *buf)\n{\n    assert(buf != NULL);\n\n    if ((buf->memBufPrev != NULL) && (buf < buf->memBufPrev)) {\n\treturn moveRight(buf->memBufPrev);\n    }\n    return false;\n}\n\nPRIVATE boolean_T mergeWithMemBufOnRight(MemBufHdr *buf)\n{\n    assert(buf != NULL);\n\n    /*\n     * If this memory buffer is adjacent to a free memory buffer to its right,\n     * merge the two memory buffers into one contiguous free memory buffer.\n     */\n    if (buf->memBufNext != NULL) {\n\tMemBufHdr *leftMemBuf   = buf;\n\tMemBufHdr *rightMemBuf  = buf->memBufNext;\n\t\n\t/* Assumes data portion of mem buf is contiguous with mem buf header. */\n\tchar *pointer1 = ((char *)leftMemBuf + sizeof(MemBufHdr) + leftMemBuf->size);\n\tchar *pointer2 = (char *)leftMemBuf->memBufNext;\n\n\tif (pointer1 == pointer2)\n        {\n            removeMemBuf(rightMemBuf);\n            leftMemBuf->size += rightMemBuf->size + sizeof(MemBufHdr);\n            return true;\n        }\n    }\n    return false;\n}\n\nPRIVATE boolean_T mergeMemBuf(MemBufHdr *buf)\n{\n    boolean_T statusRight = false;\n    boolean_T statusLeft  = false;\n\n    assert(buf != NULL);\n\n    statusRight = mergeWithMemBufOnRight(buf);\n\n    if (buf->memBufPrev != NULL) {\n        statusLeft = mergeWithMemBufOnRight(buf->memBufPrev);\n    }\n\n    return (statusRight | statusLeft);\n}\n\nPRIVATE MemBufHdr *inUseQueueFindMemBufHdr(void *mem)\n{\n    MemBufHdr *LocalBuf;\n\n    assert(mem != NULL);\n\n    LocalBuf = &InUseQueue;\n\n    if (LocalBuf->MemBuf == mem) return LocalBuf;\n\n    while (LocalBuf->memBufNext != NULL) {\n\tLocalBuf = LocalBuf->memBufNext;\n        if (LocalBuf->MemBuf == mem) return LocalBuf;\n    }\n\n    return NULL;\n}\n\nPRIVATE void inUseQueueInsert(MemBufHdr *buf)\n{\n    MemBufHdr *LocalBuf;\n\n    assert(buf != NULL);\n\n    LocalBuf = &InUseQueue;\n    while (LocalBuf->memBufNext != NULL) {\n\tLocalBuf = LocalBuf->memBufNext;\n\tcontinue;\n    }\n    insertMemBufRight(buf, LocalBuf);\n}\n\nPRIVATE void sortQueue(MemBufHdr *buf)\n{\n    int count = 1;\n\n    assert(buf != NULL);\n\n    /* Bi-directional bubble sort...\n     *\n     * Whatever packet given, move it left until the packet to the\n     * left belongs there, or there is no packet to the left.\n     *\n     * If there is a packet to the left, move it to the left as\n     * above. \n     *\n     * If there is no packet to the left, reverse direction moving\n     * packets to the right.\n     *\n     * Repeat this until no packets are moved.\n     */\n\n    /* While something moves... */\n    while (count > 0) {\n\tcount = 0;\n\n\t/* Bubble left. */\n\twhile (1) {\n\t    /* Move the current packet as far left as it will go. */\n\t    if (sortLeft(buf)) {\n\t\tcount++;\n\t\tcontinue;\n\t    } else {\n\t\t/* Try to merge the packet with its neighbor to the right. */\n\t\tmergeMemBuf(buf);\n\n\t\t/* Move the MemBufHdr to the left, if possible, and\n\t\t * continue bubbling left.\n\t\t */ \n\t\tif (buf->memBufPrev != NULL) {\n\t\t    buf = buf->memBufPrev;\n\t\t    continue;\n\t\t} else {\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\n\t/* All done bubbling to the left. Now bubble to the right. */\n\n\t/* Bubble right. */\n\twhile (1) {\n\t    /* Move the current packet as far right as it will go. */\n\t    if (sortRight(buf)) {\n\t\tcount++;\n\t\tcontinue;\n\t    } else {\n\t\t/* Try to merge the packet with its neighbor to the right. */\n\t\tmergeMemBuf(buf);\n\n\t\t/* Move the MemBufHdr to the right, if possible, and\n\t\t * continue bubbling right.\n\t\t */ \n\t\tif (buf->memBufNext != NULL) {\n\t\t    buf = buf->memBufNext;\n\t\t    continue;\n\t\t} else {\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n}\n\nPRIVATE void initFreeQueue(void)\n{\n    MemBufHdr *initialFreeMemBuf = NULL;\n\n#ifdef VERBOSE\n    /* There is always at least one header allocated from the buffer. */\n    numBytesAllocated = sizeof(MemBufHdr);\n#endif\n\n    /* The FreeQueue is a pointer to a \"free\" buffer. */\n    FreeQueue = (MemBufHdr *)MemoryBuffer;\n\n    /*\n     * The first free packet describes blocks of free space in the free queue\n     * buffer (initially the whole buffer) and, as space becomes fragmented, is\n     * linked to other \"free\" buffers.\n     */\n    initialFreeMemBuf = FreeQueue;\n\n    /*\n     * The location and size of the initial free buffer describes the whole\n     * memory buffer.\n     */\n    initialFreeMemBuf->MemBuf = (char *)initialFreeMemBuf + sizeof(MemBufHdr);\n    initialFreeMemBuf->size   = sizeof(MemoryBuffer) - sizeof(MemBufHdr);\n\n    /*\n     * When there is only one, contiguous memory buffer, the initial free\n     * buffer is linked to no other free buffers. When there are more than\n     * one, or discontiguous free buffers, these links tie together all free\n     * buffers.\n     */\n    initialFreeMemBuf->memBufPrev = NULL;\n    initialFreeMemBuf->memBufNext = NULL;\n}\n\nPRIVATE MemBufHdr *findFirstFreeMemBuf(const int bufSize)\n{\n    /* Get the first free packet. */\n    MemBufHdr *buf = FreeQueue;\n\n    /*\n     * Loop until we find a free packet big enough for our request or we\n     * run out of free packets.\n     */\n    while (buf != NULL) {\n        /* Take the first free packet that fits. */\n        if (buf->size >= bufSize) {\n            /* Got it. Break out to continue. */\n            break;\n        }\n        /* Get the next free packet. */\n        buf = buf->memBufNext;\n    }\n\n    return buf;\n}\n\nPUBLIC void ExtModeFree(void *mem)\n{\n    MemBufHdr *buf = NULL;\n\n    if (mem == NULL) return;\n\n    /* Find the header associated with the memory pointer. */\n    buf = inUseQueueFindMemBufHdr(mem);\n    assert(buf != NULL);\n\n#ifdef VERBOSE\n    numBytesAllocated -= (buf->size + sizeof(MemBufHdr));\n    printf(\"\\nBytes allocated: %d out of %d.\\n\", numBytesAllocated, EXTMODE_STATIC_SIZE);\n#endif\n\n    /* Remove the buffer from the linked list. */\n    removeMemBuf(buf);\n\n    /* Put the buffer back in the free queue. */\n    insertMemBufRight(buf, FreeQueue);\n    mergeMemBuf(buf);\n}\n\nPUBLIC void *ExtModeCalloc(uint32_T number, uint32_T size)\n{\n    uint32_T numBytes = number*size;\n    void     *mem     = ExtModeMalloc(numBytes);\n\n    if (mem == NULL) goto EXIT_POINT;\n\n    memset(mem, 0, numBytes);\n\n  EXIT_POINT:\n    return mem;\n}\n\nPUBLIC void *ExtModeMalloc(uint32_T size)\n{\n    boolean_T keepTrying = false;\n\n    MemBufHdr *LocalMemBuf = NULL; /* Requested buffer (NULL if none available). */\n    MemBufHdr *FreeMemBuf = NULL;  /* First free buffer big enough for request. */\n\n    /*\n     * Must allocate enough space for the requested number of bytes plus the\n     * size of the memory buffer header.\n     */\n    int sizeToAlloc = size + sizeof(MemBufHdr);\n\n    while (!keepTrying) {\n        keepTrying = true;\n\n        LocalMemBuf = NULL;\n        FreeMemBuf  = NULL;\n\n        /* Initialize the free queue. */\n        if (FreeQueue == NULL) initFreeQueue();\n\n        /* Find first free packet big enough for our request. */\n        FreeMemBuf = findFirstFreeMemBuf(sizeToAlloc);\n\n        if (FreeMemBuf == NULL) {\n            /* We couldn't find a free buffer.  Run garbage collection to merge\n               free buffers together and try again. */\n            sortQueue(FreeQueue);\n\n            FreeMemBuf = findFirstFreeMemBuf(sizeToAlloc);\n        }\n\n        /* No free buffers are available which satisfy the request. */\n        if (FreeMemBuf == NULL) goto EXIT_POINT;\n\n        /*\n         * Found a free buffer with enough space.  Carve out the exact buffer size\n         * needed from the end of the free buffer.\n         */\n        LocalMemBuf = (MemBufHdr *)(FreeMemBuf->MemBuf +\n                                    FreeMemBuf->size -\n                                    sizeToAlloc);\n\n        /*\n         * The pointer to the free memory must be longword aligned.  If it\n         * is not, adjust the size to allocate and try again.\n         */\n        {\n            int alignBytes = (int)((ptrdiff_t)LocalMemBuf % 4);\n            if (alignBytes) {\n                sizeToAlloc += (4-alignBytes);\n                keepTrying = false;\n            }\n        }\n    }\n\n    /* Set up the new packet's info. */\n    LocalMemBuf->memBufPrev = NULL;\n    LocalMemBuf->memBufNext = NULL;\n    LocalMemBuf->MemBuf     = (char *)LocalMemBuf + sizeof(MemBufHdr);\n    LocalMemBuf->size       = size;\n\n    /* Insert the newly created buffer into the InUseQueue. */\n    inUseQueueInsert(LocalMemBuf);\n\n    /* Update the free packet's size to reflect giving up a piece. */\n    FreeMemBuf->size -= sizeToAlloc;\n\n  EXIT_POINT:\n    if (LocalMemBuf) {\n#ifdef VERBOSE\n        numBytesAllocated += sizeToAlloc;\n        printf(\"\\nBytes allocated: %d out of %d.\\n\", numBytesAllocated, EXTMODE_STATIC_SIZE);\n#endif\n        return LocalMemBuf->MemBuf;\n    }\n\n#ifdef VERBOSE\n    printf(\"\\nBytes allocated: %d out of %d.\", numBytesAllocated+sizeToAlloc, EXTMODE_STATIC_SIZE);\n    printf(\"\\nMust increase size of static allocation!\\n\");\n#endif\n    return NULL;\n}\n"},{"name":"rt_logging.c","type":"source","group":"other","path":"/Applications/MATLAB_R2024a.app/rtw/c/src","tag":"","groupDisplay":"Other files","code":"/* \n *\n * Copyright 1994-2022 The MathWorks, Inc.\n *\n * File: rt_logging.c\n *\n * Abstract:\n *\tReal-Time Workshop data logging routines using circular buffers of\n *      fixed size.  The buffers are allocated at start, filled in at each\n *      major time step and finally written to a MAT-file at the end of the\n *      simulation.\n *\n *      This file handles redefining the following standard MathWorks types\n *      (see tmwtypes.h):\n *         [u]int8_T     to be int32_T (logged as Matlab [u]int32)\n *         [u]int16_T    to be int32_T (logged as Matlab [u]int32)\n *         real_T        to be real32_T (logged as Matlab single)\n *\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n\n\n#if !defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)\n\n#include <stddef.h>                     /* size_t */\n#include \"rt_logging.h\"\n#ifndef IS_RAPID_ACCEL\n#include \"rt_mxclassid.h\"\n#endif\n#include \"rtw_matlogging.h\"\n\n#include \"rtwtypes.h\"\n\n#ifndef TMW_NAME_LENGTH_MAX\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n#define matUNKNOWN                  0\n#define\tmatINT8                     1\n#define\tmatUINT8                    2\n#define\tmatINT16                    3\n#define\tmatUINT16                   4\n#define\tmatINT32                    5\n#define\tmatUINT32                   6\n#define\tmatFLOAT                    7\n#define\tmatDOUBLE                   9\n#define matINT64                   12\n#define matUINT64                  13\n#define\tmatMATRIX                  14\n\n#define matLOGICAL_BIT          0x200\n#define matCOMPLEX_BIT          0x800\n\n#define matKEY                 0x4D49\n#define matVERSION             0x0100\n#define matVERSION_INFO_OFFSET   124L\n\n#define matINT64_ALIGN(e)      ( ( ((unsigned)(e))+7 ) & (~7) )\n#define matTAG_SIZE            (sizeof(int32_T) << 1)\n\n#ifndef DEFAULT_BUFFER_SIZE\n#define DEFAULT_BUFFER_SIZE      1024  /* used if maxRows=0 and Tfinal=0.0    */\n#endif\n\n#define FREE(m) if (m != NULL) free(m)\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\n/*==========*\n * typedefs *\n *==========*/\n\ntypedef struct LogInfo_Tag {\n    LogVar       *t;                   /* Time log variable                   */\n    void         *x;                   /* State log variable                  */\n    int_T        ny;                   /* Length of \"y\" log variables         */\n    void         **y;                  /* Output log vars                     */\n    void         *xFinal;              /* Final state log variable            */\n\n    LogVar       *logVarsList;         /* Linked list of all LogVars          */\n    StructLogVar *structLogVarsList;   /* Linked list of all StructLogVars    */\n\n    boolean_T   haveLogVars;           /* Are logging one or more vars?       */\n} LogInfo;\n\ntypedef struct MatItem_tag {\n  int32_T    type;\n  uint32_T    nbytes;\n  const void *data;\n} MatItem;\n\ntypedef enum {\n    DATA_ITEM,\n    MATRIX_ITEM,\n    STRUCT_LOG_VAR_ITEM,\n    SIGNALS_STRUCT_ITEM\n} ItemDataKind;\n\n/*===========*\n * Constants *\n *===========*/\n\nstatic const char_T rtMemAllocError[] = \"Memory allocation error\";\n\n#define ZEROS32 \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\n#if mxMAXNAM==32\n\n#define ZERO_PAD\n\n#elif mxMAXNAM==64\n\n#define ZERO_PAD ZEROS32\n\n#elif mxMAXNAM==128\n\n#define ZERO_PAD   ZEROS32  ZEROS32  ZEROS32\n\n#else\n\n#error \"Cannot Handle mxMAXNAM other than 32,64, and 128\"\n\n#endif\n/* field names: for variable-size signal logging */\nstatic const char_T rtStructLogVarFieldNames[] =\n                  \"time\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"signals\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtLocalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n                  \n\n#define TIME_FIELD_NAME      (rtStructLogVarFieldNames[0*mxMAXNAM])\n#define SIGNALS_FIELD_NAME   (rtStructLogVarFieldNames[1*mxMAXNAM])\n#define BLOCKNAME_FIELD_NAME (rtStructLogVarFieldNames[2*mxMAXNAM])\n\n#define VALUES_FIELD_NAME    (rtLocalLoggingSignalsStructFieldNames[0*mxMAXNAM])\n#define VALUEDIMENSIONS_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[1*mxMAXNAM])\n#define DIMENSION_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[2*mxMAXNAM])\n#define LABEL_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[3*mxMAXNAM])\n#define TITLE_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[4*mxMAXNAM])\n#define PLOTSTYLE_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n\n#define STATENAME_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n#define CROSS_MDL_REF_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[6*mxMAXNAM])\n\n/* field names: for fixed-size signal logging */\nstatic const char_T rtLocalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nextern real_T rtInf; /* declared by rt_nonfinite.c */\nextern real_T rtNaN;\nextern real32_T rtNaNF;\n\n/*================*\n * Local routines *\n *================*/\n\n/* Function: rt_GetSizeofDataType ==============================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofDataType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 0; /* unknown */\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        elSz = sizeof(real_T);\n        break;\n      case SS_SINGLE:\n        elSz = sizeof(real32_T);\n        break;\n      case SS_INT8:\n        elSz = sizeof(int8_T);\n        break;\n      case SS_UINT8:\n        elSz = sizeof(uint8_T);\n        break;\n      case SS_INT16:\n        elSz = sizeof(int16_T);\n        break;\n      case SS_UINT16:\n        elSz = sizeof(uint16_T);\n        break;\n      case SS_INT32:\n        elSz = sizeof(int32_T);\n        break;\n      case SS_UINT32:\n        elSz = sizeof(uint32_T);\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n    return(elSz);\n\n} /* end rt_GetSizeofDataType */\n\n\n/* Function: rt_GetSizeofComplexType ===========================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofComplexType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 2*rt_GetSizeofDataType(dTypeID);\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal_T);\n      #endif\n        break;\n      case SS_SINGLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal32_T);\n      #endif\n        break;\n      case SS_INT8:\n      #ifdef CINT8_T\n        elSz = sizeof(cint8_T);\n      #endif\n        break;\n      case SS_UINT8:\n      #ifdef CUINT8_T\n        elSz = sizeof(cuint8_T);\n      #endif\n        break;\n      case SS_INT16:\n      #ifdef CINT16_T\n        elSz = sizeof(cint16_T);\n      #endif\n        break;\n      case SS_UINT16:\n      #ifdef CUINT16_T\n        elSz = sizeof(cuint16_T);\n      #endif\n        break;\n      case SS_INT32:\n      #ifdef CINT32_T\n        elSz = sizeof(cint32_T);\n      #endif\n        break;\n      case SS_UINT32:\n      #ifdef CUINT32_T\n        elSz = sizeof(cuint32_T);\n      #endif\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n\n    return(elSz);\n\n} /* end rt_GetSizeofComplexType */\n\n\n/* Function: rt_GetDataTypeConvertInfo =========================================\n * Abstract:\n *      Directly copy if pointer to structure is non-NULL, otherwise set to\n *      default.\n */\nstatic RTWLogDataTypeConvert rt_GetDataTypeConvertInfo(\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    BuiltInDTypeId dTypeID\n    )\n{\n    RTWLogDataTypeConvert dataTypeConvertInfoCopy;\n\n    if (pDataTypeConvertInfo == NULL) {\n        dataTypeConvertInfoCopy.conversionNeeded = 0;\n        dataTypeConvertInfoCopy.dataTypeIdLoggingTo = dTypeID;\n        dataTypeConvertInfoCopy.dataTypeIdOriginal  = (DTypeId)dTypeID;\n        dataTypeConvertInfoCopy.bitsPerChunk = 0;\n        dataTypeConvertInfoCopy.numOfChunk = 0;\n        dataTypeConvertInfoCopy.isSigned = 0;\n        dataTypeConvertInfoCopy.fracSlope = 1.0;\n        dataTypeConvertInfoCopy.fixedExp = 0;\n        dataTypeConvertInfoCopy.bias = 0.0;\n    } else {\n        dataTypeConvertInfoCopy = *pDataTypeConvertInfo;\n    }\n\n    return dataTypeConvertInfoCopy;\n\n} /* end rt_GetDataTypeConvertInfo */\n\n\n/* Function: rt_GetDblValueFromOverSizedData ===================================\n * Abstract:\n */\nstatic double rt_GetDblValueFromOverSizedData(\n    const void *pVoid, \n    int bitsPerChunk, \n    int numOfChunk,\n    unsigned int isSigned, \n    double fracSlope, \n    int fixedExp, \n    double bias)\n{\n    double retValue = 0;\n\n    double *dblValue = (double *) calloc(numOfChunk, sizeof(double));\n\n    int i;    \n    double isSignedNeg;\n\n    if(isSigned) {\n        const chunk_T *pData = (const chunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    } else  {\n        const uchunk_T *pData = (const uchunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    }\n\n    /* \n       Assuming multi chunks b_n ... b_2 b_1 b_0, and the length of each chunk is N.\n       Suppose b_i is the i-th chunk's value.\n       Then for unsigned data or data with one chunk: we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0;\n       But for signed data, we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0+ (b_0<0) * 2^N + \n       ... (b_(n-1) <0) * 2^(n*N) \n       = (b_n + (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + (b_0<0)) * 2^N + b_0 * 2^0;\n       Together:\n       retValue = \n       (b_n + isSigned * (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + isSigned * (b_0<0)) * 2^N + b_0 * 2^0;\n    */\n\n    retValue = dblValue[numOfChunk - 1];\n    \n    for(i = numOfChunk - 1; i > 0; i--) {\n        isSignedNeg = dblValue[i - 1] < 0 ? (double)isSigned : 0;\n        retValue = retValue + isSignedNeg;\n\n        retValue = ldexp(retValue, bitsPerChunk)+ dblValue[i-1];\n    }\n    retValue = ldexp( fracSlope * retValue, fixedExp ) + bias;\n\n    FREE(dblValue);\n    return (retValue);\n\n} /* end rt_GetDblValueFromOverSizedData */\n\n\n/* Function: rt_GetNonBoolMxIdFromDTypeId ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nstatic mxClassID rt_GetNonBoolMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        mxID = (sizeof(real_T)==4? mxSINGLE_CLASS: mxDOUBLE_CLASS);\n        break;\n      case SS_SINGLE:\n        mxID = mxSINGLE_CLASS;\n        break;\n      case SS_INT8:\n        switch (sizeof(int8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 32-bits\" */\n            mxID = mxINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 16-bits\" */\n            mxID = mxINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_UINT8:\n        switch (sizeof(uint8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxUINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_INT16:\n        mxID = (sizeof(int16_T)==4? mxINT32_CLASS: mxINT16_CLASS);\n        break;\n      case SS_UINT16:\n        mxID = (sizeof(uint16_T)==4? mxUINT32_CLASS: mxUINT16_CLASS);\n        break;\n      case SS_INT32:\n        mxID = mxINT32_CLASS;\n        break;\n      case SS_UINT32:\n        mxID = mxUINT32_CLASS;\n        break;\n        /*case SS_BOOLEAN:\n          mxID = (sizeof(boolean_T)==4? mxUINT32_CLASS: mxLOGICAL_CLASS);\n          break;*/\n      default:\n        mxID = mxUNKNOWN_CLASS;\n        break;\n    }\n\n    return(mxID);\n\n} /* end rt_GetNonBoolMxIdFromDTypeId */\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeIdForRSim ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeIdForRSim(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxLOGICAL_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeIdForRSim */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeId =============================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxUINT8_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeId */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n/* Function: rt_GetMatIdFromMxId ===============================================\n * Abstract:\n *      Get the MatId given the mxClassID.\n */\nstatic int_T rt_GetMatIdFromMxId(mxClassID mxID)\n{\n    int_T matID;\n\n    switch (mxID) {\n      case mxCELL_CLASS:\n      case mxSTRUCT_CLASS:\n      case mxOBJECT_CLASS:\n        matID = -1;\n        break;\n      case mxCHAR_CLASS:\n        matID = matUINT16;\n        break;\n      case mxDOUBLE_CLASS:\n        matID = matDOUBLE;\n        break;\n      case mxSINGLE_CLASS:\n        matID = matFLOAT;\n        break;\n      case mxINT8_CLASS:\n        matID = matINT8;\n        break;\n      case mxUINT8_CLASS:\n        matID = matUINT8;\n        break;\n      case mxINT16_CLASS:\n        matID = matINT16;\n        break;\n      case mxUINT16_CLASS:\n        matID = matUINT16;\n        break;\n      case mxINT32_CLASS:\n        matID = matINT32;\n        break;\n      case mxUINT32_CLASS:\n        matID = matUINT32;\n        break;\n      case mxINT64_CLASS:\n        matID = matINT64;\n        break;\n      case mxUINT64_CLASS:\n        matID = matUINT64;\n        break;\n      default:\n        matID = matUNKNOWN;\n        break;\n    }\n    return(matID);\n\n} /* end rt_GetMatIdFromMxId */\n\n\n/* Forward declaration */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind dataKind);\n\n\n/* Function: rt_ProcessMatItem =================================================\n * Abstract:\n *      This routine along with rt_WriteItemToMatFile() write out a specified\n *      mat-item the .mat file. Note that if the input argument\n *          cmd == 0, then this function just calculates the size of the item.\n *          cmd <> 0, this function writes the mat-item to the file.\n *      Return values is\n *           -1 : coding/logic error\n *            0 : upon success\n *          > 0 : upon write failure (1)\n */\nstatic int_T rt_ProcessMatItem(FILE         *fp,\n                               MatItem      *pItem,\n                               ItemDataKind itemKind,\n                               int_T        cmd)\n{\n    mxClassID    mxID          = mxUNKNOWN_CLASS;\n    uint32_T     arrayFlags[2] = {0, 0};\n    int32_T      *dims         = NULL;\n    int32_T      _dims[3]      = {0, 0, 0};\n    int32_T      nDims         = 2;\n    int32_T      nBytesInItem  = 0;\n    const char_T *itemName;\n    MatItem      item;\n    int_T        retStat       = 0;\n\n    switch (itemKind) {\n      case DATA_ITEM: {\n          (void)fprintf(stderr,\"Unexpected itemKind = DATA_ITEM in \"\n                               \"rt_ProcessMatItem @A\\n\");\n          retStat = -1;\n          goto EXIT_POINT;\n      }\n      case MATRIX_ITEM: {\n          const MatrixData *var = (const MatrixData *) pItem->data;\n\n          mxID           = var->mxID;\n          arrayFlags[0]  = mxID;\n          arrayFlags[0] |= var->logical;\n          arrayFlags[0] |= var->complex;\n          if (var->nDims < 2) {\n              dims         = _dims;\n              dims[0]      = var->nRows;\n              dims[1]      = var->nCols;\n              nDims        = 2;\n          } else {\n              int32_T k;\n              dims = (int32_T*)malloc(sizeof(int32_T)*(var->nDims+1));\n              for (k = 0; k < var->nDims; k++) {\n                  dims[k] = var->dims[k];\n              }\n              dims[var->nDims] = var->nRows;\n              nDims = var->nDims + 1;\n          }\n          itemName = var->name;\n          break;\n      }\n      case STRUCT_LOG_VAR_ITEM: {\n          const StructLogVar *var = (const StructLogVar *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = 1;\n          itemName      = var->name;\n          break;\n      }\n      case SIGNALS_STRUCT_ITEM: {\n          const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = var->numSignals;\n          itemName      = &SIGNALS_FIELD_NAME;\n          break;\n      }\n      default:\n        (void)fprintf(stderr,\"Unexpected itemKind=%d in rt_ProcessMatItem @B\\n\",\n                      itemKind);\n        retStat = -1;\n        goto EXIT_POINT;\n    }\n\n    /* array flags */\n    item.nbytes = 2*sizeof(uint32_T);\n    if (cmd) {\n        item.type = matUINT32;\n        item.data = arrayFlags;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* dimensions */\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    item.nbytes = nDims*sizeof(int32_T);\n    if (cmd) {\n        item.type = matINT32;\n        item.data = dims;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;            \n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* name */\n    item.nbytes = (int32_T)strlen(itemName);\n    if (cmd) {\n        item.type = matINT8;\n        item.data = (const char_T*) itemName;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        nBytesInItem += (item.nbytes <= 4) ? /*LINTED E_CAST_INT_TO_SMALL_INT*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n\n    if (itemKind == MATRIX_ITEM) {\n        const MatrixData *var   = (const MatrixData*) pItem->data;\n        int_T            matID  = rt_GetMatIdFromMxId(mxID);\n        size_t           elSize = var->elSize;\n\n        /* data */\n        item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n        if (cmd) {\n            item.type = matID;\n            item.data = var->re;\n            if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n        }\n        /* imaginary part */\n        if (var->complex) {\n            item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n            if (cmd) {\n                item.type = matID;\n                item.data = var->im;\n                if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                    retStat = 1;\n                    goto EXIT_POINT;\n                }\n            } else {\n                nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n            }\n        }\n    } else {  /* some type of structure item */\n        const char_T *fieldNames;\n        int_T        sizeofFieldNames;\n\n        /* field names */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = (const StructLogVar *) pItem->data;\n              fieldNames        = rtStructLogVarFieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n              fieldNames        = var->fieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @C\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n\n        /* write field names */\n        if (cmd) {\n            int32_T tmpInt = mxMAXNAM;\n\n            item.nbytes = sizeof(int32_T);\n            item.type   = matINT32;\n            item.data   = &tmpInt;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n\n            item.nbytes = sizeofFieldNames;\n            item.type   = matINT8;\n            item.data   = (const char_T*) fieldNames;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            /*LINTED E_CAST_INT_TO_SMALL_INT*/\n            nBytesInItem += matINT64_ALIGN( matTAG_SIZE + matTAG_SIZE +\n                                            sizeofFieldNames );\n        }\n\n        /* process each field of the structure */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = pItem->data;\n\n              /* time */\n              {\n                  const void *data = var->time;\n\n                  if (var->logTime) { /* time is a LogVar, get the MatrixData */\n                      data = &(((const LogVar*) (var->time))->data);\n                  }\n\n                  item.type = matMATRIX;\n                  item.data = data;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp,&item,MATRIX_ITEM)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM,0)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n\n              /* signals */\n              item.type = matMATRIX;\n              item.data = &(var->signals);\n              if (cmd) {\n                  if (rt_WriteItemToMatFile(fp,&item,SIGNALS_STRUCT_ITEM)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n              } else {\n                  if (rt_ProcessMatItem(fp, &item, SIGNALS_STRUCT_ITEM,0)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n                  nBytesInItem += item.nbytes + matTAG_SIZE;\n              }\n\n              /* block name */\n              if (var->blockName != NULL) {\n                  item.type = matMATRIX;\n                  item.data = var->blockName;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var        = pItem->data;\n              const LogVar        *values     = var->values;\n              const MatrixData    *dimensions = var->dimensions;\n              const MatrixData    *labels     = var->labels;\n              const MatrixData    *plotStyles = var->plotStyles;\n              const MatrixData    *titles     = var->titles;\n              const MatrixData    *blockNames = var->blockNames;\n              const MatrixData    *stateNames = var->stateNames;\n              const MatrixData    *crossMdlRef = var->crossMdlRef;\n              const boolean_T logValueDimensions = var->logValueDimensions;\n              int_T               i;\n\n              for (i = 0; i < var->numSignals; i++) {\n                  /* values */\n                  item.type = matMATRIX;\n                  item.data = &(values->data);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n\n                  if(logValueDimensions)\n                  {\n                      /* valueDimensions */\n                      /* Since the functions rt_WriteItemToMatFile and \n                         rt_ProcessMatItem deal with MatrixData, \n                         convert valDims to tempData, and fill up the\n                         necessary fields.\n                      */\n                      MatrixData  tempData;\n                      (void)memcpy(tempData.name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n                      tempData.nRows = values->valDims->nRows;\n                      tempData.nCols = values->valDims->nCols;\n                      tempData.nDims = 1;\n                      tempData._dims[0] = values->valDims->nCols;\n                      tempData.re = values->valDims->dimsData;\n                      tempData.im = NULL;\n                      tempData.dTypeID = SS_DOUBLE;\n                      tempData.elSize =  sizeof(real_T);\n                      tempData.mxID = mxDOUBLE_CLASS;\n                      tempData.logical = 0;\n                      tempData.complex = 0;\n                      tempData.frameData = 0;\n                      tempData.frameSize = 1;\n\n                      item.type = matMATRIX;                    \n                      item.data = &tempData; /*values->valDims;*/\n\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  values = values->next;\n\n                  /* dimensions */\n                  if (dimensions != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(dimensions[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n\n                  /* label */\n                  item.type = matMATRIX;\n                  item.data = &(labels[i]);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n                  /* title */\n                  if (titles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(titles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* plot style */\n                  if (plotStyles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(plotStyles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* block name */\n                  if (blockNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(blockNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* state name */\n                  if (stateNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(stateNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* crossMdlRef */\n                  if (crossMdlRef != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(crossMdlRef[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n              } /* for i=1:numSignals */\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @D\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n    } /* end struct item */\n\n    if (!cmd) {\n        pItem->nbytes = nBytesInItem;\n    }\n\n  EXIT_POINT:\n    if (dims != _dims) {\n        FREE(dims);\n    }\n    return(retStat);\n\n} /* end rt_ProcessMatItem */\n\n\n/* Function: rt_WriteItemToMatFile =============================================\n * Abstract:\n *      Entry function for writing out a mat item to the mat file.\n *\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind itemKind)\n{\n    /* Determine the item size */\n    if (pItem->type == matMATRIX) {\n        if (rt_ProcessMatItem(fp, pItem, itemKind, 0)) return(1);\n    }\n\n    /* Write the item tag and data */\n    if (pItem->nbytes > 4) {\n        int32_T nAlignBytes;\n\n        if (fwrite(pItem, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n\n        if (pItem->type == matMATRIX) {\n            if (rt_ProcessMatItem(fp, pItem, itemKind, 1)) return(1);\n        } else {\n            if ( fwrite(pItem->data, 1, pItem->nbytes, fp) !=\n                                                    ((size_t) pItem->nbytes) ) {\n                return(1);\n            }\n        }\n\n        /* Add offset for 8-byte alignment */\n        nAlignBytes = matINT64_ALIGN(pItem->nbytes) - pItem->nbytes;\n        if (nAlignBytes > 0) {\n            int pad[2] = {0, 0};\n            if ( fwrite(pad,1,nAlignBytes,fp) != ((size_t) nAlignBytes) ) {\n                return(1);\n            }\n        }\n    } else {\n        MatItem item = {0, 0, NULL};\n        item.type = ((uint32_T)(pItem->type))|(((uint32_T)(pItem->nbytes))<<16);\n        (void)memcpy(&item.nbytes, pItem->data, pItem->nbytes);\n        if (fwrite(&item, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n    }\n\n    return(0);\n\n} /* end rt_WriteItemToMatFile */\n\n\n/* Function: rt_WriteMat5FileHeader ============================================\n * Abstract:\n *      Function to write the mat file header.\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteMat5FileHeader(FILE *fp)\n{\n    int_T        nbytes;\n    int_T        nspaces;\n    int_T        i, n;\n    unsigned short ver[2];\n    char_T       spaces[16];\n    const char_T *matversion = \"MATLAB 5.0 MAT-file\";\n\n    (void)memset(spaces, ' ', sizeof(spaces));\n\n    n = (int_T)strlen(matversion);\n    nbytes = (int_T)fwrite(matversion, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    nspaces = matVERSION_INFO_OFFSET - nbytes;\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces % sizeof(spaces);\n    nbytes += (int_T)fwrite(spaces, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces / sizeof(spaces);\n    for (i = 0; i < n; ++i) {\n        nbytes += (int_T)fwrite(spaces, 1, sizeof(spaces), fp);\n    }\n    if (nbytes == matVERSION_INFO_OFFSET) {\n        ver[0] = matVERSION;\n        ver[1] = matKEY;\n        nbytes += (int_T)fwrite(ver, 1, sizeof(ver), fp);\n    }\n    return(nbytes != matVERSION_INFO_OFFSET + sizeof(ver));\n\n} /* end rt_WriteMat5FileHeader */\n\n\n/* Function: rt_FixupLogVar ====================================================\n * Abstract:\n *\tMake the logged variable suitable for MATLAB.\n */\nstatic const char_T *rt_FixupLogVar(LogVar *var,int verbose)\n{\n    int_T  nCols   = var->data.nCols;\n    int_T  maxRows = var->data.nRows;\n    int_T  nDims   = var->data.nDims;\n    size_t elSize  = var->data.elSize;\n    int_T  nRows   = (var->wrapped ?  maxRows : var->rowIdx);\n\n    var->nDataPoints = var->rowIdx + var->wrapped * maxRows;\n\n    if (var->wrapped > 1 || (var->wrapped == 1 && var->rowIdx != 0)) {\n        /*\n         * Warn the user the circular buffer has wrapped, implying that\n         * some data has been lost.\n         */\n        if( verbose) {\n            (void)fprintf(stdout,\n                          \"*** Log variable %s has wrapped %d times\\n\"\n                          \"    using a circular buffer of size %d\\n\",\n                          var->data.name, var->wrapped, var->data.nRows);\n        }\n        if (var->usingDefaultBufSize) {\n            /*\n             * If wrapping occurred using the default buffer size,\n             * let the user know what size buffer to use in the\n             * future to avoid wrapping.  If the default buffer\n             * size was not used, the user has no control to specify\n             * the correct value.  Wrapping may occur when not using\n             * the default buffer if we allocated too small a buffer\n             * size for this logvar.  One common case is a toWorkspace\n             * block inside of an iterative subsystem - we can not take\n             * the number of iterations into account (they may be\n             * variable) when allocating the buffer.  In this case,\n             * just warn the buffer wrapped and don't tell user they\n             * can override the buffer size.\n             */\n            if( verbose ) {\n                (void)fprintf(stdout,\n                              \"*** To avoid wrapping, explicitly specify a\\n\"\n                              \"    buffer size of %d in your Simulink model\\n\"\n                              \"    by adding OPTS=\\\"-DDEFAULT_BUFFER_SIZE=%d\\\"\\n\"\n                              \"    as an argument to the ConfigSet MakeCommand\\n\"\n                              \"    parameter\\n\",\n                              var->nDataPoints, var->nDataPoints);\n            }\n        }\n    }\n\n    if (nDims < 2 && nCols > 1) {  /* Transpose? */\n        /* Don't need to transpose valueDimensions */\n        int_T  nEl    = nRows*nCols;\n        char   *src   = var->data.re;\n        char   *pmT;\n        int_T  k;\n\n        /**********************************\n         * If memory cannot be allocated, *\n         * write to a temporary buffer    *\n         **********************************/\n        if ((pmT = malloc(nEl*elSize)) == NULL) {\n            FILE  *fptr;\n            char  fName[mxMAXNAM+13];\n\n            (void)sprintf(fName, \"%s%s\", var->data.name, \"_rtw_tmw.tmw\");\n            if ((fptr=fopen(fName,\"w+b\")) == NULL) {\n                (void)fprintf(stderr,\"*** Error opening %s\",fName);\n                return(\"unable to open data file\\n\");\n            }\n\n            /****************************\n             * Write the data to a file *\n             ****************************/\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nCols*(k%nRows) + (k/nRows);\n                char  *dst = src + kT*elSize;\n                (void)fwrite(dst, elSize, 1, fptr);\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n\n            /*******************************\n             * Read the data from the file *\n             *******************************/\n            (void)rewind(fptr);\n            (void)fread(var->data.re, elSize, nEl, fptr);\n            (void)fclose(fptr);\n            (void)remove(fName);\n        } else {\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nRows*(k%nCols) + (k/nCols);\n                char  *dst = pmT + kT*elSize;\n                (void)memcpy(dst, src, elSize);\n                src += elSize;\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n            FREE(var->data.re);\n            var->data.re = pmT;\n        }\n    } /* Transpose? */\n\n    if (var->wrapped > 0 && var->rowIdx != 0 ) {  /* Rotate? */\n        char_T *buffer    = var->data.re;\n        int_T  done       = 0; /* done: 0 (1) rotate real (imag) part. */\n\n        do {\n            char_T *col       = buffer;\n            int_T  rowOffset  = (int_T)((nDims == 1) ? (elSize) : (elSize * nCols));\n            int_T  colOffset  = (int_T)((nDims == 1)?  (nRows*elSize) : elSize);\n            int_T  zeroIdx    = var->rowIdx;\n            int_T  j;\n\n            for (j = 0 ; j < nCols; ++j, col += colOffset) {\n                int_T   swapCount;\n                int_T   srcIdx;\n                int_T   dstIdx;\n                int_T   tmpIdx;\n                MatReal tmp;\n\n                for (tmpIdx=0, swapCount=0; swapCount < nRows; tmpIdx++) {\n                    (void)memcpy(&tmp, col + tmpIdx*rowOffset, elSize);\n\n                    dstIdx=tmpIdx; \n                    srcIdx = ((dstIdx + zeroIdx) % nRows);\n                    while (srcIdx != tmpIdx) {\n                        (void)memcpy(col + dstIdx*rowOffset,\n                                     col + srcIdx*rowOffset,\n                                     elSize);\n                        ++swapCount;\n                        dstIdx = srcIdx;\n                        srcIdx = ((dstIdx + zeroIdx) % nRows);\n                        \n                    }\n                    (void)memcpy(col + dstIdx*rowOffset, &tmp, elSize);\n                    ++swapCount;\n                }\n            }\n            done ++;\n            /* need to rotate the imaginary part */\n        } while ((done == 1) && ((buffer = var->data.im) != NULL));\n\n        var->rowIdx = 0;\n    } /* Rotate? */\n\n    /*\n     * We might have allocated more number of rows than the number of data\n     * points that have been logged, in which case set nRows to nDataPoints\n     * so that only these values get saved.\n     */\n    if (var->nDataPoints < var->data.nRows) {\n        var->data.nRows = var->nDataPoints;\n        if(var->valDims != NULL){\n            size_t elSizeValDims = sizeof(real_T);\n            int_T  k;\n            real_T *dimsData = var->valDims->dimsData + nRows;\n            /* \n               Keep nRows of values and that of valueDimensions consistent \n               for variable-size signals.\n            */\n            var->valDims->nRows = var->data.nRows;\n            /*\n               Also need to move data when shrinking the array size,\n               because valueDimensions data is stored in array format. \n               e.g. maxRows = 4; nRows = 2; nDims = 3;\n               Before fixing up the logVar, the locations of data are as below:\n               (x, y, z -- useful data / o -- junk)\n               a[0] = x    a[4] = y    a[8] = z\n               a[1] = x    a[5] = y    a[9] = z\n               a[2] = o    a[6] = o    a[10]= o\n               a[3] = o    a[7] = o    a[11]= o\n               After fixing up the logVar, we want the data to be stored as:\n               a[0] = x    a[4] = z    a[8] = o\n               a[1] = x    a[5] = z    a[9] = o\n               a[2] = y    a[6] = o    a[10]= o\n               a[3] = y    a[7] = o    a[11]= o\n            */\n            for(k = 1; k < nDims; k++){\n                (void) memmove(dimsData, \n                              var->valDims->dimsData + k*maxRows,\n                              elSizeValDims * nRows);\n                dimsData += nRows;\n            }\n        }\n    }\n    return(NULL);\n\n} /* end rt_FixupLogVar */\n\n\n/* Function: rt_LoadModifiedLogVarName =========================================\n * Abstract:\n *      The name of the logged variable is obtained from the input argument\n *      varName and the nameModifier which is obtained from the simstruct. If\n *      the nameModifier begins with an '_', then nameModifier is post-pended to\n *      varName to obtain the name of the logged variable. If the first\n *      character does not begin with an '_', then the nameModifier is\n *      pre-pended to varName.\n *\n * Examples:\n *     a)  varName = \"tout\" & nameModifier = \"_rt\"  => logVarName = \"tout_rt\"\n *     b)  varName = \"tout\" & nameModifier = \"rt_\"  => logVarName = \"rt_tout\"\n *     c)  varName = \"tout\" & nameModifier = \"none\" => logVarName = \"tout\"\n */\nstatic void rt_LoadModifiedLogVarName(const RTWLogInfo *li,         /* in  */\n                                      const char       *varName,    /* in  */\n                                      char             *logVarName) /* out */\n{\n    int_T        nameLen;\n    const char_T *nameModifier = rtliGetLogVarNameModifier(li);\n\n    if (nameModifier != NULL && strcmp(nameModifier,\"none\")==0) {\n        nameModifier = NULL;\n    }\n\n    logVarName[mxMAXNAM-1] = '\\0';\n    if (nameModifier == NULL) {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n    } else if (nameModifier[0] == '_') {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, nameModifier, (size_t)mxMAXNAM-1-nameLen);\n    } else {\n        (void)strncpy(logVarName, nameModifier, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, varName, (size_t)mxMAXNAM-1-nameLen);\n    }\n\n} /* end rt_LoadModifiedLogVarName */\n\n\n/* Function: rt_GetActualDTypeID ===============================================\n * Abstract:\n *\tGiven a built-in data type id, return the actual data type id.\n *\tThe only time these are different is when real_T has been mapped\n *\tto a single.\n */\n#if defined(_MSC_VER)\n #pragma warning(push)\n #pragma warning(disable: 4127)\n#endif\nstatic BuiltInDTypeId rt_GetActualDTypeID(BuiltInDTypeId dTypeID)\n{\n    /*LINTED E_FALSE_LOGICAL_EXPR*/\n    if (dTypeID == SS_DOUBLE && sizeof(real_T) != 8) {     /* polyspace DEFECT:DEAD_CODE \n                                                              [Not a defect:Unset] \n                                                              \"Needed for when real_T has been \n                                                              mapped to a single\" */\n        return(SS_SINGLE);\n    } else {\n        return(dTypeID);\n    }\n\n} /* end rt_GetActualDTypeID */\n#if defined(_MSC_VER)\n #pragma warning(pop)\n#endif\n\n\n/* Function: rt_DestroyLogVar ==================================================\n * Abstract:\n *      Destroy the log var linked list.\n */\nstatic void rt_DestroyLogVar(LogVar *head)\n{\n    while(head) {\n        LogVar *var = head;\n        head = var->next;\n        FREE(var->data.re);\n        FREE(var->data.im);\n        if (var->data.dims != var->data._dims) {\n            FREE(var->data.dims);\n        }\n        /* free valDims if necessary */\n        if(var->valDims != NULL) {\n            FREE(var->valDims->dimsData);\n            FREE(var->valDims);\n        }\n        /* free coords, strides and currStrides if necessary */\n        FREE(var->coords);\n        FREE(var->strides);\n        FREE(var->currStrides);\n\n        FREE(var);\n    }\n\n} /* end rt_DestroyLogVar */\n\n\n/* Function: rt_DestroyStructLogVar ============================================\n * Abstract:\n *      Destroy the struct log var linked list.\n */\nstatic void rt_DestroyStructLogVar(StructLogVar *head)\n{\n    while(head) {\n        StructLogVar *var = head;\n\n        head = var->next;\n\n        if (var->logTime) { /* time is LogVar */\n            rt_DestroyLogVar(var->time);\n        } else {        /* time is MatrixData */\n            FREE(var->time);\n        }\n        rt_DestroyLogVar(var->signals.values);\n        FREE(var->signals.labels);\n        FREE(var->signals.plotStyles);\n        FREE(var->signals.dimensions);\n        FREE(var->signals.titles);\n        FREE(var->signals.blockNames);\n        FREE(var->signals.stateNames);\n        FREE(var->signals.crossMdlRef);\n        FREE(var->blockName);\n        FREE(var);\n    }\n\n} /* end rt_DestroyStructLogVar */\n\n\n/* Function: rt_InitSignalsStruct ==============================================\n * Abstract:\n *      Initialize the signals structure in the struct log variable.\n *\n * Returns:\n *\t== NULL  => success.\n *\t~= NULL  => failure, the return value is a pointer to the error\n *                           message, which is also set in the simstruct.\n */\nstatic const char_T *rt_InitSignalsStruct(RTWLogInfo             *li,\n                                          const real_T           startTime,\n                                          const real_T           finalTime,\n                                          const real_T           inStepSize,\n                                          const char_T           **errStatus,\n                                          StructLogVar           *var,\n                                          int_T                  maxRows,\n                                          int_T                  decimation,\n                                          real_T                 sampleTime,\n                                          const RTWLogSignalInfo *sigInfo)\n{\n    int_T                i, sigIdx;\n    SignalsStruct        *sig          = &(var->signals);\n    int_T                nSignals      = sigInfo->numSignals;\n    const int_T          *numCols      = sigInfo->numCols;\n    const int_T          *numDims      = sigInfo->numDims;\n    const int_T          *dims         = sigInfo->dims;\n    const BuiltInDTypeId *dTypes       = sigInfo->dataTypes;\n    const int_T          *cSgnls       = sigInfo->complexSignals;\n    const int_T          *fData        = sigInfo->frameData;\n    const char_T         **labels      = sigInfo->labels.cptr;\n    const int_T          *plotStyles   = sigInfo->plotStyles;\n    const char_T         *titles       = sigInfo->titles;\n    const int_T          *titleLen     = sigInfo->titleLengths;\n    const char_T         **blockNames  = sigInfo->blockNames.cptr;\n    const char_T         **stateNames  = sigInfo->stateNames.cptr;\n    const boolean_T      *crossMdlRef  = sigInfo->crossMdlRef;\n    void                 **currSigDims = sigInfo->currSigDims;\n    int_T                *currSigDimsSize = sigInfo->currSigDimsSize;\n    LogVar               *prevValues   = NULL;\n    int_T                dimsOffset    = 0;\n    boolean_T            *isVarDims    = sigInfo->isVarDims;\n    /* if any signal is variable-size, the field 'valueDimensions' is needed */\n    boolean_T            logValueDimensions = false;\n    const RTWLogDataTypeConvert *pDTConvInfo = sigInfo->dataTypeConvert;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    sig->numActiveFields = 1;\n    sig->numSignals      = nSignals;\n\n    sig->isVarDims = isVarDims;\n    /* check whether we need valueDimensions field*/\n    for (i=0; i<nSignals; i++){\n        if(isVarDims[i]){\n            logValueDimensions = true;\n            break;\n        }\n    }\n\n    /* values */\n    dimsOffset = 0;\n    for (i = 0; i < nSignals; i++) {\n        BuiltInDTypeId dt = (dTypes) ? dTypes[i] : SS_DOUBLE;\n        int_T          cs = (cSgnls) ? cSgnls[i] : 0;\n        int_T          fd = (fData)  ? fData[i]  : 0;\n        int_T          nd = (numDims) ? numDims[i] : 1;\n\n        const RTWLogDataTypeConvert *pDTConvInfoCur =\n                       (pDTConvInfo)  ? (pDTConvInfo+i)  : 0;\n\n        LogVar *values = NULL;\n        LogValDimsStat logValDimsStat;\n\n        if(!logValueDimensions){\n            logValDimsStat = NO_LOGVALDIMS;\n        }\n        else{\n            logValDimsStat = isVarDims[i] ? LOGVALDIMS_VARDIMS :  \n                                            LOGVALDIMS_EMPTYMX;\n        }\n\n        values = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                            inStepSize, errStatus,\n                                            &VALUES_FIELD_NAME,\n                                            dt, \n                                            pDTConvInfoCur,\n                                            0, cs, fd,\n                                            numCols[i],nd,\n                                            dims + dimsOffset,\n                                            logValDimsStat,\n                                            currSigDims + dimsOffset,\n                                            currSigDimsSize + dimsOffset,\n                                            maxRows,decimation,sampleTime, 0);\n\n        if (values == NULL) goto ERROR_EXIT;\n\n        if (sig->values == NULL) {\n            sig->values = values;\n        } else {\n            if (prevValues == NULL) goto ERROR_EXIT;\n            prevValues->next = values;\n        }\n        prevValues = values;\n        dimsOffset += nd;\n    }\n\n    if(logValueDimensions){\n        ++sig->numActiveFields;\n        sig->logValueDimensions = true;\n    }\n    else{\n        sig->logValueDimensions = false;\n    }\n\n    /* Dimensions */\n    {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            int_T nd = (numDims) ? numDims[i] : 1;\n            dataLen += nd;\n        }\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->dimensions = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->dimensions)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n          data[i] = dims[i]; /* cannot memcpy double <- int */\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->dimensions[i]);\n            int_T nd = (numDims) ? numDims[i] : 1;\n\n            (void)memcpy(mtxData->name, &DIMENSION_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = 1;\n            mtxData->nCols   = nd;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += nd;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* labels */\n    if (labels != NULL) {\n        unsigned short   *data;\n        size_t  nbytes;\n        int_T   dataLen    = 0;\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (labels[i] != NULL){\n                dataLen = dataLen + (int_T)strlen(labels[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->labels = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->labels)) + dataOffset);\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T labelLen = (labels[sigIdx]==NULL) ? 0 : (int_T)strlen(labels[sigIdx]);\n            for (i = 0; i < labelLen; i++) {\n                data[dataIdx++] = (uint8_T)labels[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->labels[i]);\n            int_T labelLen = (int_T)strlen(labels[i]);\n\n            (void)memcpy(mtxData->name, &LABEL_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (labelLen) ? 1 : 0;\n            mtxData->nCols   = labelLen;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += labelLen;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* plot styles */\n    if (plotStyles != NULL) {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            dataLen += numCols[i];\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->plotStyles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (real_T*) (((char_T*) (sig->plotStyles)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n            data[i] = plotStyles[i];\n        }\n\n        dimsOffset = 0;\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->plotStyles[i]);\n            \n            (void)memcpy(mtxData->name, &PLOTSTYLE_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = (numCols[i]) ? 1 : 0;\n            mtxData->nCols   = numCols[i];\n\n            mtxData->nDims   = numDims[i];\n            \n            if(mtxData->nDims > 2) {\n                if ((mtxData->dims = calloc(mtxData->nDims, sizeof(int_T))) == NULL) goto ERROR_EXIT;\n            } else {\n                mtxData->dims    = mtxData->_dims;\n            }\n            \n            mtxData->dims[0] = *(dims + dimsOffset);\n            if(mtxData->nDims >= 2) {\n                int32_T j;\n                for (j=1; j<mtxData->nDims; j++) {\n                    mtxData->dims[j] = *(dims + dimsOffset + j);\n                }\n            }\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data       += numCols[i];\n            dimsOffset += numDims[i];\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* titles */\n    if (titles != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen    = (int_T)strlen(titles);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->titles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (unsigned short*) (((char_T*) (sig->titles)) + dataOffset);\n        for (i = 0; i < dataLen; i++) {\n            data[i] = titles[i];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->titles[i]);\n\n            (void)memcpy(mtxData->name, &TITLE_FIELD_NAME, mxMAXNAM);\n            if (titleLen) {\n                mtxData->nRows   = (titleLen[i]) ? 1 : 0;\n                mtxData->nCols   = titleLen[i];\n            } else {\n                mtxData->nRows   = (dataLen) ? 1 : 0;\n                mtxData->nCols   = dataLen;\n            }\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += ((titleLen) ? titleLen[i] : dataLen);\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* block names */\n    if (blockNames != NULL)     {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (blockNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(blockNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->blockNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->blockNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (blockNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(blockNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)blockNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->blockNames[i]);\n            int_T blockNameLen = (int_T)strlen(blockNames[i]);\n\n            (void)memcpy(mtxData->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (blockNameLen) ? 1 : 0;\n            mtxData->nCols   = blockNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += blockNameLen;\n        }\n        ++sig->numActiveFields;\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    } else {\n        if(logValueDimensions){\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* state names */\n    if (stateNames != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (stateNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(stateNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->stateNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->stateNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (stateNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(stateNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)stateNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->stateNames[i]);\n            int_T stateNameLen = (int_T)strlen(stateNames[i]);\n\n            (void)memcpy(mtxData->name, &STATENAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (stateNameLen) ? 1 : 0;\n            mtxData->nCols   = stateNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += stateNameLen;\n        }\n        ++sig->numActiveFields;\n\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* CrossMdlRef */\n    if (crossMdlRef != NULL) {\n        real_T  *data;\n        size_t nbytes;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n\n        nbytes = dataOffset + nSignals*sizeof(real_T);\n\n        if ( (sig->crossMdlRef = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->crossMdlRef)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            data[sigIdx] = crossMdlRef[sigIdx];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->crossMdlRef[i]);\n\n            (void)memcpy(mtxData->name, &CROSS_MDL_REF_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = 1;\n            mtxData->nCols   = 1;\n            mtxData->nDims   = 1; /* => matlab scalar */\n\n            mtxData->re      = &data[i];\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_DOUBLE;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(SS_DOUBLE);\n            mtxData->elSize  = sizeof(real_T);\n            mtxData->logical = matLOGICAL_BIT;\n            mtxData->complex = 0U;\n            mtxData->frameData = 0;\n            mtxData->frameSize = 1;\n        }\n        ++sig->numActiveFields;\n    }\n    \n    return(NULL); /* NORMAL_EXIT */\n\n  ERROR_EXIT:\n\n    (void)fprintf(stderr, \"*** Error creating signals structure \"\n                  \"in the struct log variable %s\\n\", var->name);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyLogVar(sig->values);\n    FREE(sig->labels);\n    FREE(sig->plotStyles);\n    FREE(sig->dimensions);\n    FREE(sig->titles);\n    FREE(sig->blockNames);\n    FREE(sig->stateNames);\n    FREE(sig->crossMdlRef);\n    return(*errStatus);\n\n} /* end rt_InitSignalsStruct */\n\n\n/* Function: local_CreateStructLogVar ==========================================\n * Abstract:\n *      Create a logging variable in the structure format.\n *\n * Returns:\n *      ~= NULL  => success, returns the log variable created.\n *      == NULL  => failure, error message set in the simstruct.\n */\nstatic StructLogVar *local_CreateStructLogVar(\n    RTWLogInfo              *li,\n    const real_T            startTime,\n    const real_T            finalTime,\n    const real_T            inStepSize,\n    const char_T            **errStatus,\n    const char_T            *varName,\n    boolean_T               logTime,\n    int_T                   maxRows,\n    int_T                   decimation,\n    real_T                  sampleTime,\n    const RTWLogSignalInfo  *sigInfo,\n    const char_T            *blockName)\n{\n    StructLogVar *var;\n    LogInfo      *logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ( (var = calloc(1, sizeof(StructLogVar))) == NULL ) goto ERROR_EXIT;\n\n    var->numActiveFields = 2;\n\n    /* Setup the structure name using varName and nameModifier */\n    rt_LoadModifiedLogVarName(li,varName,var->name);\n\n    /* time field */\n    if (logTime) {\n        /* need to create a LogVar to log time */\n        int_T dims = 1;\n        var->time = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                               inStepSize, errStatus,\n                                               &TIME_FIELD_NAME, SS_DOUBLE, \n                                               NULL,\n                                               0, 0, 0, 1,\n                                               1, &dims, NO_LOGVALDIMS, \n                                               NULL, NULL, maxRows,\n                                               decimation, sampleTime, 0);\n        if (var->time == NULL) goto ERROR_EXIT;\n    } else {\n        /* create a dummy MatrixData to write out time as an empty matrix */\n        BuiltInDTypeId dt     = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         nbytes = sizeof(MatrixData);\n        MatrixData     *time;\n\n        if ( (var->time = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n        time = var->time;\n\n        (void)memcpy(time->name, &TIME_FIELD_NAME, mxMAXNAM);\n        time->nRows   = 0;\n        time->nCols   = 0;\n        time->nDims   = 0;\n        time->re      = NULL;\n        time->im      = NULL;\n        time->dTypeID = dt;\n        time->mxID    = rt_GetMxIdFromDTypeId(dt);\n        time->elSize  = rt_GetSizeofDataType(dt);\n        time->logical = 0U;\n        time->complex = 0U;\n    }\n    var->logTime = logTime;\n\n    /* signals field */\n    if (sigInfo) {\n        if (rt_InitSignalsStruct(li,startTime,finalTime,inStepSize,errStatus,\n                                 var,maxRows,decimation,sampleTime,sigInfo)) {\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* blockName Field */\n    if (blockName != NULL) {\n        int_T  dataLen = (int_T)strlen(blockName);\n        size_t nbytes;\n        size_t dataOffset = sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (var->blockName = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        (void)memcpy(var->blockName->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n        var->blockName->nRows   = (dataLen) ? 1 : 0;\n        var->blockName->nCols   = dataLen;\n\n        var->blockName->nDims   = 1;\n        var->blockName->dims    = var->blockName->_dims;\n        var->blockName->dims[0] = dataLen;\n        {\n            /*LINTED E_BAD_PTR_CAST_ALIGN*/\n            unsigned short *data = (unsigned short*)(((char_T*) (var->blockName))+dataOffset);\n            int_T   i;\n\n            for (i=0; i<dataLen; i++) {\n                data[i] = (uint8_T)blockName[i];\n            }\n            var->blockName->re  = data;\n        }\n        var->blockName->im      = NULL;\n        var->blockName->dTypeID = SS_INT16;\n        var->blockName->mxID    = mxCHAR_CLASS;\n        var->blockName->elSize  = sizeof(short);\n        var->blockName->logical = 0U;\n        var->blockName->complex = 0U;\n\n        ++var->numActiveFields;\n    }\n\n    /* Add this struct log var to the linked list in log info */\n    {\n        StructLogVar *list = logInfo->structLogVarsList;\n\n        if (list != NULL) {\n            while (list->next != NULL) {\n                list = list->next;\n            }\n            list->next = var;\n        } else {\n            logInfo->structLogVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Error creating log variable %s\\n\", varName);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyStructLogVar(var);\n    return(NULL);\n\n} /* end local_CreateStructLogVar */\n\n\n/* Function: rt_StartDataLoggingForOutput ======================================\n * Abstract:\n */\nstatic const char_T *rt_StartDataLoggingForOutput(RTWLogInfo   *li,\n                                                  const real_T startTime,\n                                                  const real_T finalTime,\n                                                  const real_T stepSize,\n                                                  const char_T **errStatus)\n{\n    const char_T   *varName;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    LogInfo *       logInfo;\n    logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    /* outputs */\n    varName = rtliGetLogY(li);\n    if (varName[0] != '\\0') {\n        int_T                  i;\n        int_T                  ny;\n        int_T                  yIdx;\n        char_T                 name[mxMAXNAM];\n        const char_T           *cp        = strchr(varName,',');\n        LogSignalPtrsType      ySigPtrs   = rtliGetLogYSignalPtrs(li);\n        const RTWLogSignalInfo *yInfo     = rtliGetLogYSignalInfo(li);\n\n        /* count the number of variables (matrices or structures) to create */\n        for (ny=1; cp != NULL; ny++) {\n            cp = strchr(cp+1,',');\n        }\n        logInfo->ny = ny;\n\n        if (logFormat==0) {\n            if ( (logInfo->y = calloc(ny,sizeof(LogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        } else {\n            if ( (logInfo->y = calloc(ny,sizeof(StructLogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        }\n\n        for (i = yIdx = 0, cp = varName; i < ny; i++) {\n            int_T        len;\n            const char_T *cp1 = strchr(cp+1,',');\n\n            if (cp1 != NULL) {\n                /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n                len = (int_T)(cp1 - cp);\n                if (len >= mxMAXNAM) len = mxMAXNAM - 1;\n            } else {\n                len = mxMAXNAM - 1;\n            }\n            (void)strncpy(name, cp, len);\n            name[len] = '\\0';\n\n            if (ny > 1 && ySigPtrs[i] == NULL) {\n                goto NEXT_NAME;\n            }\n\n            if (logFormat == 0) {\n                int            numCols;\n                int            nDims;\n                const int      *dims;\n                BuiltInDTypeId dataType;\n                int            isComplex;\n\n                if (ny == 1) {\n                    int_T op;\n\n                    numCols = yInfo[0].numCols[0];\n                    for (op = 1; op < yInfo[0].numSignals; op++) {\n                        numCols += yInfo[0].numCols[op];\n                    }\n                    /*\n                     * If we have only one \"matrix\" outport,\n                     * we can still log it as a matrix\n                     */\n                    if (yInfo[0].numSignals == 1) {\n                        nDims = yInfo[0].numDims ? yInfo[0].numDims[0] : 1;\n                        dims  = yInfo[0].dims;\n                    } else {\n                        nDims = 1;\n                        dims  = &numCols;\n                    }\n\n                    dataType  = yInfo[0].dataTypes[0];\n                    isComplex = yInfo[0].complexSignals[0];\n                } else {\n                    numCols   = yInfo[yIdx].numCols[0];\n                    nDims     = yInfo[yIdx].numDims ? yInfo[yIdx].numDims[0] : 1;\n                    dims      = yInfo[yIdx].dims;\n                    dataType  = yInfo[yIdx].dataTypes[0];\n                    isComplex = yInfo[yIdx].complexSignals[0];\n                }\n\n                logInfo->y[yIdx] = rt_CreateLogVarWithConvert(\n                    li, startTime, finalTime,\n                    stepSize, errStatus,\n                    name,\n                    dataType,\n                    yInfo[yIdx].dataTypeConvert,\n                    0,isComplex,\n                    0,numCols,nDims,dims,\n                    NO_LOGVALDIMS, NULL, NULL,\n                    maxRows,decimation,\n                    sampleTime,1);\n                if (logInfo->y[yIdx] == NULL)  goto ERROR_EXIT;\n            } else {\n                logInfo->y[yIdx] = local_CreateStructLogVar(li, startTime,\n                                                            finalTime, stepSize,\n                                                            errStatus, name,\n                                                            logTime, maxRows,\n                                                            decimation, sampleTime,\n                                                            &yInfo[yIdx], NULL);\n                if (logInfo->y[yIdx] == NULL) goto ERROR_EXIT;\n            }\n            ++yIdx;\n        NEXT_NAME:\n            cp = cp1;\n            if (cp != NULL && *cp == ',') cp++;\n        }\n    }\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) { /* polyspace DEFECT:USELESS_IF [No action planned:Unset] \n                     \"Defense coding.\" */\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo->y);\n        logInfo->y = NULL;\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingForOutput */\n\n\n/* Function: rt_ReallocLogVar ==================================================\n * Abstract:\n *   Allocate more memory for the data buffers in the log variable.\n *   Exit if unable to allocate more memory.\n */\nstatic void rt_ReallocLogVar(LogVar *var, boolean_T isVarDims)\n{\n    void *tmp;\n    int_T nCols = var->data.nCols;\n    int_T nRows;\n    size_t elSize = var->data.elSize;\n\n    if (isVarDims)\n    {\n        nRows = var->data.nRows + DEFAULT_BUFFER_SIZE;\n    }\n    else\n    {\n        nRows = var->data.nRows == 0 ? 1 : 2*var->data.nRows;\n    }\n    \n    tmp = realloc(var->data.re, nRows*nCols*elSize);\n    if (tmp == NULL) {\n        (void)fprintf(stderr,\n                      \"*** Memory allocation error.\\n\");\n        (void)fprintf(stderr, \"\"\n                      \"    varName          = %s%s\\n\"\n                      \"    nRows            = %d\\n\"\n                      \"    nCols            = %d\\n\"\n                      \"    elementSize      = %lu\\n\"\n                      \"    Current Size     = %.16g\\n\"\n                      \"    Failed resize    = %.16g\\n\\n\",\n                      var->data.name,\n                      var->data.complex ? \" (real part)\" : \"\",\n                      var->data.nRows,\n                      var->data.nCols,\n                      (unsigned long)  var->data.elSize,\n                      (double)nRows*nCols*elSize,\n                      (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n        exit(1);\n    }\n    var->data.re = tmp;\n\n    if (var->data.complex) {\n        tmp = realloc(var->data.im, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s (complex part)\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->data.name,\n                          var->data.nRows,\n                          var->data.nCols,\n                          (unsigned long)  var->data.elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n        var->data.im = tmp;\n    }\n    var->data.nRows = nRows;\n\n    /* Also reallocate memory for \"valueDimensions\" \n       when logging the variable-size signal\n    */\n    if(isVarDims){\n        int_T k;\n        \n        nCols = var->valDims->nCols;\n        nRows = var->valDims->nRows + DEFAULT_BUFFER_SIZE;\n        elSize = sizeof(real_T);\n        tmp = realloc(var->valDims->dimsData, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->valDims->name,\n                          var->valDims->nRows,\n                          var->valDims->nCols,\n                          (unsigned long)  elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n\n        /*\n         * valueDimensions data is stored in array format and must be\n         * adjusted after reallocation (see also rt_FixupLogVar())\n         *\n         * Example: maxRows = 4; nRows = 4; nDims = 3;\n         * Before realloc of the logVar, the locations of data are as below:\n         * (x, y, z -- useful data / o -- junk, don't care)\n         * a[0] = x    a[4] = y    a[8] = z\n         * a[1] = x    a[5] = y    a[9] = z\n         * a[2] = x    a[6] = y    a[10]= z\n         * a[3] = x    a[7] = y    a[11]= z\n         *\n         * After realloc of the logVar (suppose 2 extra rows are added),\n         * the locations of data are as below:\n         * a[0] = x    a[6] = y    a[12]= o\n         * a[1] = x    a[7] = y    a[13]= o\n         * a[2] = x    a[8] = z    a[14]= o\n         * a[3] = x    a[9] = z    a[15]= o\n         * a[4] = y    a[10]= z    a[16]= o\n         * a[5] = y    a[11]= z    a[17]= o\n         *\n         * The data must be adjusted as below:\n         * a[0] = x    a[6] = y    a[12]= z\n         * a[1] = x    a[7] = y    a[13]= z\n         * a[2] = x    a[8] = y    a[14]= z\n         * a[3] = x    a[9] = y    a[15]= z\n         * a[4] = o    a[10]= o    a[16]= o\n         * a[5] = o    a[11]= o    a[17]= o\n         */\n        for(k = var->data.nDims-1; k > 0; k--){\n            (void) memcpy((real_T*)tmp + k*nRows, \n                          (real_T*)tmp + k*var->valDims->nRows,\n                          elSize * var->valDims->nRows);\n        }\n\n        var->valDims->dimsData = tmp;\n        var->valDims->nRows = nRows;\n    }\n\n} /* end rt_ReallocLogVar */\n\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs);\n                                             \n/* Function: rt_UpdateLogVarWithDiscontinuousData ==============================\n * Abstract:\n *      Log one row of the LogVar with data that is not contiguous.\n */\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs)\n{\n    size_t elSize = 0;\n    size_t offset = 0;\n    int    segIdx = 0;\n\n    if (++var->numHits % var->decimation) return(NULL);\n    var->numHits = 0;\n\n    /*\n     * Reallocate or wrap the LogVar\n     */\n    if (var->rowIdx == var->data.nRows) {\n        if (var->okayToRealloc == 1) {\n            rt_ReallocLogVar(var, false);\n        } else {\n            /* Circular buffer */\n            var->rowIdx = 0;\n            ++(var->wrapped); /* increment the wrap around counter */\n        }\n    }\n\n    /* This function is only used to log states, there's no var-dims issue. */\n    elSize = var->data.elSize;\n    offset = (size_t)(elSize * var->rowIdx * var->data.nCols);\n\n    if (var->data.complex) {\n        char_T *dstRe = (char_T*)(var->data.re) + offset;\n        char_T *dstIm = (char_T*)(var->data.im) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            int_T         nEl  = segmentLengths[segIdx];\n            char_T *src        = (char_T *)data[segIdx];\n            int_T         el;\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(elSize * nEl * 2);\n                preprocessingPtr(src, (void *)data[segIdx]);\n            }\n\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);\n            }\n            else {\n                for (el = 0; el < nEl; el++) {\n                    (void)memcpy(dstRe, src, elSize);\n                    dstRe += elSize;   src += elSize;\n                    (void)memcpy(dstIm, src, elSize);\n                    dstIm += elSize;   src += elSize;\n                }\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    } else {\n        char_T *dst = (char_T*)(var->data.re) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            size_t      segSize = elSize*segmentLengths[segIdx];\n            char_T *src         = (void *) data[segIdx];\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(segSize);\n                preprocessingPtr(src, data[segIdx]);\n            }\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);            }\n            else {\n                (void)memcpy(dst, src, segSize);\n                dst += segSize;\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    }\n\n    ++var->rowIdx;\n    return(NULL);\n\n} /* end rt_UpdateLogVarWithDiscontinuousData */\n\n\n/*==================*\n * Visible routines *\n *==================*/\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_CreateLogVarWithConvert ========================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVarWithConvert(\n    RTWLogInfo        *li,\n    const real_T      startTime,\n    const real_T      finalTime,\n    const real_T      inStepSize,\n    const char_T      **errStatus,\n    const char_T      *varName,\n    BuiltInDTypeId    inpDataTypeID,\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    int_T             logical,\n    int_T             complex,\n    int_T             frameData,\n    int_T             nCols,\n    int_T             nDims,\n    const int_T       *dims,\n    LogValDimsStat    logValDimsStat,\n    void              **currSigDims,\n    int_T             *currSigDimsSize,\n    int_T             maxRows,\n    int_T             decimation,\n    real_T            sampleTime,\n    int_T             appendToLogVarsList)\n{\n    int_T          usingDefaultBufSize = 0;\n#ifdef NO_LOGGING_REALLOC\n    int_T          okayToRealloc       = 0;\n#else\n    int_T          okayToRealloc       = 1;\n#endif\n    LogVar         *var                = NULL;\n    /*inpDataTypeID is the rt_LoggedOutputDataTypeId*/\n    BuiltInDTypeId dTypeID             = (BuiltInDTypeId)inpDataTypeID; \n    size_t         elementSize         = rt_GetSizeofDataType(dTypeID);\n    int_T          frameSize;\n    int_T          nRows;\n    int_T          nColumns;\n\n    /*===================================================================*\n     * Determine the frame size if the data is frame based               *\n     *===================================================================*/\n    frameSize = frameData ? dims[0] : 1;\n\n    /*===================================================================*\n     * Calculate maximum number of rows needed in the buffer             *\n     *===================================================================*/\n\n    if (finalTime > startTime && finalTime != rtInf) {\n        real_T nPoints;            /* Tfinal is finite  ===>  nRows can be  */\n        real_T stepSize;           /* computed since the StepSize is fixed  */\n\n        if (sampleTime == -2.0) {  /* The signal being logged is constant,  *\n                                    * Hence, only one data point is logged. */\n            stepSize = finalTime;\n        } else if (sampleTime == -1.0 || sampleTime == 0.0) {\n                                /* Signal being logged is either inside a    *\n                                 * triggered sub-system or it is continuous. */\n            stepSize = inStepSize;\n        } else {                /* Discrete signal */\n            stepSize = sampleTime;\n        }\n\n        if (stepSize == 0.0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {\n            nPoints = 1.0 + floor((finalTime-startTime)/stepSize);\n\n            /*\n             * Add one more data point if needed.\n             */\n            if ( stepSize*(nPoints-1.0) < (finalTime-startTime) ) {\n                nPoints += 1.0;\n            }\n\n            /*\n             * Actual number of points to log = nPoints * size of\n             * each frame if data is frame-based\n             */\n            nPoints = frameData ? (nPoints * frameSize) : nPoints;\n\n            nPoints /= decimation;\n            if (nPoints != floor(nPoints)) {\n                nPoints += 1.0;\n            }\n            nRows = (nPoints <= INT_MAX) ? ((int_T) nPoints) : INT_MAX;\n        }\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (finalTime == startTime) {\n        /*\n         * Number of rows to log is equal to 1 if not frame-based and\n         * equal to frame size if frame-based\n         */\n        nRows = frameData ? frameSize : 1;\n\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (maxRows > 0) {     /* maxRows is specified => nRows=maxRows  */\n        nRows = maxRows;\n        okayToRealloc = 0;\n    } else {\n\n        if (inStepSize == 0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {                    /* Use a default value for nRows          */\n            usingDefaultBufSize = 1;\n            nRows = DEFAULT_BUFFER_SIZE;\n            okayToRealloc = 0;  /* No realloc with infinite stop time */\n            (void)fprintf(stdout, \"*** Using a default buffer of size %d for \"\n                          \"logging variable %s\\n\", nRows, varName);\n        }\n    }\n\n    /*\n     * Figure out the number of columns that the log variable should have.\n     * If the data is not frame based, then number of columns should equal\n     * nCols that is provided as input to the function. If the data is\n     * frame-based, then the number of columns should be equal to the\n     * number of channels = nCols/frameSize = dims[1];\n     */\n    nColumns = frameData ? dims[1] : nCols;\n\n    /*\n     * Error out if the size of the circular buffer is absurdly large, this\n     * error message is more informative than the one we get when we try to\n     * malloc this many number of bytes in one fell swoop.\n     */\n    {\n        double tmpDbl = ((double)elementSize)*((double)nRows)*\n                                              ((double)nColumns);\n\n        if (tmpDbl >= UINT_MAX) {\n            (void)fprintf(stderr,\n                          \"\\n*** Memory required to log variable '%s' is too\"\n                          \"\\n    big. Use the 'Limit rows to last:' and (or)\"\n                          \"\\n    'Decimation:' options to reduce the required\"\n                          \"\\n    memory size.\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Required  = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long)\n                          elementSize, tmpDbl);\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* Allocate memory for the log variable */\n    if ( (var = calloc(1, sizeof(LogVar))) == NULL ) {\n        (void)fprintf(stderr, \"*** Error allocating memory for logging %s\\n\",\n                      varName);\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer (real part) */\n    if ( (var->data.re = malloc(nRows*nColumns*elementSize)) == NULL ) {\n        (void)fprintf(stderr,\n                      \"*** Error allocating memory for the circular buffer\\n\");\n        (void)fprintf(stderr, \"*** Details:\\n\"\n                      \"       varName         = %s\\n\"\n                      \"       nRows           = %d\\n\"\n                      \"       nCols           = %d\\n\"\n                      \"       elementSize     = %lu\\n\"\n                      \"       Bytes Requested = %.16g\\n\\n\",\n                      varName, nRows, nColumns, (unsigned long) elementSize,\n                      ((double)elementSize)*((double)nRows)*((double)nColumns));\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer for the imaginary part */\n    if (complex) {\n        if ( (var->data.im = malloc(nRows*nColumns*elementSize)) == NULL ) {\n            (void)fprintf(stderr,\n                          \"*** Error allocating memory for the circular buffer \"\n                          \"for logging the imaginary part of %s\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Requested = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long) elementSize,\n                          ((double)elementSize)*((double)nRows)*\n                                                 ((double)nColumns));\n            goto ERROR_EXIT;\n        }\n    }\n    /*\n     * Initialize the fields in LogVar structure.\n     */\n    if (appendToLogVarsList) {\n        rt_LoadModifiedLogVarName(li,varName,var->data.name);\n    } else {\n        var->data.name[mxMAXNAM-1] = '\\0';\n        (void)strncpy(var->data.name,varName,mxMAXNAM-1);\n    }\n    var->data.nCols           = nColumns;\n    var->data.nRows           = nRows;\n\n    var->data.nDims           = frameData ? 1 : nDims;\n    if (var->data.nDims > 2) {\n        var->data.dims = (int_T*)malloc(sizeof(int_T)*var->data.nDims);\n    } else {\n        var->data.dims = var->data._dims;\n    }\n    if (frameData) {\n        var->data.dims[0] = nColumns;\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        (void)memcpy(var->data.dims, dims, (size_t)(nDims*sizeof(int_T)));\n    }\n\n    var->data.dTypeID         = dTypeID;\n    var->data.elSize          = elementSize;\n\n    var->data.dataTypeConvertInfo = rt_GetDataTypeConvertInfo(\n        pDataTypeConvertInfo, dTypeID);\n\n    var->data.mxID            = rt_GetMxIdFromDTypeId(dTypeID);\n    /* over-ride logical bit if data type is boolean */\n    logical = dTypeID == SS_BOOLEAN ? 1 : 0;\n    var->data.logical         = (logical)   ? matLOGICAL_BIT : 0x0;\n    var->data.complex         = (complex)   ? matCOMPLEX_BIT : 0x0;\n    var->data.frameData       = frameData;\n    var->data.frameSize       = (frameData) ? frameSize : 1;\n\n    /* fill up valDims field */\n    if(logValDimsStat == NO_LOGVALDIMS){\n        /* All signals are fixed-size, no need to log valueDimensions field */\n        var->valDims     = NULL;\n        /* Set these pointers to NULLs in this case */\n        var->coords      = NULL;\n        var->strides     = NULL;\n        var->currStrides = NULL;\n    }\n    else{\n        if ( (var->valDims = calloc(1, sizeof(ValDimsData))) == NULL ) {\n            goto ERROR_EXIT;\n        }\n\n        (void)memcpy(var->valDims->name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n\n        if (logValDimsStat == LOGVALDIMS_EMPTYMX) {\n            /* At least one signal is variable-size, \n               but the current signal is fixed-size. \n               Therefore, create a dummy MatrixData to write out valueDimensions \n               as an empty matrix. \n            */\n            var->valDims->nRows = 0;\n            var->valDims->nCols = 0;\n            var->valDims->currSigDims = NULL;\n            var->valDims->currSigDimsSize = NULL;\n            var->valDims->dimsData = NULL;\n            /* Set these pointers to NULLs in this case */\n            var->coords      = NULL;\n            var->strides     = NULL;\n            var->currStrides = NULL;\n        } else { /* The current signal is a variable-size signal. */\n            /* The \"valueDimensions\" must be double, so re-assign element size */\n            elementSize = sizeof(real_T);\n\n            /* When signals are frame-based, 'valueDimensions' has 1 column */\n            if(frameData){\n                /* When signal is frame-based, the first dimension is always fixed, \n                   so we only need to record the second dimension.\n                   e.g. Two frame-based signals [10x4] and [10x3], \n                   'valueDimensions' and 'currSigDims'\n                   only record 4 or 3.\n                */\n                nColumns = 1;\n                var->valDims->currSigDims = (void**) (currSigDims + 1);\n                var->valDims->currSigDimsSize = (int_T*) (currSigDimsSize + 1);\n            } else { /* non-frame based */\n                nColumns = nDims;\n                var->valDims->currSigDims = (void**) currSigDims;\n                var->valDims->currSigDimsSize = (int_T*) currSigDimsSize;\n            }\n            \n            /* Allocate memory for the circular buffer */\n            if ( (var->valDims->dimsData = malloc(nRows*nColumns*elementSize)) == NULL ) {\n                (void)fprintf(stderr,\n                              \"*** Error allocating memory for the circular buffer\\n\");\n                (void)fprintf(stderr, \"*** Details:\\n\"\n                              \"       varName         = %s\\n\"\n                              \"       nRows           = %d\\n\"\n                              \"       nCols           = %d\\n\"\n                              \"       elementSize     = %lu\\n\"\n                              \"       Bytes Requested = %.16g\\n\\n\",\n                              var->valDims->name, nRows, nColumns, (unsigned long) elementSize,\n                              ((double)elementSize)*((double)nRows)*((double)nColumns));\n                goto ERROR_EXIT;\n            }\n            var->valDims->nRows = nRows;\n            var->valDims->nCols = nColumns;\n\n            /* Allocate memory for these dynamic arrays */\n            {\n                size_t nbytes = var->data.nDims*sizeof(int_T);\n                if( ((var->coords = calloc(nbytes, 1)) == NULL)\n                    ||((var->strides = calloc(nbytes, 1)) == NULL)\n                    ||((var->currStrides = calloc(nbytes, 1)) == NULL) )\n                    goto ERROR_EXIT;\n            }\n        }\n    }\n\n    var->rowIdx               = 0;\n    var->wrapped              = 0;\n    var->nDataPoints          = 0;\n    var->usingDefaultBufSize  = usingDefaultBufSize;\n    var->okayToRealloc        = okayToRealloc;\n    var->decimation           = decimation;\n    var->numHits              = -1;  /* so first point gets logged */\n\n    /* Add this log var to list in log info, if necessary */\n    if (appendToLogVarsList) {\n        LogInfo *logInfo = (LogInfo*) rtliGetLogInfo(li);\n        LogVar  *varList = logInfo->logVarsList;\n\n        if (varList != NULL) {\n            while (varList->next != NULL) {\n                varList = varList->next;\n            }\n            varList->next = var;\n        } else {\n            logInfo->logVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    \n    *errStatus = rtMemAllocError;\n    rt_DestroyLogVar(var);\n    return(NULL);\n\n} /* end rt_CreateLogVarWithConvert */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateLogVar ===================================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVar(RTWLogInfo        *li,\n                               const real_T      startTime,\n                               const real_T      finalTime,\n                               const real_T      inStepSize,\n                               const char_T      **errStatus,\n                               const char_T      *varName,\n                               BuiltInDTypeId    inpDataTypeID,\n                               int_T             logical,\n                               int_T             complex,\n                               int_T             frameData,\n                               int_T             nCols,\n                               int_T             nDims,\n                               const int_T       *dims,\n                               LogValDimsStat    logValDimsStat,\n                               void              **currSigDims,\n                               int_T             *currSigDimsSize,\n                               int_T             maxRows,\n                               int_T             decimation,\n                               real_T            sampleTime,\n                               int_T             appendToLogVarsList)\n{\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo = NULL;\n\n    return rt_CreateLogVarWithConvert(li,\n                                      startTime,\n                                      finalTime,\n                                      inStepSize,\n                                      errStatus,\n                                      varName,\n                                      inpDataTypeID,\n                                      pDataTypeConvertInfo,\n                                      logical,\n                                      complex,\n                                      frameData,\n                                      nCols,\n                                      nDims,\n                                      dims,\n                                      logValDimsStat,\n                                      currSigDims,\n                                      currSigDimsSize,\n                                      maxRows,\n                                      decimation,\n                                      sampleTime,\n                                      appendToLogVarsList);\n\n} /* end rt_CreateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateStructLogVar =============================================\n * Abstract:\n *\tCreate a logging variable in the structure format.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nStructLogVar *rt_CreateStructLogVar(RTWLogInfo              *li,\n                                           const real_T            startTime,\n                                           const real_T            finalTime,\n                                           const real_T            inStepSize,\n                                           const char_T            **errStatus,\n                                           const char_T            *varName,\n                                           boolean_T               logTime,\n                                           int_T                   maxRows,\n                                           int_T                   decimation,\n                                           real_T                  sampleTime,\n                                           const RTWLogSignalInfo  *sigInfo,\n                                           const char_T            *blockName)\n{\n\n    return( local_CreateStructLogVar(li,\n                                     startTime,\n                                     finalTime,\n                                     inStepSize,\n                                     errStatus,\n                                     varName,\n                                     logTime,\n                                     maxRows,\n                                     decimation,\n                                     sampleTime,\n                                     sigInfo,\n                                     blockName));\n\n} /* end rt_CreateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_StartDataLoggingWithStartTime ==================================\n * Abstract:\n *      Initialize data logging info based upon the following settings cached\n *      in the RTWLogging data structure of the SimStruct.\n *\n * Return value is:\n *\t== NULL  => success\n *\t!= NULL  => failure (the return value is a pointer that points to the\n *                           error message, which is also set in the simstruct)\n */\nconst char_T *rt_StartDataLoggingWithStartTime(RTWLogInfo   *li,\n                                                      const real_T startTime,\n                                                      const real_T finalTime,\n                                                      const real_T stepSize,\n                                                      const char_T **errStatus)\n{\n    const char_T   *varName;\n    LogInfo        *logInfo;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ((logInfo=calloc(1,sizeof(LogInfo))) == NULL) {\n        *errStatus = rtMemAllocError;\n        goto ERROR_EXIT;\n    }\n    rtliSetLogInfo(li, (void*)logInfo);\n\n    /* time */\n    varName = rtliGetLogT(li);\n    if (varName[0] != '\\0') {\n        int_T dims = 1;\n        logInfo->t = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                stepSize, errStatus,\n                                                varName,SS_DOUBLE,\n                                                NULL,\n                                                0,0,0,1,1,\n                                                &dims, NO_LOGVALDIMS, NULL, NULL,\n                                                maxRows,decimation,\n                                                sampleTime,1);\n        if (logInfo->t == NULL) goto ERROR_EXIT;\n    }\n\n    /* states */\n    if ( rtliGetLogX(li)[0] != '\\0' ||  rtliGetLogXFinal(li)[0] != '\\0' ) {\n        const RTWLogSignalInfo  *xInfo = rtliGetLogXSignalInfo(li);\n\n        if (logFormat == 0) {                                /* Matrix Format */\n            int            numCols;\n            int            nDims;\n            const int      *dims;\n            BuiltInDTypeId dataType;\n            int            isComplex;\n            int_T          sIdx;\n\n            const RTWLogDataTypeConvert *pDTConvInfo;\n\n            numCols = xInfo[0].numCols ? xInfo[0].numCols[0] : 0;\n            for (sIdx = 1; sIdx < xInfo[0].numSignals; sIdx++) {\n                numCols += xInfo[0].numCols[sIdx];\n            }\n            /* If we have only one \"matrix\" state, we can log as a matrix */\n            if (xInfo[0].numSignals == 1) {\n                nDims     = xInfo[0].numDims ? xInfo[0].numDims[0] : 1;\n                dims      = xInfo[0].dims;\n            } else {\n                nDims     = 1;\n                dims      = &numCols;\n            }\n            dataType  = xInfo[0].dataTypes ? xInfo[0].dataTypes[0] : 0;\n            isComplex = xInfo[0].complexSignals ? xInfo[0].complexSignals[0] : 0;\n\n            pDTConvInfo = xInfo[0].dataTypeConvert;\n\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                        stepSize, errStatus,\n                                                        rtliGetLogX(li),dataType,\n                                                        pDTConvInfo,\n                                                        0,\n                                                        isComplex,0,numCols,nDims,dims,\n                                                        NO_LOGVALDIMS, NULL, NULL,\n                                                        maxRows,decimation,sampleTime,1);\n                if (logInfo->x == NULL)  goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                             stepSize, errStatus,\n                                                             rtliGetLogXFinal(li),dataType,\n                                                             pDTConvInfo,\n                                                             0,isComplex,0,numCols,nDims,\n                                                             dims, NO_LOGVALDIMS, NULL, \n                                                             NULL, 1,decimation,\n                                                             sampleTime,1);\n                if (logInfo->xFinal == NULL)  goto ERROR_EXIT;\n            }\n        } else {                                          /* Structure Format */\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = local_CreateStructLogVar(li, startTime, finalTime,\n                                                      stepSize, errStatus,\n                                                      rtliGetLogX(li), logTime,\n                                                      maxRows, decimation,\n                                                      sampleTime, xInfo, NULL);\n                if (logInfo->x == NULL) goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = local_CreateStructLogVar(li, startTime, finalTime,\n                                                           stepSize, errStatus,\n                                                           rtliGetLogXFinal(li),\n                                                           logTime,1,decimation,\n                                                           sampleTime,xInfo,NULL);\n                if (logInfo->xFinal == NULL) goto ERROR_EXIT;\n            }\n        }\n    }\n\n    /* outputs */\n    *errStatus = rt_StartDataLoggingForOutput(li,startTime,finalTime,\n                                              stepSize,errStatus);\n    if (*errStatus != NULL)  goto ERROR_EXIT;\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) {\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo);\n        rtliSetLogInfo(li,NULL);\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingWithStartTime */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StartDataLogging ===============================================\n * Abstract:\n */\nconst char_T *rt_StartDataLogging(RTWLogInfo   *li,\n                                         const real_T finalTime,\n                                         const real_T stepSize,\n                                         const char_T **errStatus)\n{\n    return rt_StartDataLoggingWithStartTime(li,\n                                            0.0,\n                                            finalTime,\n                                            stepSize,\n                                            errStatus);\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_UpdateLogVar ===================================================\n * Abstract:\n *\tCalled to log data for a log variable.\n */\nvoid rt_UpdateLogVar(LogVar *var, const void *data, boolean_T isVarDims)\n{\n    size_t        elSize    = var->data.elSize;\n    const  char_T *cData    = data;\n    const  int_T  frameData = var->data.frameData;\n    const  int_T  frameSize = frameData ? (var->data.frameSize) : 1;\n    const  int_T  logWidth  = var->data.nCols;\n    BuiltInDTypeId dTypeID  = var->data.dTypeID;\n\n    size_t offset        = 0;\n    char_T *currRealRow  = NULL;\n    char_T *currImagRow  = NULL;\n    int_T  pointSize     = (int_T)((var->data.complex) ? rt_GetSizeofComplexType(dTypeID) : elSize);\n\n    int    i, j, k;\n\n    /* The following variables will be used for \n       logging variable-size signals */\n    const  int_T  nDims = var->data.nDims;\n    const  int_T  *dims = var->data.dims;\n    const  void   * const *currDimsPtr = NULL;\n    const  int_T  *currDimsSizePtr = NULL;\n\n    /* The following variables will be used for \n       logging \"valueDimensions\" field */\n    size_t offset_valDims   = 0;\n    char_T *currValDimsRow  = NULL;\n    size_t elSize_valDims   = sizeof(real_T);\n    real_T currentSigDims   = 0;\n    int_T  nRows_valDims    = 0;\n    int_T  logWidth_valDims = 0;\n\n    for (i = 0; i < frameSize; i++) {\n        if (++var->numHits % var->decimation) continue;\n        var->numHits = 0;\n\n        if (var->rowIdx == var->data.nRows) {\n            if (var->okayToRealloc == 1) {\n                rt_ReallocLogVar(var, isVarDims);\n            } else {\n                /* Circular buffer */\n                var->rowIdx = 0;\n                ++(var->wrapped); /* increment the wrap around counter */\n            }\n        }\n\n        if(isVarDims){\n            currDimsPtr = (const void * const *) var->valDims->currSigDims;\n            currDimsSizePtr = (const int_T*) var->valDims->currSigDimsSize;\n            logWidth_valDims = frameData ? 1 : var->valDims->nCols;\n            nRows_valDims = var->valDims->nRows;\n\n            var->strides[0] = 1;\n            var->currStrides[0] = 1;\n\n            for (k = 1; k < nDims; k++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[k-1]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                }\n                var->strides[k] = var->strides[k-1] * dims[k-1];\n                var->currStrides[k] = var->currStrides[k-1] * currDimsVal;\n            }\n        }\n\n        offset       = (size_t)(elSize * var->rowIdx * logWidth);\n        currRealRow  = ((char_T*) (var->data.re)) + offset;\n        currImagRow  = (var->data.complex) ?\n                       ((char_T*) (var->data.im)) + offset :  NULL;\n\n        /* update logging data */\n        for (j = 0; j < logWidth; j++) {\n\n            boolean_T inRange = true;\n            int idx = j;\n\n            /* Check whether the currently logged value is in range or not.\n               For fixed-size signal logging, always inRange = true; idx = j;\n               For variable-size signal logging, use strides, coordinates\n               and current strides to decide whether the currently logged\n               data is in range or not and its location in the logging \n               matrix.\n             */\n            if(isVarDims){\n                int rem = j;\n                idx = 0;\n                for(k = nDims-1; k>=0; k--){\n                    int32_T currDimsVal=0;\n                    switch (currDimsSizePtr[k]) {\n                      case 1:\n                        currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+k));\n                        break;\n                      case 2:\n                        currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+k));\n                        break;\n                      case 4:\n                        currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+k));\n                        break;\n                    }\n                    var->coords[k] = rem / var->strides[k];\n                    if( var->coords[k] >= currDimsVal ){\n                        inRange = false;\n                        break;\n                    }\n                    rem = rem - var->coords[k] * var->strides[k];\n                }\n                if(inRange){\n                    idx = var->coords[0];\n                    for (k = 1; k < nDims; k++){\n                        idx += var->coords[k] * var->currStrides[k];\n                    }\n                }\n            }\n            \n            if (!var->data.dataTypeConvertInfo.conversionNeeded) {\n                /* NO  conversion needed\n                 */ \n                if (inRange) {\n                    /* If in range, fill in data */\n                    const char *cDataPoint = cData + (i+frameSize*idx) * pointSize;\n\n                    (void) memcpy(currRealRow, cDataPoint, elSize);\n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        (void) memcpy(currImagRow, cDataPoint + pointSize/2, elSize);\n                        currImagRow += elSize;\n                    }\n                } else {\n                    /* If out of range, fill in NaN or 0:\n                       1) For bool, int32, uint32, int16, uint16, etc,\n                          memset to zeros;\n                       2) For fixed-point data type, NaN conversion is not\n                          allowed, memset to zeros.\n                    */\n                    if (dTypeID == SS_DOUBLE) {\n                       ((real_T*)(currRealRow))[0] = rtNaN;\n                    } else if (dTypeID == SS_SINGLE){\n                        ((real32_T*)(currRealRow))[0] = rtNaNF;\n                    } else {\n                        (void) memset(currRealRow, 0, elSize);\n                    }\n                    \n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        /* For imaginary part, fill in 0 */\n                        (void) memset(currImagRow, 0, elSize);\n                        currImagRow += elSize;\n                    }\n                }\n            }\n            else\n            {\n                /* YES conversion needed\n                 */ \n                DTypeId dataTypeIdOriginal = \n                    var->data.dataTypeConvertInfo.dataTypeIdOriginal;\n                int_T DpSize = (int_T)((var->data.complex) ? \n                                       rt_GetSizeofComplexType(dataTypeIdOriginal) : \n                                       rt_GetSizeofDataType(dataTypeIdOriginal));\n\n                DTypeId dataTypeIdLoggingTo = \n                    var->data.dataTypeConvertInfo.dataTypeIdLoggingTo;\n\n                int bitsPerChunk = var->data.dataTypeConvertInfo.bitsPerChunk;\n                int numOfChunk =  var->data.dataTypeConvertInfo.numOfChunk;\n                unsigned int isSigned = var->data.dataTypeConvertInfo.isSigned;\n\n                double fracSlope = var->data.dataTypeConvertInfo.fracSlope;\n                int    fixedExp  = var->data.dataTypeConvertInfo.fixedExp;\n                double bias      = var->data.dataTypeConvertInfo.bias;\n\n                double curRealValue = -0.12345678987654;\n                double curImagValue = -0.12345678987654;\n\n                int_T adjIndexIfComplex = (var->data.complex) ? 2 : 1;\n\n                if(inRange){\n                    if(numOfChunk > 1)\n                    {\n                        /* For multiword */\n                        const char *pInData = (const char *)(cData);\n                        int dtSize = bitsPerChunk*numOfChunk/8;\n                        pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                        \n                        curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                       isSigned, fracSlope, fixedExp, bias);\n                        if (var->data.complex) {\n                            curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                           isSigned, fracSlope, fixedExp, bias);\n                        }\n                    }\n                    else\n                    {\n                        /* if in range, fill in data that is converted first */\n                        switch ( dataTypeIdOriginal )\n                        {\n                          case SS_DOUBLE:\n                            {\n                                const real_T *pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_SINGLE:\n                            {\n                                const real32_T *pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT8:\n                            {\n                                const int8_T *pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT8:\n                            {\n                                const uint8_T *pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT16:\n                            {\n                                const int16_T *pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT16:\n                            {\n                                const uint16_T *pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT32:\n                            {\n                                const int32_T *pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT32:\n                            {\n                                const uint32_T *pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_BOOLEAN:\n                            {\n                                const boolean_T *pInData = ((const boolean_T *)(cData));\n                                \n                                pInData += (i+frameSize*idx) * adjIndexIfComplex;\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          default: \n                            {\n                                /* For biglong */\n                                const char *pInData = (const char *)(cData);\n                                int dtSize = bitsPerChunk*numOfChunk/8;\n                                pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                                \n                                curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                               isSigned, fracSlope, fixedExp, bias);\n                                if (var->data.complex) {\n                                    curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                                   isSigned, fracSlope, fixedExp, bias);\n                                }\n                            }\n                            break;\n                        } /* -- end of switch -- */\n                    }\n                } else {\n                    /* if out of range, just fill NaN or 0 */\n                    if(dTypeID == SS_DOUBLE || dTypeID == SS_SINGLE){\n                        /* vijay 4/11/2013: DO NOT CALL ldexp() with NaN below as it causes \n                         * lcc-win64 to generate inf instead of NaN as output. \n                         * Just use rtNaN directly */\n                        curRealValue = rtNaN;\n                    }\n                    else{\n                        curRealValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                    if (var->data.complex) {\n                        /* fill 0 in imaginary part*/\n                        curImagValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                }\n\n                switch ( dataTypeIdLoggingTo )\n                {\n                  case SS_DOUBLE:\n                    {\n                        *((real_T *)currRealRow) = (real_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real_T *)currImagRow) = (real_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_SINGLE:\n                    {\n                        *((real32_T *)currRealRow) = (real32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real32_T *)currImagRow) = (real32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT8:\n                    {\n                        *((int8_T *)currRealRow) = (int8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int8_T *)currImagRow) = (int8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT8:\n                    {\n                        *((uint8_T *)currRealRow) = (uint8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint8_T *)currImagRow) = (uint8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT16:\n                    {\n                        *((int16_T *)currRealRow) = (int16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int16_T *)currImagRow) = (int16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT16:\n                    {\n                        *((uint16_T *)currRealRow) = (uint16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint16_T *)currImagRow) = (uint16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT32:\n                    {\n                        *((int32_T *)currRealRow) = (int32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int32_T *)currImagRow) = (int32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT32:\n                    {\n                        *((uint32_T *)currRealRow) = (uint32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint32_T *)currImagRow) = (uint32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_BOOLEAN:\n                    {\n                        *((boolean_T *)currRealRow) = (boolean_T)(curRealValue != 0.0);\n\n                        if (var->data.complex) {\n\n                            *((boolean_T *)currImagRow) = (boolean_T)(curImagValue != 0.0);\n                        }\n                    }\n                    break;\n                } /* -- end of switch -- */\n\n                currRealRow += elSize;\n                if (var->data.complex) {\n                    currImagRow += elSize;\n                }\n            }\n        }\n\n        if(isVarDims){ /* update \"valueDimensions\" field */\n            for(j = 0; j < logWidth_valDims; j ++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[j]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+j));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+j));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+j));\n                    break;\n                }\n                offset_valDims  = (size_t)(elSize_valDims *( var->rowIdx + nRows_valDims * j));\n                currValDimsRow  = ((char_T*) (var->valDims->dimsData)) + offset_valDims;\n\n                /* convert int_T to real_T */\n                currentSigDims = (real_T) currDimsVal;\n                (void) memcpy(currValDimsRow, &currentSigDims, elSize_valDims);\n                currValDimsRow += elSize_valDims;\n            }\n        }\n        \n        ++var->rowIdx;\n    }\n\n    return;\n\n} /* end rt_UpdateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n \n \n/* Function: rt_UpdateStructLogVar =============================================\n * Abstract:\n *      Called to log data for a structure log variable.\n */\nvoid rt_UpdateStructLogVar(StructLogVar *var, const real_T *t, const void *data)\n{\n    LogVar       *values = var->signals.values;\n    const char_T *signal = data;\n    boolean_T *isVarDims = var->signals.isVarDims;\n    int i = 0;\n\n    /* time */\n    if (var->logTime) {\n        rt_UpdateLogVar(var->time, t, false);\n    }\n\n    /* signals */\n    while (values) {\n        size_t elSz = values->data.elSize;\n\n        rt_UpdateLogVar(values, signal, isVarDims[i]);\n\n        if (values->data.complex) elSz *= 2;\n        signal += elSz * values->data.nCols;\n\n        values = values->next;\n        i++;\n    }\n\n} /* end rt_UpdateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * g1614989:Refactoring this function to accept number of elements\n *          instead of accepting signalInfo and index.\n */\nvoid* rt_getTempMemory(LogVar* var, int_T numEls);\n\nvoid* rt_getTempMemory(LogVar* var, int_T numEls)\n{\n    size_t elSize  = var->data.elSize;\n    size_t cmplxMult = var->data.complex ? 2 : 1;\n    /*\n     * g1689750: With multiword support for mat file logging in row major array layout, we need to allocate more space to\n     * store the data when the transpose operation is being performed. The additional space is required to store multiple\n     * chunks that each multi word contains.\n     */\n    size_t numOfChunks = var->data.dataTypeConvertInfo.conversionNeeded ? var->data.dataTypeConvertInfo.numOfChunk : 1;\n    void* tempMemory = malloc(elSize * numEls * cmplxMult * numOfChunks);\n    return tempMemory;\n}\n\n/*\n* g1614989:This function processes the signal data if a function pointer is available and then logs the data.\n*          If a function pointer is not present, signal data is logged without any processing.\n*          The idx parameter specifies which information from the SignalInfo to be used for processing and logging.\n*          When idx is -1, the provided signal info is to be used for processing and logging the data.\n*/\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    RTWPreprocessingFcnPtr preprocessingPtr = NULL;\n    int_T numEls = -1;\n    if (idx == -1) {\n        preprocessingPtr = *(signalInfo->preprocessingPtrs);\n        numEls = *(signalInfo->numCols);\n    }\n    else {\n        preprocessingPtr = signalInfo->preprocessingPtrs[idx];\n        numEls = signalInfo->numCols[idx];\n    }\n\n    if (preprocessingPtr != NULL) {\n        void* curData = rt_getTempMemory(val, numEls);\n        preprocessingPtr(curData, data);\n        rt_UpdateLogVar(val, curData, isVarDims);\n        free(curData);\n    }\n    else {\n        rt_UpdateLogVar(val, data, isVarDims);\n    }\n}\n\n/*\n* g1614989:This function is called when each signal has a specific RTWLogSignalInfo structure defined.\n*/\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    rt_preProcessAndLogDataWithIndex(&signalInfo, -1, val, data, isVarDims);\n}\n \n/* Function: rt_UpdateTXYLogVars ===============================================\n * Abstract:\n *\tUpdate the xFinal,T,X,Y variables that are being logged.\n */\nconst char_T *rt_UpdateTXYLogVars(RTWLogInfo *li, time_T *tPtr)\n{\n    return rt_UpdateTXXFYLogVars(li, tPtr, true);\n}\n \n/* Function: rt_UpdateTXXFYLogVars =============================================\n * Abstract:\n *\tUpdate xFinal and/or the T,X,Y variables that are being logged\n */\nconst char_T *rt_UpdateTXXFYLogVars(RTWLogInfo *li, time_T *tPtr, boolean_T updateTXY)\n{\n    LogInfo *logInfo     = rtliGetLogInfo(li);\n    int_T   matrixFormat = (rtliGetLogFormat(li) == 0);\n    const RTWLogSignalInfo* yInfo = rtliGetLogYSignalInfo(li);\n    const RTWLogSignalInfo* xInfo = rtliGetLogXSignalInfo(li);\n\n    /* time */\n    if (logInfo->t != NULL && updateTXY) {\n        rt_UpdateLogVar(logInfo->t, tPtr, false);\n    }\n\n    if (matrixFormat) {                                      /* MATRIX_FORMAT */\n        /* states */\n        if (logInfo->x != NULL || logInfo->xFinal != NULL) {\n            int8_T**               segAddr     = _rtliGetLogXSignalPtrs(li);\n            const int_T            *segLengths = xInfo->numCols;\n            int_T                  nSegments   = xInfo->numSignals;\n            RTWPreprocessingFcnPtr* preprocessingPtrs = xInfo->preprocessingPtrs;\n\n            if (logInfo->x != NULL && updateTXY) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->x, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n            if (logInfo->xFinal != NULL) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->xFinal, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n        }\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            LogVar **var = (LogVar**) (logInfo->y);\n            int_T  ny    = logInfo->ny;\n            int_T  i;\n            int    yIdx;\n            LogSignalPtrsType data = rtliGetLogYSignalPtrs(li);\n\n            for (i = 0, yIdx = 0; i < ny; i++) {\n                if (data[i] != NULL) {\n                    /* \n                       When outputs are logged in Matrix format, \n                       no variable-size signal logging is allowed.\n                    */\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *          Function pointer is now identified by using \n                     *          Y Signal Info instead of iterating over pre-processing \n                     *          function pointers.\n                    */ \n                    rt_preProcessAndLogData(yInfo[yIdx], var[yIdx], data[i], false);\n                    yIdx++;\n                }\n            }\n        }\n    } else {                                              /* STRUCTURE_FORMAT */\n        /* states */\n        if (logInfo->x != NULL && updateTXY) {\n            int_T             i;\n            StructLogVar      *var = logInfo->x;\n            LogVar            *val = var->signals.values;\n            int_T             nsig = var->signals.numSignals;\n            LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n\n            /* time */\n            if (var->logTime) {\n                rt_UpdateLogVar(var->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            int_T             ny      = logInfo->ny;\n            LogSignalPtrsType data    = rtliGetLogYSignalPtrs(li);\n            StructLogVar      **var   = (StructLogVar**) (logInfo->y);\n\n            if (ny == 1) {\n                int_T  i;\n                int_T  dataIdx;\n                LogVar *val = var[0]->signals.values;\n                int_T  nsig = var[0]->signals.numSignals;\n                boolean_T   *isVarDims = var[0]->signals.isVarDims;\n\n                /* time */\n                if (var[0]->logTime) {\n                    rt_UpdateLogVar(var[0]->time, tPtr, false);\n                }\n\n                /* signals */\n                for (i = 0, dataIdx = 0; i < nsig; i++) {                    \n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogDataWithIndex(yInfo, i, val, data[dataIdx], isVarDims[i]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            } else {\n                int_T  i;\n                int_T  dataIdx;\n\n                for (i = 0, dataIdx = 0; i < ny && var[i] != NULL; i++) {\n                    LogVar *val = var[i]->signals.values;\n                    boolean_T   *isVarDims = var[i]->signals.isVarDims;\n\n                    /* time */\n                    if (var[i]->logTime) {\n                        rt_UpdateLogVar(var[i]->time, tPtr, false);\n                    }\n\n                    /* signals */\n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogData(yInfo[i], val, data[dataIdx], isVarDims[0]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            }\n        }\n        /* final state */\n        if (logInfo->xFinal != NULL) {\n            StructLogVar *xf  = logInfo->xFinal;\n            LogVar       *val = xf->signals.values;\n            int_T        nsig = xf->signals.numSignals;\n            int_T        i;\n\n            /* time */\n            if (xf->logTime) {\n                rt_UpdateLogVar(xf->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n    }\n    return(NULL);\n} /* end rt_UpdateTXXFYLogVars */\n\n\n#ifdef __cplusplus\n}\n#endif\n          \n\n          \n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLoggingImpl =======================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLoggingImpl(const char_T *file, RTWLogInfo *li, boolean_T isRaccel)\n{\n    FILE          *fptr;\n    LogInfo       *logInfo     = (LogInfo*) rtliGetLogInfo(li);\n    LogVar        *var         = logInfo->logVarsList;\n    StructLogVar  *svar        = logInfo->structLogVarsList;\n    /* At this time, verbose is only needed if running rapid accelerator\n     * simulations. */\n    int           verbose      = isRaccel ? 0: 1;\n\n    boolean_T     emptyFile    = 1; /* assume */\n    boolean_T     errFlag      = 0;\n    const char_T  *msg;\n\n    /*******************************\n     * Create MAT file with header *\n     *******************************/\n    if ((fptr=fopen(file,\"w+b\")) == NULL) {\n        (void)fprintf(stderr,\"*** Error opening %s\",file);\n        goto EXIT_POINT;\n    }\n    if (rt_WriteMat5FileHeader(fptr)) {\n        (void)fprintf(stderr,\"*** Error writing to %s\",file);\n        goto EXIT_POINT;\n    }\n\n    /**************************************************\n     * First log all the variables in the LogVar list *\n     **************************************************/\n    while (var != NULL) {\n        if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n            (void)fprintf(stderr,\"*** Error writing %s due to: %s\\n\",file,msg);\n            errFlag = 1;\n            break;\n        }\n        if (var->nDataPoints > 0 || isRaccel) {\n            MatItem item;\n\n            item.type   = matMATRIX;\n            item.nbytes = 0; /* not yet known */\n            item.data   = &(var->data);\n            if (rt_WriteItemToMatFile(fptr, &item, MATRIX_ITEM)) {\n                (void)fprintf(stderr,\"*** Error writing log variable %s to \"\n                              \"file %s\",var->data.name, file);\n                errFlag = 1;\n                break;\n            }\n            emptyFile = 0;\n        }\n        var = var->next;\n    }\n    /* free up some memory by destroying the log var list here */\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n\n    /*******************************************************\n     * Next log all the variables in the StructLogVar list *\n     *******************************************************/\n    while (svar != NULL) {\n        MatItem item;\n\n        if (svar->logTime) {\n            var = svar->time;\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n        }\n\n        var = svar->signals.values;\n        while (var) {\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n            var = var->next;\n        }\n\n        item.type   = matMATRIX;\n        item.nbytes = 0; /* not yet known */\n        item.data   = svar;\n\n        if (rt_WriteItemToMatFile(fptr, &item, STRUCT_LOG_VAR_ITEM)) {\n            (void)fprintf(stderr,\"*** Error writing structure log variable \"\n                          \"%s to file %s\",svar->name, file);\n            errFlag = 1;\n            break;\n        }\n        emptyFile = 0;\n\n        svar = svar->next;\n    }\n\n    /******************\n     * Close the file *\n     ******************/\n    (void)fclose(fptr);\n    if (emptyFile || errFlag) {\n        (void)remove(file);\n    } else {\n        if( verbose ) {\n            (void)printf(\"** created %s **\\n\\n\", file);\n        }\n    }\n\n EXIT_POINT:\n\n    /****************\n     * free logInfo *\n     ****************/\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n    rt_DestroyStructLogVar(logInfo->structLogVarsList);\n    logInfo->structLogVarsList = NULL;\n    FREE(logInfo->y);\n    logInfo->y = NULL;\n    FREE(logInfo);\n    rtliSetLogInfo(li,NULL);\n\n} /* end rt_StopDataLoggingImpl */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLogging ================================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLogging(const char_T *file, RTWLogInfo *li)\n{\n    rt_StopDataLoggingImpl(file,li,false);\n\n} /* end rt_StopDataLogging */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#else /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n#define rt_StartDataLogging(li, finalTime, stepSize, errStatus) NULL /* do nothing */\n#define rt_UpdateTXYLogVars(li, tPtr) NULL /* do nothing */\n#define rt_StopDataLogging(file, li) { (void(file)); } /* use file quiet unused macro warning */ /* do nothing */\n\n#endif /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n\n\n/* [eof] rt_logging.c */\n\n/* LocalWords:  Tfinal MAXNAM nonfinite DType PWS RSim Fixup logvar DDEFAULT th\n * LocalWords:  curr Realloc realloc inp biglong vijay ldexp TXY eof XFinal th\n * LocalWords:  TXXFY NULL typedefs ret polyspace NUL\n */\n"},{"name":"rt_logging_mmi.c","type":"source","group":"legacy","path":"/Applications/MATLAB_R2024a.app/rtw/c/src","tag":"","groupDisplay":"Other files","code":"/* \n *\n * Copyright 1994-2022 The MathWorks, Inc.\n *\n * File: rt_logging_mmi.c\n *\n * Abstract:\n */\n\n#ifndef rt_logging_c\n#define rt_logging_c\n\n#include <stdlib.h>\n#include <stddef.h>\n/* Macro SIMPLIFIED_RTWTYPES_COMPATIBILITY declares compatibility with simplified version of\n * rtwtypes.h */\n#define SIMPLIFIED_RTWTYPES_COMPATIBILITY\n#include \"rtwtypes.h\"\n#undef SIMPLIFIED_RTWTYPES_COMPATIBILITY\n#include \"builtin_typeid_types.h\"\n#include \"rtw_matlogging.h\"\n#include \"rtw_modelmap.h\"\n#include <string.h>\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\nstatic const char_T rtMemAllocError[] = \"Memory allocation error\";\n#define FREE(m) if (m != NULL) free(m)\n\n#define ACCESS_C_API_FOR_RTW_LOGGING true\n\n/* Function: rt_FillStateSigInfoFromMMI =======================================\n * Abstract:\n *\n * Returns:\n *\t== NULL  => success.\n *\t~= NULL  => failure, the return value is a pointer to the error\n *                           message, which is also set in the simstruct.\n */\nconst char_T * rt_FillStateSigInfoFromMMI(RTWLogInfo   *li,\n                                                 const char_T **errStatus)\n{\n    int_T                  i;\n    int_T                  nSignals     = 0;\n    int_T                  *dims        = NULL;\n    BuiltInDTypeId         *dTypes      = NULL;\n    int_T                  *cSgnls      = NULL;\n    char_T                 **labels     = NULL;\n    char_T                 **blockNames = NULL;\n    char_T                 **stateNames = NULL;\n    boolean_T              *crossMdlRef = NULL;\n    char_T                 **pathAlias  = NULL;\n    void                   **sigDataAddr = NULL;\n    RTWLoggingFcnPtr       *RTWLoggingPtrs = NULL;\n    int_T                  *logDataType = NULL;\n    boolean_T              *isVarDims   = NULL;\n    const rtwCAPI_ModelMappingInfo *mmi = (const rtwCAPI_ModelMappingInfo *)rtliGetMMI(li);\n\n    int_T                  sigIdx       = 0;\n\n    RTWLogSignalInfo *     sigInfo;\n    /* reset error status */\n    *errStatus = NULL;\n\n    sigInfo = (RTWLogSignalInfo *)calloc(1,sizeof(RTWLogSignalInfo));\n    if (sigInfo == NULL) goto ERROR_EXIT;\n\n    nSignals = rtwCAPI_GetNumStateRecordsForRTWLogging(mmi);\n\n    if (nSignals >0) {\n        /* These are all freed before exiting this function */\n        dims        = (int_T *)calloc(nSignals,sizeof(int_T));\n        if (dims == NULL) goto ERROR_EXIT;\n        dTypes      = (BuiltInDTypeId *)calloc(nSignals,sizeof(BuiltInDTypeId));\n        if (dTypes == NULL) goto ERROR_EXIT;\n        cSgnls      = (int_T *)calloc(nSignals,sizeof(int_T));\n        if (cSgnls == NULL) goto ERROR_EXIT;\n        labels      = (char_T **)calloc(nSignals, sizeof(char_T*));\n        if (labels == NULL) goto ERROR_EXIT;\n        blockNames  = (char_T**)calloc(nSignals, sizeof(char_T*));\n        if (blockNames == NULL) goto ERROR_EXIT;\n        stateNames  = (char_T**)calloc(nSignals, sizeof(char_T*));\n        if (stateNames == NULL) goto ERROR_EXIT;\n        crossMdlRef  = (boolean_T*)calloc(nSignals, sizeof(boolean_T));\n        if (crossMdlRef == NULL) goto ERROR_EXIT;\n        pathAlias  = (char_T**)calloc(nSignals, sizeof(char_T*));\n        if (pathAlias == NULL) goto ERROR_EXIT;\n        logDataType = (int_T *)calloc(nSignals,sizeof(int_T));\n        if (logDataType == NULL) goto ERROR_EXIT;\n        /* Allocate memory for isVarDims pointer and set all elements to 0's */\n        isVarDims = (boolean_T *)calloc(nSignals,sizeof(boolean_T));\n        if (isVarDims == NULL) goto ERROR_EXIT;\n\n        /* These are freed in stopDataLogging (they're needed in the meantime) */\n        sigDataAddr = (void **)calloc(nSignals,sizeof(void *));\n        if (sigDataAddr == NULL) goto ERROR_EXIT;\n        RTWLoggingPtrs = (RTWLoggingFcnPtr *)calloc(nSignals, sizeof(RTWLoggingFcnPtr));\n        if (RTWLoggingPtrs == NULL) goto ERROR_EXIT;\n\n        *errStatus = rtwCAPI_GetStateRecordInfo(mmi,\n                                                (const char_T**) blockNames,\n                                                (const char_T**) labels,\n                                                (const char_T**) stateNames,\n                                                dims,\n                                                (int_T*)dTypes,\n                                                logDataType,\n                                                cSgnls,\n                                                sigDataAddr,\n                                                RTWLoggingPtrs,\n                                                crossMdlRef,\n                                                NULL, /* sigInProtectedMdl */\n                                                (const char_T**) pathAlias,\n                                                NULL, /* sigSampleTime */\n                                                NULL, /* sigHierInfoIdx */\n                                                NULL, /* sigFlatElemIdx */\n                                                NULL, /* sigMMI */\n                                                &sigIdx,\n                                                false, /* crossingModel */\n                                                false, /* isInProtectedMdl */\n                                                NULL,  /* stateDerivVector */\n                                                ACCESS_C_API_FOR_RTW_LOGGING);\n\n        if (*errStatus != NULL) goto ERROR_EXIT;\n\n        rtliSetLogXSignalPtrs(li,(LogSignalPtrsType)sigDataAddr);\n    }\n\n    /* g2104454 : If pathAlias is available then copy it as block name */\n    for (i = 0; i < nSignals; ++i) {\n        if (pathAlias[i] != NULL) {\n            utFree(blockNames[i]);\n            blockNames[i] = pathAlias[i];\n        }\n    }\n\n    /* Done with pathAlias */\n    FREE(pathAlias);\n\n    sigInfo->numSignals = nSignals;\n    sigInfo->numCols = dims;\n    sigInfo->numDims = NULL;\n    sigInfo->dims = dims;\n    sigInfo->dataTypes = dTypes;\n    sigInfo->complexSignals = cSgnls;\n    sigInfo->frameData = NULL;\n    sigInfo->preprocessingPtrs = (RTWPreprocessingFcnPtr*) RTWLoggingPtrs;\n    sigInfo->labels.ptr = labels;\n    sigInfo->titles = NULL;\n    sigInfo->titleLengths = NULL;\n    sigInfo->plotStyles = NULL;\n    sigInfo->blockNames.ptr = blockNames;\n    sigInfo->stateNames.ptr = stateNames;\n    sigInfo->crossMdlRef = crossMdlRef;\n    sigInfo->dataTypeConvert = NULL;\n\n    sigInfo->isVarDims = isVarDims;\n    sigInfo->currSigDims = NULL;\n\n    rtliSetLogXSignalInfo(li,sigInfo);\n\n    /* Free logDataType it's not needed any more,\n     * the rest of them will be freed later */\n    FREE(logDataType);\n    return(NULL); /* NORMAL_EXIT */\n\n  ERROR_EXIT:\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    /* Free local stuff that was allocated. It is no longer needed */\n    for (i = 0; i < nSignals; ++i) utFree(blockNames[i]);\n    FREE(blockNames);\n    for (i = 0; i < nSignals; ++i) utFree(stateNames[i]);\n    FREE(stateNames);\n    FREE(labels);\n    FREE(dims);\n    FREE(dTypes);\n    FREE(logDataType);\n    FREE(cSgnls);\n    FREE(isVarDims);\n    return(*errStatus);\n\n} /* end rt_InitSignalsStruct */\n\nvoid rt_CleanUpForStateLogWithMMI(RTWLogInfo *li)\n{\n    int_T i;\n    RTWLogSignalInfo *sigInfo = _rtliGetLogXSignalInfo(li); /* get the non-const ptr */\n    int_T nSignals = sigInfo->numSignals;\n\n    if ( nSignals > 0 ) {\n\n        for (i = 0; i < nSignals; ++i) utFree(sigInfo->blockNames.ptr[i]);\n        FREE(sigInfo->blockNames.ptr);\n        FREE(sigInfo->labels.ptr);\n        FREE(sigInfo->crossMdlRef);\n        FREE(sigInfo->dims);\n        FREE(sigInfo->dataTypes);\n        FREE(sigInfo->complexSignals);\n        FREE(sigInfo->isVarDims);\n        FREE(sigInfo);\n        rtliSetLogXSignalInfo(li, NULL);\n\n        FREE(_rtliGetLogXSignalPtrs(li)); /* get the non-const ptr */\n        rtliSetLogXSignalPtrs(li,NULL);\n    }\n}\n\n#endif /*  rt_logging_mmi_c */\n\n/* LocalWords:  Hier Deriv\n */\n"},{"name":"rtiostream_interface.c","type":"source","group":"legacy","path":"/Applications/MATLAB_R2024a.app/rtw/c/src/ext_mode/common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2018 The MathWorks, Inc.\n *\n * File: rtiostream_interface.c     \n *\n * Abstract: \n * Provide a target-side communications driver interface for Simulink external\n * mode.\n */\n\n\n/***************** TRANSPORT-INDEPENDENT INCLUDES *****************************/\n\n#ifndef EXTMODE_DISABLEPRINTF  \n#include <stdio.h>\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"updown_util.h\"\n#include \"rtwtypes.h\"\n#include \"rtw_extmode.h\"\n\n/* include rtIOStream interface to use */\n#include \"rtiostream.h\"\n\n/* include Target-side rtIOStream utility APIs */\n#include \"rtiostream_utils.h\"\n\n#ifdef VXWORKS\n# include <sockLib.h>\n# include <inetLib.h>\n# include <selectLib.h>\nextern SEM_ID commSem;\n#endif\n\n#ifdef LEGO\n#include \"ecrobot_interface.h\"\n#endif\n\n#include \"ext_types.h\"\n#include \"ext_share.h\"\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\n/* \n * ExtCloseConnection() sets this to FALSE (to signal the low layer rtiostream)\n * on an external mode disconnection.\n * \n * rtIOStreamRecv() reads a few spurious bytes before receiving valid data on its\n * first call during external mode start or connect. Setting receivedSyncByteE\n * to FALSE forces rtIOStreamRecv() to look for the first character 'e' in 'ext-mode',\n * which is the first valid external mode packet. All preceding bytes are rejected and\n * subsequent bytes including the string 'ext-mode' are forwarded.\n * \n * For a more detailed description refer to the\n * comments in the associated rtiostream_serial_daemon.c/cpp file.\n */\n#if (defined(ARDUINO_ARCH_AVR) || defined(ARDUINO_SAM_DUE)) && !defined(_ROTH_LEONARDO_)\nextern volatile boolean_T receivedSyncByteE;\n#endif\n\ntypedef struct ExtUserData_tag {\n    boolean_T waitForStartPkt;\n    int streamID;\n#ifdef VXWORKS \n    int_T processArgsArgc;\n    const char_T ** processArgsArgv;\n#endif\n} ExtUserData;\n\n\n/* Function: ExtProcessArgs ====================================================\n * Abstract:\n *  Process the arguments specified by the user when invoking the target\n *  program.  In the case of this TCPIP example the args handled by external\n *  mode are:\n *      o -port #\n *          specify tcpip port number\n *      \n *      o -w\n *          wait for a start packet from the target before starting to execute\n *          the real-time model code\n *\n *  If any unrecognized options are encountered, ignore them.\n *\n * NOTES:\n *  o An error string is returned on failure, NULL is returned on success.\n *\n *  o IMPORTANT!!!\n *    As the arguments are processed, their strings must be NULL'd out in\n *    the argv array.  ext_svr will search argv when this function returns,\n *    and if any non-NULL entries are encountered an \"unrecognized option\" \n *    packet will be displayed.\n */\nPUBLIC const char_T *ExtProcessArgs(\n    ExtUserData   *UD,\n    const int_T   argc,\n    const char_T  *argv[])\n{\n    const char_T *error          = NULL;\n    int_T        count           = 1;\n\n#if defined(ON_TARGET_WAIT_FOR_START) && ON_TARGET_WAIT_FOR_START == 1\n    boolean_T    waitForStartPkt = true;\n#else\n    boolean_T    waitForStartPkt = false;\n#endif\n\n    while(count < argc) {\n        const char_T *option = argv[count++];\n        \n        if (option == NULL) continue;\n\n        if (strcmp(option, \"-w\") == 0) {\n            /* \n             * -w (wait for packet from host) option\n             */\n            waitForStartPkt = true;\n            \n            argv[count-1] = NULL;\n        } else if (strcmp(option, \"-ignore-arg\") == 0 && (count != argc)) {\n            /*\n             * Special argument used by sbruntests to mark an executable\n             * with a particular ID allowing the executable to be killed\n             * when the sbruntests session is killed.\n             *\n             * -ignore-arg SBRUNTESTS_SESSION_ID#\n             */\n            count++;     \n            argv[count-2] = NULL;\n            argv[count-1] = NULL;\n        }\n    }\n\n    assert(UD != NULL);\n    UD->waitForStartPkt = waitForStartPkt;\n\n#ifdef VXWORKS\n    /* Store argv and argc for processing in ExtUserDataSetPort. \n     * rtIOStreamOpen will be called in ExtUserDataSetPort */\n    UD->processArgsArgc = argc;\n    UD->processArgsArgv = (const char_T **) argv;\n#else\n    /* rtIOStreamOpen combines argument processing and opening the stream */\n    UD->streamID = rtIOStreamOpen(argc, (void **) (void *) argv);\n#endif    \n    return(error);\n} /* end ExtProcessArgs */\n\n\n/* Function: ExtUserDataCreate =================================================\n * Abstract:\n *  Create the user data.\n */\nPUBLIC ExtUserData *ExtUserDataCreate(void)\n{\n    static ExtUserData UD;\n\n    return &UD;\n} /* end ExtUserDataCreate */\n\n\n/* Function: ExtInit ===========================================================\n * Abstract:\n *  Called once at program startup to do any initialization related to external\n *  mode.  For the TCPIP, example, a socket is created to listen for\n *  connection requests from the host.  EXT_NO_ERROR is returned on success,\n *  EXT_ERROR on failure.\n *\n * NOTES:\n *  o This function should not block.\n */\nPUBLIC boolean_T ExtInit(ExtUserData *UD)\n{\n    boolean_T error      = EXT_NO_ERROR;\n\n    UNUSED_PARAMETER(UD);\n\n\n    /* rtIOStreamOpen has already been called so no further\n     * action required here */\n\n    return(error);\n} /* end ExtInit */\n\n/* Function: ExtSetHostPkt =====================================================\n * Abstract:\n *  Sets (sends) the specified number of bytes on the comm line.  As long as\n *  an error does not occur, this function is guaranteed to set the requested\n *  number of bytes.  The number of bytes set is returned via the 'nBytesSet'\n *  parameter.  EXT_NO_ERROR is returned on success, EXT_ERROR is returned on\n *  failure.\n *\n * NOTES:\n *  o it is always o.k. for this function to block if no room is available\n */\nPUBLIC boolean_T ExtSetHostPkt(\n    const ExtUserData *UD,\n    const int         nBytesToSet,\n    const char        *src,\n    int               *nBytesSet)\n{\n    boolean_T errorCode = EXT_NO_ERROR;\n\tint_T rtIOStreamErrorStatus;\n\t*nBytesSet = 0;\t/* assume */\n\n    #ifdef VXWORKS\n        semTake(commSem, WAIT_FOREVER);\n    #endif\n\n    /* Blocks until all requested outgoing data is sent */\n    rtIOStreamErrorStatus = rtIOStreamBlockingSend(UD->streamID,\n                                                   (const void *) src,\n                                                   (uint32_T) nBytesToSet);\n    \n    if (rtIOStreamErrorStatus == RTIOSTREAM_ERROR) {\n        errorCode = EXT_ERROR;\n    } else { \n        *nBytesSet = nBytesToSet;\n    }\n    \n    #ifdef VXWORKS\n        semGive(commSem);\n    #endif\n\n    return errorCode;\n\n} /* end ExtSetHostPkt */\n\n/* Function: ExtGetHostPkt =====================================================\n * Abstract:\n *  Attempts to get the specified number of bytes from the comm line.  The\n *  number of bytes read is returned via the 'nBytesGot' parameter.\n *  EXT_NO_ERROR is returned on success, EXT_ERROR is returned on failure.\n *\n * NOTES:\n *  o it is not an error for 'nBytesGot' to be returned as 0\n *  o not guaranteed to read total requested number of bytes\n */\nPUBLIC boolean_T ExtGetHostPkt(\n    const ExtUserData *UD,\n    const int         nBytesToGet,\n    int               *nBytesGot, /* out */\n    char              *dst)       /* out */\n{\n    boolean_T error = EXT_NO_ERROR;\n    int_T result;\n    size_t stNBytesGot;\n\n    result = rtIOStreamRecv(UD->streamID, dst, (size_t) nBytesToGet, &stNBytesGot);\n\n    if (result == RTIOSTREAM_ERROR) {\n        error = EXT_ERROR;\n    } else {\n        *nBytesGot = (int) stNBytesGot;\n    }\n\n    return(error);\n} /* end ExtGetHostPkt */\n\n\n/* Function: ExtWaitForStartPktFromHost ========================================\n * Abstract:\n *  Return true if the model should not start executing until told to do so\n *  by the host.\n */\nPUBLIC boolean_T ExtWaitForStartPktFromHost(ExtUserData *UD)\n{\n    return(UD->waitForStartPkt);\n} /* end ExtWaitForStartPktFromHost */\n\n\n/* Function: ExtUserDataDestroy ================================================\n * Abstract:\n *  Destroy the user data.\n */\nPUBLIC void ExtUserDataDestroy(ExtUserData *UD)\n{\n    UNUSED_PARAMETER(UD);\n} /* end ExtUserDataDestroy */\n\n/* Function: ExtUserDataSetPort ================================================\n * Abstract:\n *  Set the port in the external mode user data structure.\n */\n#ifdef VXWORKS\nPUBLIC void ExtUserDataSetPort(ExtUserData *UD, const int_T port)\n{\n#define PORT_NUM_STR_DEFAULT \"00255\\0\"\n#define PORT_NUM_STR_LEN 6 /* allocates extra space for sprintf below */\n#define PORT_ARG_STR \"-port\"\n    /* create an extended argc and argv that includes -port */    \n    const int_T argc = UD->processArgsArgc + 2;\n    const char_T * portArgStr = PORT_ARG_STR;\n    char_T portNumStr[PORT_NUM_STR_LEN] = PORT_NUM_STR_DEFAULT;\n    const char_T ** argv = (const char_T **) calloc(argc, sizeof(char_T *));\n    int_T count;\n    if (argv == NULL) {\n#ifndef EXTMODE_DISABLEPRINTF        \n       (void)fprintf(stderr,\n                \"ExtUserDataSetPort: Memory allocation error.\\n\");\n#endif\n       /* any unprocessed args in the original argv will be caught by caller */\n       return;\n    }\n    /* set a non-default port if valid */ \n    if ( (port >=255) && (port <= 65535)) {\n        sprintf(portNumStr, \"%5d\", port);\n    }\n    /* copy original argv */\n    for (count = 0; count < UD->processArgsArgc; count++) {\n      argv[count] = UD->processArgsArgv[count];\n    }\n    /* add port */\n    argv[argc-2] = portArgStr;\n    argv[argc-1] = (const char_T *) portNumStr;\n        \n    /* rtIOStreamOpen combines argument processing and opening the stream */\n    UD->streamID = rtIOStreamOpen(argc, (void *) argv);\n\n    /* We assume -port argument has been processed by rtIOStream.\n     * Copy back other elements of processed argv which should have been set to NULL. */\n    for (count = 0; count < UD->processArgsArgc; count++) {\n       UD->processArgsArgv[count] = argv[count];\n    }\n    free(argv);\n} /* end ExtUserDataSetPort */\n#endif\n\n\n/* Function: ExtModeSleep =====================================================\n * Abstract:\n *  This function is used if the target is in pause mode or waiting for a\n *  start packet from the host. By calling ExtModeSleep prior to checking \n *  the receive buffer, we can prevent excessive CPU loading.\n */\n#ifndef VXWORKS\nPUBLIC void ExtModeSleep(\n    const ExtUserData *UD,\n    const long        sec,  /* # of secs to wait        */\n    const long        usec) /* # of micros secs to wait */\n{\n\n    UNUSED_PARAMETER(UD);\n    UNUSED_PARAMETER(sec);\n    UNUSED_PARAMETER(usec);\n\n    /* This function is intentionally left empty */\n\n} /* end ExtModeSleep */\n#endif\n\n\n/* Function: ExtOpenConnection =================================================\n * Abstract:\n *  The rtIOStream driver must open a connection implicitly as required. Hence\n *  the implementation of this function is empty.\n */\nPUBLIC boolean_T ExtOpenConnection(\n    ExtUserData *UD,\n    boolean_T   *outConnectionMade)\n{\n    boolean_T          error          = EXT_NO_ERROR;\n    UNUSED_PARAMETER(UD);\n\n    *outConnectionMade = 1;\n    return error;\n\n} /* end ExtOpenConnection */\n\n\n/* Function: ExtForceDisconnect ================================================\n * Abstract:\n *  Called by rt_UploadServerWork() in ext_svr.c when there is an extmode\n *  communication error (e.g. a tcp/ip disconnection between the host and target\n *  caused by a cable problem or extremely high network traffic).  In this case,\n *  we want the target to disconnect from the host even if it can't communicate\n *  with the host because we assume that the communication problem caused the\n *  host to disconnect.  This function will perform all steps necessary to\n *  shutdown the communication and leave the target in a state ready to be\n *  reconnected.\n */\nPUBLIC void ExtForceDisconnect(ExtUserData *UD)\n{\n\n    UNUSED_PARAMETER(UD);\n\n} /* end ExtForceDisconnect */\n\n/* Function: ExtCloseConnection ================================================\n * Abstract:\n *  Called when the target needs to disconnect from the host (disconnect\n *  procedure is initiated by the host).\n */\nPUBLIC void ExtCloseConnection(ExtUserData *UD)\n{\n    UNUSED_PARAMETER(UD);\n    \n    #ifdef LEGO\n    ecrobot_term_bt_connection();\n    #endif\n    \n    #if (defined(ARDUINO_ARCH_AVR) || defined(ARDUINO_SAM_DUE)) && !defined(_ROTH_LEONARDO_)\n    receivedSyncByteE = false;\n    #endif\n            \n} /* end ExtCloseConnection */\n\n\n/* Function: ExtShutDown =======================================================\n * Abstract:\n *  Called when the target program is terminating.\n */\nPUBLIC void ExtShutDown(ExtUserData *UD)\n{\n    rtIOStreamClose(UD->streamID);\n} /* end ExtShutDown */\n\n/* LocalWords:  NULL'd svr extmode tcp ip\n */\n"},{"name":"rtiostream_tcpip.c","type":"source","group":"legacy","path":"/Applications/MATLAB_R2024a.app/toolbox/coder/rtiostream/src/rtiostreamtcpip","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2023 The MathWorks, Inc.\n *\n * File: rtiostream_tcpip.c     \n *\n * Abstract: This source file implements both client-side and server-side TCP/IP\n *  and UDP/IP communication. Typically, this driver is used to support host-target\n *  communication where the client-side device driver runs on the host and the\n *  server-side driver runs on the target. For this implementation, both\n *  client-side and server-side driver code has been combined into a single\n *  file.\n *\n *  If you are using this code as a starting point to implement a TCP/IP or \n *  UDP/IP driver for a custom target it is only necessary to include code \n *  for the server side of the connection.\n */\n\n#ifndef _WIN32\n/* Required BSD Unix extensions are not available by default on certain Unix\n * distributions */\n#define _DEFAULT_SOURCE     /* _DEFAULT_SOURCE must be defined to avoid\n                               _BSD_SOURCE deprecation warning\n                               for glibc >= 2.20 */\n#define _BSD_SOURCE         /* Required to support glibc <= 2.19 */\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <limits.h>\n#include \"rtiostream.h\"\n#include \"tmwtypes.h\"\n\n#ifdef _WIN32\n  /* WINDOWS */\n\n#if defined(_MSC_VER)\n /* temporarily disable warning triggered\n  * by windows.h */\n #pragma warning(push)\n #pragma warning(disable: 4255)\n#endif\n\n/* temporarily add undef to resolve g3061028\n * to be re-evaluated as part of g3119543 */\n#undef A\n#undef B\n#undef V\n#undef W\n\n#include <windows.h>\n\n#if defined(_MSC_VER)\n /* restore warning */\n #pragma warning(pop)\n#endif\n\n# ifdef __LCC__\n# ifndef __LCC64__\n#   include <winsock2.h>\n# endif\n#   include <errno.h>\n# endif\n\n#include <winsock.h> /* in case if WIN32_LEAN_AND_MEAN was defined and needs to be after winsock2 */\n\n#define RTIOSTREAM_ECONNRESET WSAECONNRESET\n\n#elif defined(VXWORKS)\n /*VxWorks headers*/\n# include <selectLib.h>\n# include <sockLib.h>\n# include <inetLib.h>\n# include <ioLib.h>\n# include <taskLib.h>\n# include <netinet/tcp.h> \n\n#define RTIOSTREAM_ECONNRESET ECONNRESET\n\n#else\n  /* UNIX */\n# include <signal.h>\n# include <sys/time.h>      /* Linux */\n# include <sys/types.h>     /* Linux */\n# include <sys/socket.h>\n# include <sys/poll.h>\n# include <netinet/in.h>    /* Linux */\n# include <netinet/tcp.h>   /* Linux */\n# include <arpa/inet.h>     /* Linux */\n# include <netdb.h>\n# include <errno.h>\n# include <fcntl.h>  \n# include <unistd.h>\n\n#define RTIOSTREAM_ECONNRESET ECONNRESET\n#endif\n\n#if defined(_WIN32) || defined(VXWORKS)\n#define USE_SELECT  \n#endif\n\n#ifdef USE_MEXPRINTF\n#include \"mex.h\"\n#define printf mexPrintf\n#define SERVER_PORT_PRINTF(FORMAT, ARG1) mexPrintf(FORMAT, ARG1)\n#else\n/* If stdout is redirected to file, it is essential that the port number is \n * available immediately in the output file. With LCC, printf does not flush \n * correctly to the redirected output file - use fprintf & fflush instead. */\n#define SERVER_PORT_PRINTF(FORMAT, ARG1) fprintf(stdout, FORMAT, ARG1); \\\n                                         fflush(stdout)\n#endif\n\n/***************** DEFINES ****************************************************/                                         \n#define HOSTNAME_MAXLEN (64U)\n\n#define SERVER_PORT_NUM  (17725U)   /* sqrt(pi)*10000 */\n\n/* \n * EXT_BLOCKING  \n *\n * Depending on the implementation of the main program (e.g., grt_main.c,\n * rt_main.c), the EXT_BLOCKING flag must be set to either 0 or 1.\n *\n * rt_main.c (tornado/vxworks): rt_main.c is a real-time, multi-tasking target.\n * The upload and packet servers are called via background (low priority) tasks.\n * In this case, it is o.k. for the transport function to block as the blocked\n * tasks will simply be pre-empted in order to enable the model to run.  It is\n * desirable to block instead of to poll to free up the cpu for any other\n * potential work. \n */\n#ifdef VXWORKS\n# define EXT_BLOCKING (1)  \n#else\n# define EXT_BLOCKING (0)  \n#endif\n\n/* timeout of 0 means to return immediately */\n#define BLOCKING_RECV_TIMEOUT_NOWAIT (0)\n/* timeout of -1 means to wait indefinitely */\n#define BLOCKING_RECV_TIMEOUT_NEVER (-1)\n/* rogue value for blocking receive timeout */\n#define DEFAULT_BLOCKING_RECV_TIMEOUT (-2)\n/* timeout of -3 means to wait for 10 ms to avoid high CPU load */\n#define BLOCKING_RECV_TIMEOUT_10MS (-3)\n/* wake up from blocking every second */\n#define DEFAULT_BLOCKING_RECV_TIMEOUT_SECS_CLIENT (1) \n/* only wake up from blocking when data arrives */\n#define DEFAULT_BLOCKING_RECV_TIMEOUT_SECS_SERVER (BLOCKING_RECV_TIMEOUT_NEVER)\n/* server wait time for client to close its socket */\n#define BLOCKING_RECV_TIMEOUT_SOCK_SHUTDOWN (60)\n\n/* define a set of verbosity levels:\n *\n * 0: no verbose output\n * 1: verbose output with data\n * 2: extra verbose output including when data size is zero*/\ntypedef enum {VERBOSITY_LEVEL_0=0, VERBOSITY_LEVEL_1, VERBOSITY_LEVEL_2} VerbosityLevel;\n/* default verbosity value */\n#define DEFAULT_VERBOSITY VERBOSITY_LEVEL_0\n\n/* default protocol value */\n#define DEFAULT_PROTOCOL TCP_PROTOCOL\n/* allowed -protocol strings */\n#define TCP_PROTOCOL_STRING \"TCP\"\n#define UDP_PROTOCOL_STRING \"UDP\"\n#define UDP_PACKET_LOSS_DETECTON_PROTOCOL_STRING \"UDP_PACKET_LOSS_DETECTION\"\n\n/* default UDP max packet size \n *\n * The maximum size of UDP packets that are transmitted / received must be\n * consistent on the host and target otherwise receive errors will occur at \n * the side with the smaller buffer size specified.\n *\n * Use the \"-maxudppacketsize SIZE\" argument to specify a different packet size.\n * This option is particularly useful when using a custom server implementation\n * that uses a different max packet size to the default. \n *\n * The maximum UDP payload is 65507 bytes, which can be achieved for localhost\n * based communications on Linux and Windows, but Mac has a lower size of\n * 9216.\n */\n#define UDP_MAX_PACKET_SIZE 9216\n#define DEFAULT_MAX_UDP_PACKET_SIZE UDP_MAX_PACKET_SIZE\n/* increase the UDP socket receive size to decrease the \n * possibility of buffer overflow */\n#define DEFAULT_UDP_SOCKET_RECEIVE_SIZE_REQUEST (512 * 1024) \n#define DEFAULT_UDP_SOCKET_SEND_SIZE_REQUEST (512 * 1024) \n\n#define DEFAULT_IS_USING_SEQ_NUM 1\n\n#ifdef WIN32\n  /* WINDOWS */\n# define close closesocket\n# define SOCK_ERR SOCKET_ERROR\n#else\n  /* UNIX, VXWORKS */\n# define INVALID_SOCKET (-1)\n# define SOCK_ERR (-1)\n\n  typedef int SOCKET;\n#endif\n\n/*\n * send prototype differs on different platforms. The following typedefs\n * suppress compiler warnings.\n */\n#if defined(WIN32)\ntypedef const char * send_buffer_t;\n#elif defined(VXWORKS)\ntypedef char * send_buffer_t;\n#else\ntypedef const void * send_buffer_t;\n#endif\n\n/* MIN utility */\n#ifndef MIN\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n\n#ifndef __APPLE__\n#define SPRINTF(a, b, c, d) (sprintf(a, b, c, d))\n#else\n#define SPRINTF(a, b, c, d) (snprintf(a, sizeof(a), b, c, d))\n#endif\n\n/***************** TYPEDEFS **************************************************/\n\n#if (defined(_WIN32)) || (defined(VXWORKS))\n   /* socklen_t may not be available */\n   typedef int rtiostream_socklen_t;\n#else\n   typedef socklen_t rtiostream_socklen_t;\n#endif\n\n#if (defined(_WIN32) || defined(VXWORKS))\n   typedef unsigned long rtiostream_in_addr_t;\n#else\n   typedef in_addr_t rtiostream_in_addr_t;\n#endif\n\n/* Server specific data structure */\ntypedef struct ServerData_tag {\n    int       port;           /* port number associated with the server socket */\n    SOCKET    listenSock;     /* listening socket to accept incoming connections */\n    char      *serverInfoFile; /* the filename that is used to write the server \n                                 port number when dynamic port allocation is used */                      \n} ServerData;\n\n/* UDP send / receive buffer data structure */\ntypedef struct UDPPacketBuffer_tag {\n    char * buffer; /* pointer to the buffer */\n    char * dataPtr; /* pointer to the current position in the buffer */\n    int dataAvail; /* amount of data in the buffer */\n} UDPPacketBuffer;\n\n/* Type for the optional UDP sequence number */\ntypedef uint32_T udpSeqNum_T;\n/* byte size of the UDP sequence number */\n#define UDP_SEQ_NUM_SIZE ((int) sizeof(udpSeqNum_T))\n\n/* UDP specific data structure */\ntypedef struct UDPData_tag {\n   int isUsingSeqNum; /* is this connection using sequence numbers */\n   int maxPacketSize; /* max packet size (buffer size) */\n   UDPPacketBuffer * recvBuffer; /* buffer for an incoming datagram */\n   UDPPacketBuffer * sendBuffer; /* buffer for an outgoing datagram */\n   udpSeqNum_T sendSeqNum; /* sequence number to add to outgoing datagrams */\n   udpSeqNum_T expectedRecvSeqNum; /* expected sequence number in incoming \n                                   datagrams */\n   int resetExpectedRecvSeqNum; /* flags whether to reset expectedRecvSeqNum\n                                   to the sequence number of the next incoming\n                                   datagram */\n} UDPData;\n\n/* enum of supported communications protocols */\ntypedef enum {TCP_PROTOCOL, UDP_PROTOCOL} CommsProtocol;\n\n/* Data encapsulating a single client / server connection  */\ntypedef struct ConnectionData_tag {\n   int isInUse; /* is this ConnectionData instance currently in use? */\n   int isServer; /* is this ConnectionData instance a Server (or client)? */\n   int blockingRecvTimeout; /*    Timeout value in seconds. rtIOStreamRecv \n                                  blocks until at least some of the requested \n                                  data is available or the timeout expires.   \n                                  If a timeout occurs the receiveSize will be 0. \n\n                                  A value of BLOCKING_RECV_TIMEOUT_NOWAIT (0)\n                                  means to block for 0 seconds (polling mode). \n                                  rtIOStreamRecv processes \n                                  any pending data or, if no data is available, \n                                  returns immediately with a receiveSize of 0.\n\n                                  A value of BLOCKING_RECV_TIMEOUT_NEVER (-1)\n                                  means to block indefinitely (full blocking \n                                  mode). rtIOStreamRecv blocks\n                                  until at least some of the requested data is \n                                  available.   receiveSize should always be \n                                  greater than 0. \n\n                                  A value of BLOCKING_RECV_TIMEOUT_10MS (-3)\n                                  means to block for up to 10 ms to avoid high CPU \n                                  load.\n                             */\n   VerbosityLevel verbosity; /* enum indicating the level of verbosity to be displayed on the output */\n   CommsProtocol protocol; /* TCP or UDP protocol */\n   SOCKET sock; /* socket to send/receive packets */\n   ServerData * serverData; /* Server specific data - NULL for clients */\n   UDPData * udpData; /* UDP specific data - NULL for TCP */\n   int udpSendBufSize;\n   int udpRecvBufSize;\n} ConnectionData;\n\n/**************** LOCAL DATA *************************************************/\n\n/* All local data resides in the per client / \n * server instance ConnectionData structures to make sure each connection is\n * completely independent.\n *\n * Each ConnectionData does not use much memory; any optionally required \n * send / recv buffers are dynamically allocated and freed when the ConnectionData \n * actually becomes in use.\n *\n * The static array will be deallocated when the shared library is unloaded. \n *\n * Using an array rather than a linked list allows us to have fast direct lookup\n * of ConnectionData from connectionID during calls to rtIOStreamSend/Recv */\n#define MAX_NUM_CONNECTIONS (50)\nstatic ConnectionData connectionDataArray[MAX_NUM_CONNECTIONS];\n\n/************** LOCAL FUNCTION PROTOTYPES ************************************/\n\nstatic int initConnectionData(int connectionID, \n                          int isServer, \n                          CommsProtocol protocol, \n                          SOCKET sock, \n                          int blockingRecvTimeout,\n                          int maxPacketSize, \n                          int serverPort, \n                          char * serverInfoFile, \n                          VerbosityLevel verbosity, \n                          int isUsingSeqNum,\n                          int udpSendBufSize,\n                          int udpRecvBufSize); \n\nstatic int getConnectionID(void);\n\nstatic ConnectionData * getConnectionData(int connectionID);\n\nstatic void freeConnectionData(ConnectionData * connection);\n\nstatic UDPPacketBuffer * createUDPPacketBuffer(int maxPacketSize);\n\nstatic void freeUDPPacketBuffer(UDPPacketBuffer ** udpPacketBuffer);\n\nstatic void resetUDPPacketBuffer(UDPPacketBuffer * udpPacketBuffer);\n\nstatic int processUDPRecvSeqNum(ConnectionData * connection);\n\nstatic int initialUDPServerRecvfrom(ConnectionData * connection,\n                                    struct sockaddr * clientSA,\n                                    rtiostream_socklen_t * clientSALen);\n\nstatic int waitForClientClose(ConnectionData * connection);\n\nstatic int socketDataSet(\n    ConnectionData * connection, \n    const void *src,\n    const size_t size,\n    size_t *sizeSent);\n\nstatic int socketDataGet(\n    ConnectionData * connection, \n    char          *dst,\n    const size_t   size,\n    size_t        *sizeRecvd);\n\nstatic int socketDataPending(\n    const SOCKET sock,\n    ConnectionData * connection,\n    int    *outPending,\n    int timeoutSecs);\n\nstatic int serverStreamRecv( \n    ConnectionData * connection, \n    void * dst,\n    size_t size,\n    size_t * sizeRecvd);\n\nstatic SOCKET serverOpenSocket(int port, char * serverInfoFile, CommsProtocol protocol,int udpSendBufSize, int udpRecvBufSize);\n\n#if (!defined(VXWORKS))\nstatic SOCKET clientOpenSocket(char * hostName, unsigned int portNum, CommsProtocol protocol, int udpSendBufSize, int udpRecvBufSize);\n#endif\n\nstatic void serverAcceptSocket(ConnectionData * connection);\n\nstatic int processArgs(\n    const int          argc,\n    void            *  argv[],\n    char           **  hostName, \n    unsigned int    *  portNum,\n    unsigned int    *  isClient,\n    int             *  isBlocking,\n    int             *  recvTimeout, \n    char           **  serverInfoFile, \n    CommsProtocol   * protocol, \n    int             * maxPacketSize,\n    VerbosityLevel  * verbosity, \n    int             * isUsingSeqNum,\n    int             * udpSendBufSize,\n    int             * udpRecvBufSize);\n\n#if (!defined(VXWORKS))\nstatic rtiostream_in_addr_t nameLookup(char * hostName);\n#endif\n\n/*************** LOCAL FUNCTIONS **********************************************/\n\n/* Function: initConnectionData =================================================\n * Abstract:\n *  Initializes a client / server ConnectionData for the specified protocol.\n *\n *  A return value of RTIOSTREAM_ERROR indicates an error.\n */\nstatic int initConnectionData(int connectionID, \n                          int isServer, \n                          CommsProtocol protocol, \n                          SOCKET sock, \n                          int blockingRecvTimeout,\n                          int maxPacketSize, \n                          int serverPort, \n                          char * serverInfoFile, \n                          VerbosityLevel verbosity, \n                          int isUsingSeqNum,\n                          int udpSendBufSize,\n                          int udpRecvBufSize) {\n   int retVal = RTIOSTREAM_NO_ERROR;\n   ConnectionData * connection = &connectionDataArray[connectionID];\n  \n   /* initialize the new ConnectionData */\n   connection->isInUse = 1;\n   connection->isServer = isServer;\n   connection->blockingRecvTimeout = blockingRecvTimeout;\n   connection->protocol = protocol;\n   connection->verbosity = verbosity;\n   connection->udpSendBufSize = udpSendBufSize;\n   connection->udpRecvBufSize = udpRecvBufSize;\n   /* initialize to NULL early so that calls to \n    * freeConnectionData on error will succeed */\n   connection->udpData = NULL;\n   connection->serverData = NULL;\n\n   if (connection->protocol == UDP_PROTOCOL) {      \n      /* initialize the UDP data */\n      connection->udpData = (UDPData *) malloc(sizeof(UDPData));\n      if (connection->udpData == NULL) {\n         printf(\"initConnectionData:UDPData malloc failed.\\n\");\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      /* initialize to NULL */\n      connection->udpData->recvBuffer = NULL;\n      connection->udpData->sendBuffer = NULL;\n      connection->udpData->isUsingSeqNum = isUsingSeqNum;\n      connection->udpData->maxPacketSize = maxPacketSize;\n      /* send sequence numbers always start from 0 */\n      connection->udpData->sendSeqNum = 0;\n      /* initially, seed the expectedRecvSeqNum from the first \n       * received packet */\n      connection->udpData->resetExpectedRecvSeqNum = 1;      \n      connection->udpData->recvBuffer = createUDPPacketBuffer(maxPacketSize);\n      if (connection->udpData->recvBuffer == NULL) {\n         printf(\"initConnectionData:createUDPPacketBuffer failed.\\n\");\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      if (maxPacketSize > UDP_MAX_PACKET_SIZE) {\n         /* packet size cannot exceed the maximum \n          * UDP packet size */\n         printf(\"initConnectionData: udpmaxpacketsize must be less than %d\\n\", UDP_MAX_PACKET_SIZE);\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      if (connection->udpData->isUsingSeqNum) {\n         /* packet size must be larger than the size\n          * of the sequence number */\n         if (maxPacketSize <= UDP_SEQ_NUM_SIZE) {\n            printf(\"initConnectionData: udpmaxpacketsize must be larger than %d\\n\", UDP_SEQ_NUM_SIZE);\n            freeConnectionData(connection);\n            retVal = RTIOSTREAM_ERROR;\n            return retVal; \n         }\n         /* send buffer will be required in order to add the sequence\n          * number to the outgoing data */\n         connection->udpData->sendBuffer = createUDPPacketBuffer(maxPacketSize);\n         if (connection->udpData->sendBuffer == NULL) {\n            printf(\"initConnectionData:createUDPPacketBuffer failed.\\n\");\n            freeConnectionData(connection);\n            retVal = RTIOSTREAM_ERROR;\n            return retVal; \n         }\n      }\n   }\n\n   if (isServer) {\n      /* initialize server data */\n      connection->serverData = (ServerData *) malloc(sizeof(ServerData));\n      if (connection->serverData == NULL) {\n         printf(\"initConnectionData:ServerData malloc failed.\\n\");\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      connection->serverData->port = serverPort;\n      connection->serverData->serverInfoFile = serverInfoFile;\n      /* provided sock is the listening sock */\n      connection->serverData->listenSock = sock;\n      /* later call to serverAcceptSocket will set sock */ \n      connection->sock = INVALID_SOCKET;\n   }\n   else {\n      /* store the provided socket */\n      connection->sock = sock;\n   }\n\n   if (verbosity) {\n      if (connection->protocol == TCP_PROTOCOL) {\n         printf(\"Connection id %d, protocol: TCP/IP\\n\", connectionID);\n      }\n      else if (connection->protocol == UDP_PROTOCOL) {\n         printf(\"Connection id %d, protocol: UDP/IP\\n\", connectionID);\n         printf(\"Connection id %d, maxPacketSize: %d\\n\", connectionID, \n                                                         connection->udpData->maxPacketSize);\n         printf(\"Connection id %d, isUsingSeqNum: %d\\n\", connectionID, \n                                                         connection->udpData->isUsingSeqNum);\n      }\n      else {\n         printf(\"initConnectionData:invalid protocol.\\n\");\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      {\n         /* display the size of the socket receive buffer */\n         rtiostream_socklen_t optionLen = sizeof(int);\n         int optionValue;\n         getsockopt(sock, SOL_SOCKET, SO_SNDBUF, (char *) &optionValue, &optionLen);\n         printf(\"Connection id %d, udpSendBufSize: %d\\n\", connectionID, optionValue);\n         getsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *) &optionValue, &optionLen);\n         printf(\"Connection id %d, udpRecvBufSize: %d\\n\", connectionID, optionValue);\n      }\n      printf(\"Connection id %d, blockingRecvTimeout: %d\\n\", connectionID, \n                                                            connection->blockingRecvTimeout);\n      if ((connection->isServer) && (connection->serverData != NULL)) {\n         printf(\"Connection id %d, type: server\\n\", connectionID);       \n         if (connection->serverData->serverInfoFile != NULL) {\n            printf(\"Connection id %d, server info file: %s\\n\", connectionID, \n                                                               connection->serverData->serverInfoFile);\n         }\n      }\n      else {\n         printf(\"Connection id %d, type: client\\n\", connectionID);\n      }\n      printf(\"Connection id %d, socket id %d\\n\", connectionID, (int) sock);\n      /* relevant to both clients and servers */\n      printf(\"Connection id %d, server port: %d\\n\", connectionID, serverPort);\n   }\n   return retVal;\n}\n\n/* Function: getConnectionData =================================================\n * Abstract:\n *  Retrieves a ConnectionData instance given its connectionID \n *  (as returned by initConnectionData) \n *\n * NOTE: An invalid connectionID will lead to a NULL pointer being returned \n */\nstatic ConnectionData * getConnectionData(int connectionID) {\n   /* return NULL for invalid or uninitialized connectionIDs */\n   ConnectionData * connection = NULL;\n   if ((connectionID >= 0) && (connectionID < MAX_NUM_CONNECTIONS)) {\n      if (connectionDataArray[connectionID].isInUse) {\n         connection = &connectionDataArray[connectionID];\n      }\n   }\n   return connection;\n}\n\n/* Function: getConnectionID =================================================\n * Abstract:\n *  Returns a connectionID corresponding to a ConnectionData that is not \n *  already in use.\n *\n *  Returns RTIOSTREAM_ERROR if all available ConnectionData instances are \n *  already in use.\n */\nstatic int getConnectionID(void) {\n   int connectionID;\n   int foundUnusedConnectionData = 0;\n   /* linear search for an unused ConnectionData */\n   for (connectionID = 0; connectionID < MAX_NUM_CONNECTIONS; connectionID++) {      \n      if (!connectionDataArray[connectionID].isInUse) {\n         foundUnusedConnectionData = 1;\n         break;\n      }\n   }\n   if (!foundUnusedConnectionData) {\n      /* all ConnectionData's are in use */\n      printf(\"getConnectionID: All %d available connections are in use.\\n\", MAX_NUM_CONNECTIONS);\n      connectionID = RTIOSTREAM_ERROR;\n   }\n   return connectionID;\n}\n\n/* Function: freeConnectionData =================================================\n * Abstract:\n *  Frees memory associated with the ConnectionData referenced by connectionID.\n *  Marks the ConnectionData instance as no longer in use.\n */\nstatic void freeConnectionData(ConnectionData * connection) {\n   /* mark the ConnectionData as not in use */\n   connection->isInUse = 0;\n   /* free dynamic memory */\n   if (connection->protocol == UDP_PROTOCOL) {\n      freeUDPPacketBuffer(&connection->udpData->recvBuffer);\n      /* freeConnectionData is called if connection->udpData did not allocate */\n      if (connection->udpData != NULL) {\n        if (connection->udpData->isUsingSeqNum) {\n            freeUDPPacketBuffer(&connection->udpData->sendBuffer);\n        }\n      }\n      free(connection->udpData);\n      connection->udpData = NULL;\n   }\n   if (connection->isServer) {\n      free(connection->serverData);\n      connection->serverData = NULL;\n   }\n}\n\n/* Function: createUDPPacketBuffer =================================================\n * Abstract:\n *  Allocates storage for and initializes a UDPPacketBuffer\n */\nstatic UDPPacketBuffer * createUDPPacketBuffer(int maxPacketSize) {\n   /* initialize the UDP packet buffer */\n   UDPPacketBuffer * udpPacketBuffer = (UDPPacketBuffer *) malloc(sizeof(UDPPacketBuffer));      \n   if (udpPacketBuffer == NULL) {\n      printf(\"createUDPPacketBuffer:UDPPacketBuffer malloc failed.\\n\");\n      return udpPacketBuffer; \n   }\n   /* allocate the buffer */\n   udpPacketBuffer->buffer = (char *) calloc((size_t)maxPacketSize, sizeof(char));\n   if (udpPacketBuffer->buffer == NULL) {\n      printf(\"createUDPPacketBuffer:UDPPacketBuffer buffer malloc failed.\\n\");\n      /* free everything we allocated */\n      free(udpPacketBuffer);\n      udpPacketBuffer = NULL;\n      return udpPacketBuffer; \n   }\n   resetUDPPacketBuffer(udpPacketBuffer);\n   return udpPacketBuffer;\n}\n\n/* Function: freeUDPPacketBuffer =================================================\n * Abstract:\n *  Frees memory associated with the referenced UDPPacketBuffer \n */\nstatic void freeUDPPacketBuffer(UDPPacketBuffer ** udpPacketBuffer) {\n   if (*udpPacketBuffer != NULL) {\n      /* free the buffer */\n      free((*udpPacketBuffer)->buffer);\n      (*udpPacketBuffer)->buffer = NULL;\n      /* free the container */\n      free(*udpPacketBuffer);\n      *udpPacketBuffer = NULL;\n   }\n}\n\n/* Function: resetUDPPacketBuffer =================================================\n * Abstract:\n *  Resets the referenced UDP Packet Buffer so that it is ready to receive fresh data\n */\nstatic void resetUDPPacketBuffer(UDPPacketBuffer * udpPacketBuffer) {\n   udpPacketBuffer->dataPtr = udpPacketBuffer->buffer;\n   udpPacketBuffer->dataAvail = 0;\n}\n\n/* Function: socketDataPending =================================================\n * Abstract:\n *  Returns true, via the 'pending' arg, if data is pending on the comm line.\n *  Returns false otherwise.\n *\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR on failure.\n */\nstatic int socketDataPending(\n    const SOCKET sock,\n    ConnectionData * connection,\n    int    *outPending, \n    int timeoutSecs)\n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    int pending = SOCK_ERR; /* assume failure until success */\n    \n    #ifdef USE_SELECT\n    /* Variables used with select() on Win32 & VXWorks */\n    struct timeval  tval;\n    struct timeval * tvalPtr;\n    fd_set          ReadFds;\n    #else\n    /* Variables used with poll() on Linux */\n    struct pollfd PollReadFd[1];\n    int tvalPoll;\n    int pollAttempt = 0;\n    #define MAX_POLL_RETRIES 5\n    #endif\n    \n    \n    if (connection->protocol == UDP_PROTOCOL) {\n       /* first check the UDP buffer */\n       UDPPacketBuffer * udpPacketBuffer = connection->udpData->recvBuffer;\n       if (udpPacketBuffer->dataAvail) {\n          *outPending = 1;\n          return retVal;\n       }\n    }\n\n    #ifdef USE_SELECT          /* Beginning of block for using select */\n    FD_ZERO(&ReadFds);\n    \n    #if defined(_WIN32) && defined(_MSC_VER)\n      /*temporarily disable warning C4127 caused by using FD_SET*/\n      #pragma warning(push)\n      #pragma warning(disable: 4127)\n    #endif\n\n    /* Using fd_set structure ReadFds on Win32/VXWorks */\n    FD_SET(sock, &ReadFds);\n    \n    #if defined(_WIN32) && defined(_MSC_VER)\n      /*enable the warning C4127*/\n      #pragma warning(pop)\n    #endif\n\n    /* Select() uses a timeval structure for specifying timeout */\n    switch (timeoutSecs) {\n       case BLOCKING_RECV_TIMEOUT_NEVER:\n          /* specify null pointer for blocking */\n          tvalPtr = NULL;\n          break;\n       case BLOCKING_RECV_TIMEOUT_10MS:\n          /* set up the 10ms time-val */\n          tval.tv_sec  = 0;\n          tval.tv_usec = 10000;\n          tvalPtr = &tval;\n          break;\n       default:\n          /* set up the time-val */\n          tval.tv_sec  = timeoutSecs;\n          tval.tv_usec = 0;\n          tvalPtr = &tval;\n          break;\n    }\n    #else                       /* Else block for using select */\n    /* Poll() uses an int specifying timeout in milliseconds */\n    switch (timeoutSecs) {\n       case BLOCKING_RECV_TIMEOUT_NEVER:\n          /* specify negative value for blocking */\n          tvalPoll = -1;\n          break;\n       case BLOCKING_RECV_TIMEOUT_10MS:\n          /* set up the 10ms time-val */\n          tvalPoll = 10;\n          break;\n       default:\n          /* set up the time-val */\n          tvalPoll = timeoutSecs*1000;\n          break;\n    }\n    #endif                      /* End of block for using select */\n\n    \n    #ifdef USE_SELECT\n    /* Use select() on Win32 and VxWorks */\n    /*\n     * Casting the first arg to int removes warnings on windows 64-bit\n     * platform.  It is safe to cast a SOCKET to an int here because on\n     * Linux SOCKET is typedef'd to int and on windows the first argument\n     * to select is ignored (so it doesn't matter what the value is).\n     */\n    pending = select((int)(sock + 1), &ReadFds, NULL, NULL, tvalPtr);\n    #else\n    /* Use poll() on Linux and Mac to avoid issues with sockets >= FD_SETSIZE */\n    PollReadFd[0].fd = sock;\n    PollReadFd[0].events = POLLIN;\n    \n    /* Timer interrupts may cause poll to fail with error EINTR.\n     * In these cases we should retry MAX_POLL_RETRIES times before\n     * concluding an error.\n     */\n    do {\n        pending = poll( PollReadFd, 1, tvalPoll);\n        pollAttempt++;\n    } while (pending == SOCK_ERR && errno == EINTR && pollAttempt < MAX_POLL_RETRIES);\n    #endif\n\n    #ifdef USE_SELECT\n    if (pending == SOCK_ERR) \n    #else\n    /* On Linux an extra check of POLLERR flag is needed to detect and report\n       an error if the other end suddenly crashes. The same flag doesn't seem to be\n       activated on Mac */\n    if ((pending == SOCK_ERR) || \n        (PollReadFd[0].revents & POLLERR))\n    #endif\n    {\n        retVal = RTIOSTREAM_ERROR;\n    }\n\n    *outPending = (pending==1) && (retVal == RTIOSTREAM_NO_ERROR);\n    return(retVal);\n\n} /* end socketDataPending */ \n\n/* Function: initialUDPServerRecvfrom =====================================================\n * Abstract:\n *  Reads data from the client via \"recvfrom\" into the UDP packet buffer.\n *  The client sockaddr is returned via clientSA and clientSALen.\n *\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR is returned on\n *  failure.\n */\nstatic int initialUDPServerRecvfrom(ConnectionData * connection,\n                                    struct sockaddr * clientSA,\n                                    rtiostream_socklen_t * clientSALen) {\n   int nRead;\n   int retVal;\n   UDPPacketBuffer * udpPacketBuffer = connection->udpData->recvBuffer;\n   /* reset */ \n   resetUDPPacketBuffer(udpPacketBuffer);\n   /* initialize ahead of call to recvfrom */\n   *clientSALen = sizeof(*clientSA);\n   /* 1. read into UDP buffer from the listenSock and get sockaddr of the client\n    * 2. cast to int is okay here. maxPacketSize is an int, capped to UDP_MAX_PACKET_SIZE\n    *    which is less than INT_MAX\n    */\n   nRead = (int)recvfrom(connection->serverData->listenSock,\n                         udpPacketBuffer->dataPtr,\n                         (size_t)connection->udpData->maxPacketSize,\n                         0U,\n                         clientSA,\n                         clientSALen);\n\n   if (nRead == SOCK_ERR) {\n      retVal = RTIOSTREAM_ERROR;\n   } else {\n      /* set dataAvail */\n      udpPacketBuffer->dataAvail = nRead;\n      /* handle optional sequence number */\n      retVal = processUDPRecvSeqNum(connection);\n   }\n   return retVal;\n}\n\n/* Function: processUDPRecvSeqNum =====================================================\n * Abstract:\n *  Processes sequence numbers in received UDP datagrams.\n *\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR is returned on\n *  failure.\n */\nstatic int processUDPRecvSeqNum(ConnectionData * connection) {\n   int retVal = RTIOSTREAM_NO_ERROR;\n   if (connection->udpData->isUsingSeqNum) {\n      UDPPacketBuffer * udpPacketBuffer = connection->udpData->recvBuffer;\n      /* process sequence number */\n      udpSeqNum_T recvSeqNum;\n      if (udpPacketBuffer->dataAvail < UDP_SEQ_NUM_SIZE) {\n         printf(\"No receive sequence number found.\\n\");\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      /* read sequence number from the buffer \n       *\n       * sequence number is always transmitted / received in \n       * host Endian */\n      memcpy(&recvSeqNum,\n            udpPacketBuffer->dataPtr,\n            UDP_SEQ_NUM_SIZE);\n      udpPacketBuffer->dataPtr += UDP_SEQ_NUM_SIZE;\n      udpPacketBuffer->dataAvail -= UDP_SEQ_NUM_SIZE;\n      if (connection->verbosity) {\n        printf(\"Received UDP packet with sequence number: %u\\n\", recvSeqNum);\n      }\n      if (connection->udpData->resetExpectedRecvSeqNum) {\n         /* reset the expected sequence number */\n         connection->udpData->expectedRecvSeqNum = recvSeqNum + 1;\n         connection->udpData->resetExpectedRecvSeqNum = 0;\n      }\n      else {\n         /* compare with expected receive seq num */\n         if (recvSeqNum != connection->udpData->expectedRecvSeqNum) {\n            printf(\"UDP packet sequence number mismatch. Expected #: %u, Actual #: %u\\n\", \n                  connection->udpData->expectedRecvSeqNum, recvSeqNum);\n            retVal = RTIOSTREAM_ERROR;\n         } \n         else {\n            /* increment expected receive seq num */\n            connection->udpData->expectedRecvSeqNum++;\n         }\n      }\n   }\n   return retVal;\n}\n\n/* Function: socketDataGet =====================================================\n * Abstract:\n *  Attempts to gets the specified number of bytes from the specified socket.\n *  The number of bytes read is returned via the 'sizeRecvd' parameter.\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR is returned on\n *  failure.\n *\n * NOTES:\n *  o it is not an error for 'sizeRecvd' to be returned as 0\n *  o this function blocks if no data is available\n */\nstatic int socketDataGet(ConnectionData * connection,\n    char          *dst,\n    const size_t   size,\n    size_t        *sizeRecvd)\n{\n    int nRead = 0;\n    int retVal = RTIOSTREAM_NO_ERROR; \n    /* Ensure size is not out of range for socket API recv function */\n    int sizeLim = (int) MIN(size, INT_MAX);\n\n    if (connection->protocol == TCP_PROTOCOL) {\n        nRead = (int)recv(connection->sock, dst, (size_t)sizeLim, 0U);\n       if (nRead == SOCK_ERR) {\n          retVal = RTIOSTREAM_ERROR;\n       } else {\n          retVal = RTIOSTREAM_NO_ERROR;\n       }\n    }\n    else { \n       UDPPacketBuffer * udpPacketBuffer = connection->udpData->recvBuffer;\n       /* receive more data in to the buffer if required */\n       if (udpPacketBuffer->dataAvail == 0) {         \n          /* reset */ \n          resetUDPPacketBuffer(udpPacketBuffer);\n          /* read into buffer */\n          nRead = (int)recv(connection->sock,\n                            udpPacketBuffer->dataPtr,\n                            (size_t)connection->udpData->maxPacketSize,\n                            0U);\n          \n          if (nRead == SOCK_ERR) {\n             retVal = RTIOSTREAM_ERROR;\n          } else {\n             udpPacketBuffer->dataAvail = nRead;\n             /* handle optional sequence number */\n             retVal = processUDPRecvSeqNum(connection);             \n             if (retVal == RTIOSTREAM_ERROR) {\n                return retVal;\n             }\n          }\n       }\n       /* get data from the buffer */\n       /* for the special case where we request a  */\n       /* size of 0 bytes, return the whole buffer */\n       if (udpPacketBuffer->dataAvail) {\n          if (size == 0) {\n            nRead = udpPacketBuffer->dataAvail;\n          } else {\n            nRead = MIN(udpPacketBuffer->dataAvail, sizeLim);\n          }\n          memcpy(dst, (void *) udpPacketBuffer->dataPtr, (size_t)nRead);\n          udpPacketBuffer->dataAvail -= nRead;\n          udpPacketBuffer->dataPtr += nRead;\n       }\n    }\n\n    if (retVal!=RTIOSTREAM_ERROR) {\n        *sizeRecvd = (size_t) nRead;\n    }\n\n    return retVal;\n} /* end socketDataGet */ \n\n\n/* Function: socketDataSet =====================================================\n * Abstract:\n *  Utility function to send data via the specified socket\n */\nstatic int socketDataSet(\n    ConnectionData * connection,\n    const void *src,\n    const size_t size,\n    size_t *sizeSent)\n{\n    int nSent;    \n    int retVal = RTIOSTREAM_NO_ERROR;\n    const void *sendSrc = src;    \n\n    /* Ensure size is not out of range for socket API send function */\n    int sizeLim = (int) MIN(size, INT_MAX);\n\n    if (connection->protocol == UDP_PROTOCOL) {\n       /* limit sends according to max packet size */\n       int maxPacketSize = connection->udpData->maxPacketSize;\n       if (connection->udpData->isUsingSeqNum) {          \n          int transferAmount;\n          UDPPacketBuffer * udpPacketBuffer = connection->udpData->sendBuffer;\n          /* need to apply sequence number and then increment it */\n          resetUDPPacketBuffer(udpPacketBuffer); \n          /* set data src */          \n          sendSrc = udpPacketBuffer->dataPtr;\n          /* add sequence number to the buffer \n           *\n           * sequence number is always transmitted / received in \n           * host Endian */\n          memcpy(udpPacketBuffer->dataPtr, \n                 &connection->udpData->sendSeqNum,\n                 UDP_SEQ_NUM_SIZE);\n          udpPacketBuffer->dataPtr += UDP_SEQ_NUM_SIZE;\n          udpPacketBuffer->dataAvail += UDP_SEQ_NUM_SIZE;                \n          /* copy the data - don't overflow the packet buffer */\n          transferAmount = MIN(sizeLim, maxPacketSize - udpPacketBuffer->dataAvail);\n          memcpy(udpPacketBuffer->dataPtr,\n                 src, \n                 (size_t)transferAmount);\n          udpPacketBuffer->dataAvail += transferAmount;                                   \n          sizeLim = udpPacketBuffer->dataAvail;\n       }\n       else {\n          sizeLim = MIN(maxPacketSize, sizeLim);\n       }\n    }\n\n    nSent = (int)send(connection->sock, (send_buffer_t)sendSrc, (size_t)sizeLim, 0);\n    if (nSent == SOCK_ERR) {\n        retVal = RTIOSTREAM_ERROR;\n    } else { \n        if ((connection->protocol == UDP_PROTOCOL) &&\n            (connection->udpData->isUsingSeqNum) && \n            (nSent > 0)) {\n           if (nSent < (int) UDP_SEQ_NUM_SIZE) {\n              /* expected the sequence number to have transmitted */\n              retVal = RTIOSTREAM_ERROR;\n              return retVal;\n           }\n           else {\n              if (connection->verbosity) {\n                 printf(\"Sent UDP packet with sequence number: %u\\n\", connection->udpData->sendSeqNum);\n              }\n              /* increment sequence number */\n              connection->udpData->sendSeqNum++;\n              nSent -= UDP_SEQ_NUM_SIZE;\n           }          \n        }\n        *sizeSent = (size_t)nSent;\n    }\n\n    return retVal;\n}\n\n/* Function: serverStreamRecv =================================================\n * Abstract:\n *  Send data from the server-side\n */\nstatic int serverStreamRecv( \n    ConnectionData * connection, \n    void * dst,\n    size_t size,\n    size_t * sizeRecvd)\n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    *sizeRecvd = 0;\n\n    if (connection->sock == INVALID_SOCKET) {\n       /* Attempt to open connection */\n       serverAcceptSocket(connection);\n    }\n\n    if (connection->sock != INVALID_SOCKET) {\n        int pending;\n        if (connection->blockingRecvTimeout != BLOCKING_RECV_TIMEOUT_NEVER) {\n           /* only call costly \"select\" if necessary */\n           retVal = socketDataPending(connection->sock, \n                                      connection,\n                                      &pending, \n                                      connection->blockingRecvTimeout);\n        }\n        else {\n           /* block in \"recv\" if necessary */\n           pending = 1;\n        }\n\n        if ( (pending !=0) && (retVal==RTIOSTREAM_NO_ERROR) && (size>0) ) {\n           \n            retVal = socketDataGet(connection, (char *)dst, size, sizeRecvd);\n            \n            if (*sizeRecvd == 0) {\n                \n                if (errno == RTIOSTREAM_ECONNRESET) {\n                    /* If we are closing the connection and we received this\n                     * error, it means the other side of the connection was\n                     * already closed.  Since we are expecting this, we can\n                     * ignore this particular error.\n                     */\n                    retVal = RTIOSTREAM_NO_ERROR;\n                } else {\n                    /* Connection closed gracefully by client */\n                }\n\n                close(connection->sock);\n                connection->sock = INVALID_SOCKET;\n            }\n        }\n        \n        if ( retVal == RTIOSTREAM_ERROR ) {\n            close(connection->sock);\n            connection->sock = INVALID_SOCKET;\n        }\n    }\n\n    return retVal;\n}\n\n/* Function: serverOpenSocket =================================================\n * Abstract:\n *  Opens the listening socket to be used for accepting an incoming connection.\n */\nstatic SOCKET serverOpenSocket(int port, char * serverInfoFile, CommsProtocol protocol, int udpSendBufSize, int udpRecvBufSize)\n{\n\n    struct sockaddr_in serverAddr;\n    int sockStatus;\n    rtiostream_socklen_t sFdAddSize     = (rtiostream_socklen_t) sizeof(struct sockaddr_in);\n    SOCKET lFd;\n    int option;     \n\n    /*\n    * Create a TCP or UDP based socket.\n    */\n    memset((void *) &serverAddr,0,(size_t)sFdAddSize);\n    serverAddr.sin_family      = AF_INET;\n    serverAddr.sin_port        = htons((unsigned short int) port);\n    #ifdef USE_LOCALHOST\n    serverAddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n    #else\n    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);\n    #endif\n\n    if (protocol == TCP_PROTOCOL) {\n        lFd = socket(AF_INET, SOCK_STREAM, 0);\n    }\n    else {\n        lFd = socket(AF_INET, SOCK_DGRAM, 0);\n    }\n    \n    if (lFd == INVALID_SOCKET) {\n        printf(\"socket() call failed.\\n\");\n    } else {\n        /*\n        * Listening socket should always use the SO_REUSEADDR option\n        * (\"Unix Network Programming - Networking APIs:Sockets and XTI\",\n        *   Volume 1, 2nd edition, by W. Richard Stevens).\n        */\n        option = 1;\n        sockStatus = \n            setsockopt(lFd,SOL_SOCKET,SO_REUSEADDR,(char*)&option,sizeof(option));\n        if (sockStatus == SOCK_ERR) {\n            printf(\"setsocketopt() call failed.\\n\");\n            close(lFd);\n            lFd = INVALID_SOCKET;\n        }\n        if (protocol == TCP_PROTOCOL)\n        {     \n            if (lFd != INVALID_SOCKET)\n            {\n                /* Disable Nagle's Algorithm*/ \n                option = 1;\n                sockStatus = \n                    setsockopt(lFd,IPPROTO_TCP,TCP_NODELAY,(char*)&option,sizeof(option));\n                if (sockStatus == SOCK_ERR) { \n                    printf(\"setsocketopt() TCP_NODELAY call failed.\\n\");\n                    close(lFd); \n                    lFd = INVALID_SOCKET; \n                }\n            }\n        } \n        if (protocol == UDP_PROTOCOL)\n        {\n            if (lFd != INVALID_SOCKET)\n            {\n\n                /* increase the UDP socket send size to increase the \n                * transfer rate */\n                sockStatus = \n                    setsockopt(lFd, SOL_SOCKET, SO_SNDBUF,(char*)&udpSendBufSize, sizeof(int));\n                if (sockStatus == SOCK_ERR) { \n                    printf(\"setsocketopt() SO_SNDBUF call failed.\\n\");\n                    close(lFd); \n                    lFd = INVALID_SOCKET; \n                }   \n            }\n\n            if (lFd != INVALID_SOCKET)\n            {\n                /* increase the UDP socket receive size to decrease the \n                * possibility of buffer overflow */\n                sockStatus = \n                    setsockopt(lFd, SOL_SOCKET, SO_RCVBUF,(char*)&udpRecvBufSize, sizeof(int));\n                if (sockStatus == SOCK_ERR) { \n                    printf(\"setsocketopt() SO_RCVBUF call failed.\\n\");\n                    close(lFd); \n                    lFd = INVALID_SOCKET; \n                } \n            }\n        }\n    }\n\n    if (lFd != INVALID_SOCKET) {\n        sockStatus = bind(lFd, (struct sockaddr *) &serverAddr, sFdAddSize);\n        if (sockStatus == SOCK_ERR) {\n            printf(\"bind() call failed: %s\\n\", strerror(errno));\n            close(lFd);\n            lFd = INVALID_SOCKET;\n        }\n    }\n\n    if (lFd != INVALID_SOCKET) {\n        if (port == 0) {\n            /* port 0 specifies dynamic free port allocation\n            * reuse serverAddr to store the actual address / port */\n            sockStatus = getsockname(lFd, (struct sockaddr *) &serverAddr, &sFdAddSize);           \n            if (sockStatus == SOCK_ERR) {\n                fprintf(stderr,\"getsockname() call failed: %s\\n\", strerror(errno));\n                close(lFd);\n                lFd = INVALID_SOCKET;               \n            } else { \n                if(serverInfoFile != NULL) {\n                    FILE* fh;\n                    uint16_T serverPortNo;\n                    int fprintfErr = 0;\n                    int fcloseErr = 0;\n                    \n                    /* Open file in append mode to save info already stored in the file*/\n                    fh = fopen(serverInfoFile,\"a\"); \n#ifdef __LCC64__\n                    /* This is needed due to an issue with LCC64, see the following geck:  g919889 */\n                    fseek ( fh, 0 , SEEK_END );\n#endif\n                    if (fh == NULL) {\n                        fprintf(stderr,\"Unable to open output file to write server port number: %s\\n\", strerror(errno));\n                        lFd = INVALID_SOCKET;\n                    }\n\n                    serverPortNo = ntohs(serverAddr.sin_port);\n                    fprintfErr = fprintf(fh, \"Server Port Number: %d\\n\", serverPortNo);\n                    if (fprintfErr < 0) {\n                        fprintf(stderr,\"Server port number is: %d\\nUnable to write server port number to output file: %s\\n\",\n                                serverPortNo, strerror(errno));\n                        lFd = INVALID_SOCKET;\n                    }\n                    \n                    fcloseErr = fclose(fh);\n                    if (fcloseErr == EOF) {\n                        fprintf(stderr,\"Server port number is: %d\\nUnable to close output file after writing server port number: %s\\n\", \n                                serverPortNo ,strerror(errno));\n                        lFd = INVALID_SOCKET;\n                    }\n                    \n                } else {\n                    /* write the server port number to stdout */\n                    SERVER_PORT_PRINTF(\"Server Port Number: %d\\n\", ntohs(serverAddr.sin_port));\n                }\n            }                 \n        }\n    }\n    if (protocol == TCP_PROTOCOL) {\n        if (lFd != INVALID_SOCKET) {\n            sockStatus = listen(lFd, 2);\n            if (sockStatus == SOCK_ERR) {\n                printf(\"listen() call failed.\\n\");\n                close(lFd);\n                lFd = INVALID_SOCKET;\n            }\n        }\n    }\n    return lFd;\n}\n/* Function: serverAcceptSocket =================================================\n * Abstract:\n *  Called when the target is not currently connected to the host, this \n *  function attempts to open the connection.  \n *\n *  In the case of sockets, this is a passive operation in that the host\n *  initiates contact, the target simply listens for connection requests.\n *\n * NOTES:\n \n * Blocks according to blockingRecvTimeout. When\n * polling, there may be no open requests pending.  In this case, this\n * function returns without making a connection; this is not an error.\n */\nstatic void serverAcceptSocket(ConnectionData * connection)\n{\n   struct sockaddr_in clientAddr;\n   rtiostream_socklen_t     sFdAddSize     = sizeof(struct sockaddr_in);\n   SOCKET  cFd            = INVALID_SOCKET;\n   int error             = RTIOSTREAM_NO_ERROR;\n   int pending;    \n\n   /* Check that the listening socket is still valid and open a new socket if\n    * not */\n   if (connection->serverData->listenSock == INVALID_SOCKET) {\n      connection->serverData->listenSock = serverOpenSocket(connection->serverData->port,\n            connection->serverData->serverInfoFile, \n            connection->protocol,\n            connection->udpSendBufSize, connection->udpRecvBufSize);\n   }\n\n   /* pass listenSock rather than sock */\n   error = socketDataPending(connection->serverData->listenSock, \n         connection,\n         &pending, \n         connection->blockingRecvTimeout);\n\n   if ( (pending > 0) && (error==RTIOSTREAM_NO_ERROR) ) {\n      if (connection->protocol == TCP_PROTOCOL) {\n         /*\n          * Wait to accept a connection on the comm socket.\n          */\n         cFd = accept(connection->serverData->listenSock, \n                     (struct sockaddr *)&clientAddr,\n                     &sFdAddSize);\n\n         if (cFd == INVALID_SOCKET) {\n            printf(\"accept() for comm socket failed.\\n\");\n            error = RTIOSTREAM_ERROR;\n         } \n\n         if (error == RTIOSTREAM_ERROR) {\n            close(connection->serverData->listenSock);\n            connection->serverData->listenSock = INVALID_SOCKET;\n         } \n      }\n      else {\n         /* UDP - data is pending */\n         struct sockaddr clientSA;\n         rtiostream_socklen_t clientSALen;\n         /* new connection, make sure we reset expectedRecvSeqNum, \n          * if sequence numbers are in use */\n         connection->udpData->resetExpectedRecvSeqNum = 1;\n         /* Do the initial UDP server \"recvfrom\" to get the \n          * client sockaddr.   Data read will be placed \n          * ready in the UDP packet buffer. */\n         error = initialUDPServerRecvfrom(connection, &clientSA, &clientSALen); \n         if (error == RTIOSTREAM_ERROR) {\n            close(connection->serverData->listenSock);\n            connection->serverData->listenSock = INVALID_SOCKET;\n            printf(\"initialUDPServerRecvfrom() failed.\\n\");\n         }\n         else {\n            /* connect exclusively to the client so we no longer\n             * have to use recvfrom / sendto */\n            if (connect(connection->serverData->listenSock, \n                        &clientSA, \n                        clientSALen) == SOCK_ERR) {\n               close(connection->serverData->listenSock);\n               connection->serverData->listenSock = INVALID_SOCKET;\n               printf(\"Server connect() failed.\\n\");\n            } \n         } \n         /* for UDP, the socket and listening socket are the same */\n         cFd = connection->serverData->listenSock;\n      }\n   }\n   /* set sock */\n   connection->sock = cFd;\n} \n\n\n/* Function: nameLookup =======================\n * Lookup target network name.\n */\n#if (!defined(VXWORKS))\nstatic rtiostream_in_addr_t nameLookup(char * hostName) {\n\n    struct hostent * hp = NULL;\n    struct in_addr * iaddr = NULL;\n    rtiostream_in_addr_t addr = INADDR_NONE;\n\n    /*\n     * Default to localhost if hostname not specified.\n     */\n    if (hostName == NULL) {\n        static char localhost[] = \"localhost\";\n        hostName = localhost;\n    }\n    \n    /*\n     * See if the address is an IPV4 dot separated address:\n     */\n    addr = inet_addr(hostName);\n\n    if (addr == INADDR_NONE) {\n        /* Since the address is not an IPV4 dot separated address, \n         * do a name lookup to get this: \n         */\n        hp = gethostbyname(hostName);\n        if (hp == NULL) {\n          printf(\"gethostbyname() call failed.\\n\");\n  \t  addr = INADDR_NONE;\n        } else {\n          iaddr = (struct in_addr *) hp->h_addr;\n          addr = iaddr->s_addr;\n        }\n    }\n    return(addr);\n}\n#endif\n\n/* Function: processArgs ====================================================\n * Abstract:\n *  Process the arguments specified by the user when opening the rtIOStream.\n *      \n *  If any unrecognized options are encountered, ignore them.\n *\n * Returns zero if successful or RTIOSTREAM_ERROR if \n * an error occurred.\n *\n *  o IMPORTANT!!!\n *    As the arguments are processed, their strings should be NULL'd out in\n *    the argv array. \n */\nstatic int processArgs(\n    const int         argc,\n    void            * argv[],\n    char           ** hostName, \n    unsigned int    * portNum,\n    unsigned int    * isClient,\n    int             * isBlocking,\n    int             * recvTimeout, \n    char           ** serverInfoFile, \n    CommsProtocol   * protocol, \n    int             * maxPacketSize, \n    VerbosityLevel  * verbosity, \n    int             * isUsingSeqNum,\n    int             * udpSendBufSize,\n    int             * udpRecvBufSize)\n{\n    int        retVal    = RTIOSTREAM_NO_ERROR;\n    int        count           = 0;\n\n    while(count < argc) {\n        const char *option = (char *)argv[count];\n        count++;\n\n        if (option != NULL) {\n\n            if ((strcmp(option, \"-hostname\") == 0) && (count != argc)) {\n\n                *hostName = (char *)argv[count];\n                count++;\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n\n            } else if ((strcmp(option, \"-port\") == 0) && (count != argc)) {\n                char       tmpstr[2];\n                int itemsConverted;\n                const char *portStr = (char *)argv[count];\n\n                count++;     \n                \n                itemsConverted = sscanf(portStr,\"%d%1s\", (int *) portNum, tmpstr);\n                if ( (itemsConverted != 1) || \n                     ( ((*portNum != 0) && (*portNum < 255)) || (*portNum > 65535)) \n                    ) {\n                    \n                    retVal = RTIOSTREAM_ERROR;\n                } else {\n\n                    argv[count-2] = NULL;\n                    argv[count-1] = NULL;\n                }           \n                \n            } else if ((strcmp(option, \"-client\") == 0) && (count != argc)) {\n                \n                *isClient = ( strcmp( (char *)argv[count], \"1\") == 0 );\n\n                count++;\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n\n            } else if ((strcmp(option, \"-blocking\") == 0) && (count != argc)) {\n                \n                *isBlocking = ( strcmp( (char *)argv[count], \"1\") == 0 );\n\n                count++;\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n\n            } else if ((strcmp(option, \"-verbose\") == 0) && (count != argc)) {\n                int verbosityVal;\n                int itemsConverted;\n                const char *verbosityStr = (char *)argv[count];\n                count++;\n                itemsConverted = sscanf(verbosityStr,\"%d\", &verbosityVal);\n\n                if ((itemsConverted != 1) || (verbosityVal < 0)) {\n                    retVal = RTIOSTREAM_ERROR;\n                } else {\n                    *verbosity = (VerbosityLevel) verbosityVal;\n                    argv[count-2] = NULL;\n                    argv[count-1] = NULL;\n               }\n\n            } else if ((strcmp(option, \"-recv_timeout_secs\") == 0) && (count != argc)) {\n                char       tmpstr[2];\n                int itemsConverted;\n                const char *timeoutSecsStr = (char *)argv[count];\n\n                count++;     \n                \n                itemsConverted = sscanf(timeoutSecsStr,\"%d%1s\", (int *) recvTimeout, tmpstr);\n                if ( itemsConverted != 1 ) {\n                    retVal = RTIOSTREAM_ERROR;\n                } else {\n\n                    argv[count-2] = NULL;\n                    argv[count-1] = NULL;\n                }           \n\n            } else if((strcmp(option, \"-server_info_file\") == 0) && (count != argc)) {\n                *serverInfoFile= (char *) argv[count];\n                \n                count++;\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n            } else if ((strcmp(option, \"-protocol\") == 0) && (count != argc)) {\n              char * protocolStr = (char *) argv[count];\n              count++;\n              argv[count-2] = NULL;\n              argv[count-1] = NULL;\n              /* initialize dependent properties */\n              *isUsingSeqNum = 0;\n              /* process protocolStr */\n              if (strcmp(protocolStr, TCP_PROTOCOL_STRING) == 0) {\n                 *protocol = TCP_PROTOCOL;                \n              }\n              else if (strcmp(protocolStr, UDP_PROTOCOL_STRING) == 0) {\n                 *protocol = UDP_PROTOCOL;\n              }\n              else if (strcmp(protocolStr, UDP_PACKET_LOSS_DETECTON_PROTOCOL_STRING) == 0) {\n                 *protocol = UDP_PROTOCOL;\n                 /* enable sequence number protocol */\n                 *isUsingSeqNum = 1;\n              }\n              else {\n                 /* unrecognized protocol */\n                 retVal = RTIOSTREAM_ERROR;\n              }            \n            } else if ((strcmp(option, \"-udpmaxpacketsize\") == 0) && (count != argc)) {\n               char       tmpstr[2];\n               int itemsConverted;\n               const char *maxUPDSizeStr = (char *)argv[count];\n\n               count++;     \n\n               itemsConverted = sscanf(maxUPDSizeStr,\"%d%1s\", maxPacketSize, tmpstr);\n               if ( itemsConverted != 1 ) {\n                  retVal = RTIOSTREAM_ERROR;\n               } else {\n                  argv[count-2] = NULL;\n                  argv[count-1] = NULL;\n               } \n             }else if ((strcmp(option, \"-udpsendbuffersize\") == 0) && (count != argc)) {\n               char       tmpstr[2];\n               int itemsConverted;\n               const char *udpSendBufSizeStr = (char *)argv[count];\n\n               count++;     \n\n               itemsConverted = sscanf(udpSendBufSizeStr,\"%d%1s\", udpSendBufSize, tmpstr);\n               if ( itemsConverted != 1 ) {\n                  retVal = RTIOSTREAM_ERROR;\n               } else {\n                  argv[count-2] = NULL;\n                  argv[count-1] = NULL;\n               } \n           }else if ((strcmp(option, \"-udpreceivebuffersize\") == 0) && (count != argc)) {\n               char       tmpstr[2];\n               int itemsConverted;\n               const char *udpRecvBufSizeStr = (char *)argv[count];\n\n               count++;     \n\n               itemsConverted = sscanf(udpRecvBufSizeStr,\"%d%1s\", udpRecvBufSize, tmpstr);\n               if ( itemsConverted != 1 ) {\n                  retVal = RTIOSTREAM_ERROR;\n               } else {\n                  argv[count-2] = NULL;\n                  argv[count-1] = NULL;\n               } \n            } else {\n                /* issue a warning for the unexpected argument: exception \n                 * is first argument which might be the executable name (\n                 * SIL/PIL and extmode use-cases). */\n                if ((count!=1) || (strncmp(option, \"-\", 1)==0)) {\n                    printf(\"The argument '%s' passed to rtiostream_tcpip is \"\n                            \"not valid and will be ignored.\\n\", option);\n                }\n            }\n        }\n    }\n    return retVal;\n}\n\n/* Function: clientOpenSocket =================================================\n * Abstract:\n *  Open a connection as Client\n */\n#if (!defined(VXWORKS))\nstatic SOCKET clientOpenSocket(char * hostName, unsigned int portNum, CommsProtocol protocol, int udpSendBufSize, int udpRecvBufSize) {\n    \n    struct sockaddr_in sa;\n    rtiostream_in_addr_t addr = INADDR_NONE;\n    int errStatus = RTIOSTREAM_NO_ERROR;\n    SOCKET cSock = INVALID_SOCKET;\n\n    addr = nameLookup(hostName);\n\n    if (addr!=INADDR_NONE) {\n        \n         sa.sin_addr.s_addr = addr;\n         sa.sin_family = AF_INET; /*hp->h_addrtype;*/\n         sa.sin_port   = htons((unsigned short) portNum);\n\n        /*\n         * Create the sockets & make connections.\n         */\n        if (protocol == TCP_PROTOCOL) {\n           cSock = socket(PF_INET,SOCK_STREAM,0);\n        } \n        else {\n           cSock = socket(PF_INET,SOCK_DGRAM,0);\n        }\n        \n        if (cSock == INVALID_SOCKET) {\n            errStatus = RTIOSTREAM_ERROR;\n            printf(\"socket() call failed for comm socket.\\n\");\n        }\n    } else {\n      errStatus = RTIOSTREAM_ERROR;\n    }\n \n    if (protocol == UDP_PROTOCOL)\n    {\n        if (errStatus!=RTIOSTREAM_ERROR)\n        {\n            /* increase the UDP socket send size to increase the \n            * transfer rate */\n           int sockStatus = \n                setsockopt(cSock, SOL_SOCKET, SO_SNDBUF,(char*)&udpSendBufSize, sizeof(int));\n           if (sockStatus == SOCK_ERR) { \n              printf(\"setsocketopt() SO_SNDBUF call failed.\\n\");\n              cSock = INVALID_SOCKET;\n              errStatus = RTIOSTREAM_ERROR;\n           }    \n        }\n        if (errStatus!=RTIOSTREAM_ERROR)\n        {\n            /* increase the UDP socket receive size to decrease the \n            * possibility of buffer overflow */\n           int sockStatus = \n                setsockopt(cSock, SOL_SOCKET, SO_RCVBUF,(char*)&udpRecvBufSize, sizeof(int));\n           if (sockStatus == SOCK_ERR) { \n              printf(\"setsocketopt() SO_RCVBUF call failed.\\n\");\n              cSock = INVALID_SOCKET;\n              errStatus = RTIOSTREAM_ERROR;\n           } \n       }\n    }\n\n    if (errStatus!=RTIOSTREAM_ERROR) {\n        if (connect(cSock, (struct sockaddr *)&sa, sizeof(sa)) == SOCK_ERR) {\n            char tmp[1024];\n\n            SPRINTF(tmp,\n                    \"Attempting to establish connection with hostname '%s' \"\n                    \"through port %d.\\n\", \n                    hostName,\n                    ntohs(sa.sin_port));\n            cSock = INVALID_SOCKET;\n            printf(\"%s\",tmp);\n        } \n    }\n\n    return cSock;\n}\n#endif\n\n/* Function: waitForClientClose =============================================\n * Abstract:\n *\n * Allow the client to close its end of the socket connection before the server\n * closes its own socket.\n *\n * The server will receive any outstanding data on the socket.   When the server\n * receives 0 bytes, it indicates that it has acknowledged that the client \n * is closing its socket (this is essential for the client to complete\n * closing its socket without error) or that it timed out waiting for the client to \n * close its socket.\n *\n */\nstatic int waitForClientClose(ConnectionData * connection) {\n   int retVal = RTIOSTREAM_NO_ERROR;\n#define TMP_BUF_SIZE (40)\n   char * tmpBuf[TMP_BUF_SIZE];\n   size_t numRecvd;          \n   /* cache the original blockingRecvTimeout */\n   int savedBlockingRecvTimeout = connection->blockingRecvTimeout;      \n   /* wait time for client to close its socket */\n   connection->blockingRecvTimeout = BLOCKING_RECV_TIMEOUT_SOCK_SHUTDOWN;\n   do {         \n      retVal = serverStreamRecv(connection, (void *) tmpBuf, TMP_BUF_SIZE, &numRecvd);\n   } while ((numRecvd > 0) && (retVal == RTIOSTREAM_NO_ERROR));\n   /* restore blockingRecvTimeout */\n   connection->blockingRecvTimeout = savedBlockingRecvTimeout;\n#undef TMP_BUF_SIZE\n   return retVal;\n}\n\n/***************** VISIBLE FUNCTIONS ******************************************/\n\n/* Function: rtIOStreamOpen =================================================\n * Abstract:\n *  Open the connection with the target.\n */\nint rtIOStreamOpen(int argc, void * argv[])\n{\n    char               *xHostName = NULL; /* default */\n    char               *serverInfoFile = NULL; /* default */\n    unsigned int        xPortNum     = (SERVER_PORT_NUM); /* default */\n    unsigned int        isClient = 0; /* default */\n    CommsProtocol       protocol = DEFAULT_PROTOCOL;\n    int                 isBlockingRecv = EXT_BLOCKING; /* default */\n    int                 blockingRecvTimeout = DEFAULT_BLOCKING_RECV_TIMEOUT; /* rogue value */\n    int                 maxPacketSize = DEFAULT_MAX_UDP_PACKET_SIZE;\n    VerbosityLevel      verbosity = DEFAULT_VERBOSITY;\n    int                 isUsingSeqNum = DEFAULT_IS_USING_SEQ_NUM;\n    int                 udpSendBufSize = DEFAULT_UDP_SOCKET_SEND_SIZE_REQUEST;\n    int                 udpRecvBufSize = DEFAULT_UDP_SOCKET_RECEIVE_SIZE_REQUEST;\n    int result = RTIOSTREAM_NO_ERROR;\n    int streamID;\n    SOCKET sock = INVALID_SOCKET;\n\n    /* determine the streamID for this new connection */\n    streamID = getConnectionID();\n    if (streamID == RTIOSTREAM_ERROR) {\n       result = RTIOSTREAM_ERROR;\n       return result;\n    }\n\n    result = processArgs(argc, argv, \n                         &xHostName, \n                         &xPortNum, \n                         &isClient, \n                         &isBlockingRecv,\n                         &blockingRecvTimeout, \n                         &serverInfoFile, \n                         &protocol, \n                         &maxPacketSize, \n                         &verbosity, \n                         &isUsingSeqNum,\n                         &udpSendBufSize,\n                         &udpRecvBufSize);\n\n    if (result == RTIOSTREAM_ERROR) {\n       return result;\n    }\n\n    if (verbosity) {\n       printf(\"rtIOStreamOpen\\n\");\n    }\n\n    if (isBlockingRecv) {\n       /* blocking: if blockingRecvTimeout has not been set, initialize to the client or\n        * server specific default */\n       if ((blockingRecvTimeout == DEFAULT_BLOCKING_RECV_TIMEOUT) ||\n           (blockingRecvTimeout < BLOCKING_RECV_TIMEOUT_10MS)) {\n          if (isClient) {\n             blockingRecvTimeout = DEFAULT_BLOCKING_RECV_TIMEOUT_SECS_CLIENT;\n          }\n          else {\n             blockingRecvTimeout = DEFAULT_BLOCKING_RECV_TIMEOUT_SECS_SERVER;\n          }\n       }\n    }\n    else {\n       /* not blocking: set the timeout to return immediately */\n       blockingRecvTimeout = BLOCKING_RECV_TIMEOUT_NOWAIT;\n    }\n\n#ifdef VXWORKS /* UDP is not supported on VxWorks */\n    if (protocol == UDP_PROTOCOL) {\n       result = RTIOSTREAM_ERROR;\n       return result;\n    }\n#endif\n\n#ifdef _WIN32\n    {\n        WSADATA data;\n        if (WSAStartup((MAKEWORD(1,1)), &data)) {\n            result = RTIOSTREAM_ERROR;\n            printf(\"WSAStartup() call failed.\\n\");\n        }\n    }\n#endif\n\n    if (result != RTIOSTREAM_ERROR) { /* polyspace DEFECT:USELESS_IF [Not a defect:Unset] \"Needed for Windows\" */\n        if (isClient == 1) {\n#if (!defined(VXWORKS)) /* Client side connection not supported on VxWorks */\n            sock = clientOpenSocket(xHostName, xPortNum, protocol,udpSendBufSize,udpRecvBufSize);\n            if (sock == INVALID_SOCKET) {\n            result = RTIOSTREAM_ERROR;\n            }\n#endif\n        } else {           \n            sock = serverOpenSocket((int)xPortNum, serverInfoFile, protocol,udpSendBufSize,udpRecvBufSize);            \n            if (sock == INVALID_SOCKET) {\n                result = RTIOSTREAM_ERROR;\n            }\n        }\n    }\n\n    if (result != RTIOSTREAM_ERROR) {\n       int isServer;\n       if (isClient == 1) {\n          isServer = 0;   \n       }\n       else {\n          isServer = 1;\n       }\n       result = initConnectionData(streamID, \n             isServer, \n             protocol, \n             sock, \n             blockingRecvTimeout,\n             maxPacketSize, \n             (int)xPortNum, \n             serverInfoFile, \n             verbosity, \n             isUsingSeqNum,\n             udpSendBufSize,\n             udpRecvBufSize);\n    }\n    \n    if (result != RTIOSTREAM_ERROR) {\n       result = streamID;\n    }\n    else {\n       if (sock != INVALID_SOCKET) {\n          /* cleanup */\n          close(sock);\n       }\n    }\n    return result;\n}\n\n/* Function: rtIOStreamSend =====================================================\n * Abstract:\n *  Sends the specified number of bytes on the comm line. Returns the number of\n *  bytes sent (if successful) or a negative value if an error occurred. As long\n *  as an error does not occur, this function is guaranteed to set the requested\n *  number of bytes; the function blocks if tcpip's send buffer doesn't have\n *  room for all of the data to be sent\n */\nint rtIOStreamSend(\n    int streamID,\n    const void *src,\n    size_t size,\n    size_t *sizeSent)\n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    ConnectionData * connection = getConnectionData(streamID);\n    *sizeSent = 0;\n\n    if (connection == NULL) {\n       retVal = RTIOSTREAM_ERROR;\n       return retVal;\n    }\n\n    if (connection->isServer) {\n        if (connection->sock == INVALID_SOCKET) {\n            serverAcceptSocket(connection);\n        }\n\n        if (connection->sock != INVALID_SOCKET) {\n#ifndef VXWORKS\n           retVal = socketDataSet(connection, src, size, sizeSent);\n#else           \n           /*\n            * VXWORKS send prototype does not have src as const.  This suppresses\n            * the compiler warning.\n            */\n\n           retVal = socketDataSet(connection, (char *)src, size, sizeSent);\n#endif\n        }\n    } else { /* Client stream */\n        retVal = socketDataSet(connection, src, size, sizeSent);\n    }\n\n    if (connection->verbosity) {\n        if ((*sizeSent > 0) || (connection->verbosity >= VERBOSITY_LEVEL_2)) {\n            size_t currElement;\n            printf(\"rtIOStreamSend (connection id %d): size = %lu, sizeSent = %lu: \", \n                   streamID, \n                   (unsigned long) size, \n                   (unsigned long) *sizeSent);\n        \n            for (currElement = 0; currElement < *sizeSent; currElement++) {\n                printf(\"%02x \", ((const unsigned char *) src)[currElement]);\n            }\n            printf(\"\\n\");\n        }       \n    }\n\n    return retVal;\n}\n\n\n/* Function: rtIOStreamRecv ================================================\n * Abstract: receive data\n *\n */\nint rtIOStreamRecv(\n    int      streamID,\n    void   * dst, \n    size_t   size,\n    size_t * sizeRecvd) \n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    ConnectionData * connection = getConnectionData(streamID);\n\n    *sizeRecvd = 0;\n\n    if (connection == NULL) {\n       retVal = RTIOSTREAM_ERROR;\n       return retVal;\n    }\n\n    if (connection->isServer) {\n        retVal = serverStreamRecv(connection, dst, size, sizeRecvd); \n    } else { /* Client stream */\n        int pending;\n        if (connection->blockingRecvTimeout != BLOCKING_RECV_TIMEOUT_NEVER) {\n           /* only call costly \"select\" if necessary */\n           retVal = socketDataPending(connection->sock, \n                                      connection,\n                                      &pending, \n                                      connection->blockingRecvTimeout);\n        }\n        else {\n           /* block in \"recv\" if necessary */\n           pending = 1;\n        }\n        if (pending && (size>0))  {\n            retVal = socketDataGet(connection, (char *)dst, size, sizeRecvd);\n        }\n    }\n\n    if (connection->verbosity) {\n        if ((*sizeRecvd > 0 ) || (connection->verbosity >= VERBOSITY_LEVEL_2)) {\n            size_t currElement;\n            printf(\"rtIOStreamRecv (connection id %d): size = %lu, sizeRecvd = %lu: \", \n                   streamID,\n                   (unsigned long) size,\n                   (unsigned long) *sizeRecvd);\n\n            for (currElement = 0; currElement < *sizeRecvd; currElement++) {\n                printf(\"%02x \", ((const unsigned char *) dst)[currElement]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return retVal;\n}\n\n/* Function: rtIOStreamClose ================================================\n * Abstract: close the connection.\n *\n */\nint rtIOStreamClose(int streamID)\n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    ConnectionData * connection = getConnectionData(streamID);\n    if (connection == NULL) {\n       retVal = RTIOSTREAM_ERROR;\n       return retVal;\n    }\n\n    if (connection->verbosity) {\n       printf(\"rtIOStreamClose (connection id %d)\\n\", streamID);\n    }\n\n    if (connection->isServer) {\n        /* Only if the client actually made a connection */\n        if (connection->sock != INVALID_SOCKET) {\n            if (connection->protocol == TCP_PROTOCOL) {\n                /* graceful shutdown */\n                retVal = waitForClientClose(connection);\n            }\n            \n            /* close the socket */\n            close(connection->sock);\n            connection->sock = INVALID_SOCKET;\n        }\n       if (connection->protocol == TCP_PROTOCOL) {\n          /* TCP: additionally close the listening socket\n           *\n           * for UDP, sock and listenSock are the same\n           * socket - avoid closing it twice */\n          close(connection->serverData->listenSock);\n       }\n       /* set to INVALID_SOCKET for all protocol types */\n       connection->serverData->listenSock = INVALID_SOCKET;       \n    } else {\n       SOCKET cSock = connection->sock;\n       close(cSock);\n\n    }\n    freeConnectionData(connection);\n    return retVal;\n}\n\n"},{"name":"rtiostream_utils.c","type":"source","group":"legacy","path":"/Applications/MATLAB_R2024a.app/toolbox/coder/rtiostream/src/utils","tag":"","groupDisplay":"Other files","code":"/* Copyright 2012-2013 The MathWorks, Inc. */\n\n#include \"rtiostream_utils.h\"\n\n/* include rtIOStream interface to use */\n#include \"rtiostream.h\" \n\n/* TARGET_CONNECTIVITY_TESTING might be defined by some MathWorks tests for\n * testing purposes only. In this case, we force SIZE_MAX to be 4 so we \n * could test the pointer arithmetic in rtIOStreamBlockingSend and\n * rtIOStreamBlockingRecv.\n */ \n#ifdef TARGET_CONNECTIVITY_TESTING\n    #define SIZE_MAX 4\n#else\n    /* define SIZE_MAX if not already defined (e.g. by a C99 compiler) */\n    #ifndef SIZE_MAX\n        #define SIZE_MAX ((size_t)-1)\n    #endif\n#endif\n\n#ifndef MemUnit_T\n   /* External Mode */\n   typedef unsigned char IOUnit_T; \n#else\n   /* SIL/PIL */\n   #ifdef HOST_WORD_ADDRESSABLE_TESTING\n      /* rtIOStream will handle data in single byte chunks \n       *\n       * uint8_T can be > 8-bits for certain portable word sizes \n       * cases (e.g. C2000) so use native type instead */\n      typedef unsigned char IOUnit_T;\n   #else\n      /* rtIOStream will handle data in MemUnit_T size chunks */\n      typedef MemUnit_T IOUnit_T;\n   #endif\n#endif\n\n/* Blocks until all requested outgoing data is sent */\nint rtIOStreamBlockingSend(const int streamID, \n                           const void * const src, \n                           uint32_T size) {\n\n    size_t transferAmount;\n    size_t sizeSent;\n    int errorCode      = RTIOSTREAM_NO_ERROR;   \n    const IOUnit_T * srcPtr = (const IOUnit_T *) src;\n    \n    /* use a variable to avoid SIZE_MAX being treated as a constant\n     * which leads to compiler warnings for \"MIN\" on platforms where\n     * SIZE_MAX > UINT32_MAX */\n    size_t sizeMax = SIZE_MAX;\n    while (size > 0) {\n        /* support full uint32 size */\n        transferAmount = (size_t) MIN(sizeMax, size);        \n        errorCode = rtIOStreamSend(streamID,\n                                   (const void *) srcPtr,\n                                   transferAmount,\n                                   &sizeSent);\n        if (errorCode == RTIOSTREAM_ERROR) {\n            return errorCode;\n        }\n        else {            \n            size -= (uint32_T) sizeSent;\n            srcPtr += sizeSent;\n        }\n    }\n    return errorCode;\n}\n\n/* Blocks until all requested incoming data is received */\nint rtIOStreamBlockingRecv(const int streamID,\n                           void * const dst,\n                           uint32_T size) {\n\n   size_t transferAmount;\n   size_t sizeRecvd;\n   int errorCode      = RTIOSTREAM_NO_ERROR;\n   IOUnit_T * dstPtr = (IOUnit_T *) dst;\n   \n   /* use a variable to avoid SIZE_MAX being treated as a constant\n    * which leads to compiler warnings for \"MIN\" on platforms where \n    * SIZE_MAX > UINT32_MAX */\n   size_t sizeMax = SIZE_MAX;\n   while (size > 0) {\n      /* support full uint32 size */\n      transferAmount = (size_t) MIN(sizeMax, size);      \n      errorCode = rtIOStreamRecv(streamID, \n                                 (void *) dstPtr, \n                                 transferAmount, \n                                 &sizeRecvd);\n      if (errorCode == RTIOSTREAM_ERROR) {\n            return errorCode;\n      }\n      else {          \n         size -= (uint32_T) sizeRecvd;\n         dstPtr += sizeRecvd;\n      }\n   }\n   return errorCode;\n}\n\n\n"},{"name":"rtw_modelmap_utils.c","type":"source","group":"legacy","path":"/Applications/MATLAB_R2024a.app/rtw/c/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2003-2022 The MathWorks, Inc. */\n\n/**\n * Utility functions to traverse and access information from ModelMappingInfo\n *\n */\n\n#ifdef SL_INTERNAL\n\n# include \"version.h\"\n# include \"util/memmgr/memalloc.hpp\"\n# include \"util/utassert.hpp\"\n# include \"simstruct/simstruc_types.h\"\n# include \"simulinkcoder_capi/rtw_modelmap.h\"\n\n#else\n\n# include <stdlib.h>\n# include <assert.h>\n\n# define  utFree(arg)    if (arg) free(arg)\n# define  utMalloc(arg)  malloc(arg)\n# define  utAssert(exp)  assert(exp)\n\n/*\n * UNUSED_PARAMETER(x)\n *   Used to specify that a function parameter (argument) is required but not\n *   accessed by the function body.\n */\n#ifndef UNUSED_PARAMETER\n# if defined(__LCC__)\n#   define UNUSED_PARAMETER(x)  /* do nothing */\n# else\n/*\n * This is the semi-ANSI standard way of indicating that a\n * unused function parameter is required.\n */\n#   define UNUSED_PARAMETER(x) (void) (x)\n# endif\n#endif\n\n# include \"builtin_typeid_types.h\"\n/* Macro SIMPLIFIED_RTWTYPES_COMPATIBILITY declares compatibility with simplified version of\n * rtwtypes.h */\n#define SIMPLIFIED_RTWTYPES_COMPATIBILITY\n#include \"rtwtypes.h\"\n#undef SIMPLIFIED_RTWTYPES_COMPATIBILITY\n# include \"rtw_modelmap.h\"\n\n#endif\n\n#include <string.h>\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\nstatic const char_T* rtwCAPI_mallocError = \"Memory Allocation Error\";\n\n/** Function: rtwCAPI_EncodePath ===============================================\n *  Abstract:\n *     Escape all '|' characters in bpath. For examples 'aaa|b' will become\n *     'aaa~|b'. The caller is responsible for freeing the returned string\n *\n *\n * NOTE: returned string can be NULL in two cases:\n *     (1) string passed in was NULL\n *     (2) a memory allocation error occurred\n * In the second case, the caller need to report the error\n */\nchar* rtwCAPI_EncodePath(const char* path)\n{\n    char* encodedPath     = NULL;\n    size_t pathLen        = (path==NULL) ? 0:strlen(path) + 1;\n    size_t encodedPathLen = pathLen;\n    unsigned i;\n    unsigned j = 0;\n\n    if (path == NULL) return NULL;\n\n    for (i = 0; i < pathLen; ++i) {\n        if (path[i] == '|' || path[i] == '~') ++encodedPathLen;\n    }\n\n    encodedPath = (char_T*)utMalloc(encodedPathLen*sizeof(char_T));\n    if (encodedPath == NULL) return encodedPath;\n\n    for (i = 0; i < pathLen; ++i) {\n        char ch = path[i];\n        if (ch == '~' || ch == '|') encodedPath[j++] = '~';\n        encodedPath[j++] = ch;\n    }\n    utAssert(j == encodedPathLen);\n    utAssert(encodedPath[j-1] == '\\0');\n\n    return encodedPath;\n\n} /* rtwCAPI_EncodePath */\n\n/** Function: rtwCAPI_GetSigAddrFromMap ========================================\n *\n */\nvoid rtwCAPI_GetSigAddrFromMap(uint8_T      isPointer,\n                               int_T*       sigComplexity,\n                               int_T*       sigDataType,\n                               void**       sigDataAddr,\n                               int_T*       sigIdx,\n                               uint_T       mapIdx,\n                               void**       dataAddrMap)\n{\n    if (isPointer) {\n        /* Dereference pointer and cache the address */\n\n        /* Imported Pointers cannot be complex - Assert */\n        utAssert(sigComplexity[*sigIdx] != 1);\n        UNUSED_PARAMETER(sigComplexity);\n\n        /* Check for data type and dereference accordingly */\n        switch (sigDataType[*sigIdx]) {\n          case SS_DOUBLE:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((real_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_SINGLE:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((real32_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_UINT32:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((uint32_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_INT32:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((int32_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_UINT16:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((uint16_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_INT16:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((int16_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_UINT8:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((uint8_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_INT8:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((int8_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_BOOLEAN:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((boolean_T **) dataAddrMap[mapIdx]);\n            break;\n          default:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((real_T **) dataAddrMap[mapIdx]);\n            break;\n        }  /* end switch */\n    } else {\n        /* if Data is not a pointer store the address directly */\n        sigDataAddr[*sigIdx] = dataAddrMap[mapIdx];\n    }\n\n} /* rtwCAPI_GetSigAddrFromMap */\n\n\n/** Function: rtwCAPI_HasStates ================================================\n *\n */\nboolean_T rtwCAPI_HasStates(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nCMMI;\n\n    if (mmi == NULL) return(0U);\n\n    if (rtwCAPI_GetNumStates(mmi) > 0) return(1U);\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        if (rtwCAPI_HasStates(rtwCAPI_GetChildMMI(mmi,i))) return(1U);\n    }\n    return(0U);\n\n} /* rtwCAPI_HasStates */\n\n\n\n/** Function: rtwCAPI_GetNumStateRecords =======================================\n *\n */\nint_T rtwCAPI_GetNumStateRecords(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nRecs;\n    int_T nCMMI;\n\n    if (mmi == NULL) return(0);\n\n    nRecs = rtwCAPI_GetNumStates(mmi);\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        const rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        nRecs += rtwCAPI_GetNumStateRecords(cMMI);\n    }\n    return(nRecs);\n\n} /* rtwCAPI_GetNumStateRecords */\n\n\n/** Function: rtwCAPI_GetNumStateRecordsForRTWLogging ==========================\n *\n */\nint_T rtwCAPI_GetNumStateRecordsForRTWLogging(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nRecs = 0;\n    int_T nStates;\n    int_T nCMMI;\n    const rtwCAPI_States *states;\n    const rtwCAPI_DataTypeMap* dataTypeMap;\n\n    if (mmi == NULL) return(0);\n\n    nStates = rtwCAPI_GetNumStates(mmi);\n    states = rtwCAPI_GetStates(mmi);\n    dataTypeMap = rtwCAPI_GetDataTypeMap(mmi);\n\n    for (i = 0; i < nStates; ++i) {\n        if (rtwCAPI_CanLogStateToMATFile(dataTypeMap, states, i)) {\n            ++nRecs;\n        }\n    }\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        const rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        nRecs += rtwCAPI_GetNumStateRecordsForRTWLogging(cMMI);\n    }\n\n    return(nRecs);\n\n} /* rtwCAPI_GetNumStateRecordsForRTWLogging */\n\n\n/** Function: rtwCAPI_GetNumContStateRecords ===================================\n *\n */\nint_T rtwCAPI_GetNumContStateRecords(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nRecs;\n    int_T nCMMI;\n    int_T nCStateRecs;\n    const rtwCAPI_States* states;\n    const rtwCAPI_DataTypeMap* dataTypeMap;\n\n    if (mmi == NULL) return 0;\n\n    nCStateRecs = 0;\n    states      = rtwCAPI_GetStates(mmi);\n    dataTypeMap = rtwCAPI_GetDataTypeMap(mmi);\n\n    nRecs = rtwCAPI_GetNumStates(mmi);\n    for (i = 0; i < nRecs; i++) {\n        if (rtwCAPI_IsAContinuousState(states,i)) {\n            ++nCStateRecs;\n\n            /* All continuous states should be able to be logged to MAT-File\n             * so we do not need to skip any states here. */\n            utAssert(rtwCAPI_CanLogStateToMATFile(dataTypeMap, states, i));\n        }\n    }\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        const rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        nCStateRecs += rtwCAPI_GetNumContStateRecords(cMMI);\n    }\n    return nCStateRecs;\n\n} /* rtwCAPI_GetNumContStateRecords */\n\n\n/** Function: rtwCAPI_FreeFullPaths ============================================\n *\n */\nvoid rtwCAPI_FreeFullPaths(rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T   i;\n    int_T   nCMMI;\n    char_T* fullPath;\n\n    if (mmi == NULL) return;\n\n    fullPath = rtwCAPI_GetFullPath(mmi);\n    utAssert(fullPath != NULL);\n    utFree(fullPath);\n    rtwCAPI_SetFullPath(*mmi, NULL);\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        rtwCAPI_FreeFullPaths(cMMI);\n    }\n\n} /* rtwCAPI_FreeFullPaths */\n\n\n/** Function: rtwCAPI_UpdateFullPaths =========================================*\n *\n */\nconst char_T* rtwCAPI_UpdateFullPaths(rtwCAPI_ModelMappingInfo* mmi,\n                                      const char_T* path,\n                                      boolean_T isCalledFromTopModel)\n{\n    int_T         i;\n    int_T         nCMMI;\n    size_t        pathLen;\n    char_T*       mmiPath;\n    size_t        mmiPathLen;\n    char_T*       relMMIPath;\n    size_t        relMMIPathLen;\n\n    if (mmi == NULL) return NULL;\n\n    utAssert(path != NULL);\n    utAssert( rtwCAPI_GetFullPath(mmi) == NULL );\n\n    pathLen = strlen(path)+1;\n\n    if (isCalledFromTopModel) {\n        /* If called from top model - FullPath is same as path */\n        mmiPath = (char_T*)utMalloc(pathLen*sizeof(char_T));\n        (void)memcpy(mmiPath, path, pathLen*sizeof(char_T));\n    }\n    else {        \n        relMMIPath = rtwCAPI_EncodePath(rtwCAPI_GetPath(mmi));\n        if ( (relMMIPath== NULL) && (rtwCAPI_GetPath(mmi) != NULL)) {\n            return rtwCAPI_mallocError;\n        }\n        relMMIPathLen = relMMIPath ? (strlen(relMMIPath) + 1) : 0;\n        \n        mmiPathLen = pathLen + relMMIPathLen;\n        \n        mmiPath = (char_T*)utMalloc(mmiPathLen*sizeof(char_T));\n        if (mmiPath == NULL) return rtwCAPI_mallocError;\n        (void)memcpy(mmiPath, path, pathLen*sizeof(char_T));\n        utAssert(mmiPath[pathLen-1] == '\\0');\n        \n        if (relMMIPath) {\n            /* mmiPath = path + | + relMMIPath + '\\0' */\n            mmiPath[pathLen-1] = '|';\n            (void)memcpy(&(mmiPath[pathLen]),\n                         relMMIPath, relMMIPathLen*sizeof(char_T));\n            utAssert(mmiPath[mmiPathLen-1] == '\\0');\n            utFree(relMMIPath);\n        }\n    }\n    rtwCAPI_SetFullPath(*mmi, mmiPath);\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        const char_T* errstr = rtwCAPI_UpdateFullPaths(cMMI, mmiPath, 0);\n        if (errstr != NULL) return errstr;\n    }\n    return NULL;\n\n} /* rtwCAPI_UpdateFullPaths */\n\n\n/** Function: rtwCAPI_GetFullStateBlockPath ===================================\n *\n */\nchar* rtwCAPI_GetFullStateBlockPath(const char* stateBlockPath,\n                                           const char* mmiPath,\n                                           size_t      mmiPathLen,\n                                           boolean_T   crossingModel)\n{\n    char_T* blockPath          = NULL;\n    char_T* fullStateBlockPath = NULL;\n    size_t     fullStateBlockPathLen;\n\n    if (stateBlockPath == NULL) goto EXIT_POINT;\n\n    /* fullStateBlockPath = mmiPath + | + blockPath + '\\0' */\n    /* If crossing a model boundary encode, otherwise do not */\n\n    if (crossingModel) {\n        blockPath = rtwCAPI_EncodePath(stateBlockPath);\n        if (blockPath == NULL) goto EXIT_POINT;\n    } else {\n        size_t len = strlen(stateBlockPath)+1;\n        blockPath = (char*)utMalloc(len*sizeof(char));\n        if (blockPath == NULL) goto EXIT_POINT;\n        (void)strcpy(blockPath,stateBlockPath);\n    }\n    utAssert(blockPath != NULL);\n    fullStateBlockPathLen = ( (mmiPath==NULL) ?\n                              strlen(blockPath) + 1 :\n                              mmiPathLen + strlen(blockPath) + 2 );\n    fullStateBlockPath    = (char*)utMalloc(fullStateBlockPathLen*sizeof(char));\n    if (fullStateBlockPath == NULL) goto EXIT_POINT;\n\n    if (mmiPath != NULL) {\n        (void)strcpy(fullStateBlockPath, mmiPath);\n        fullStateBlockPath[mmiPathLen]   = '|';\n        fullStateBlockPath[mmiPathLen+1] =  '\\0';\n        (void)strcat(fullStateBlockPath, blockPath);\n    } else {\n        (void)strcpy(fullStateBlockPath, blockPath);\n        fullStateBlockPath[fullStateBlockPathLen-1] =  '\\0';\n    }\n    utAssert(fullStateBlockPath[fullStateBlockPathLen-1] == '\\0');\n\n  EXIT_POINT:\n    utFree(blockPath);\n    return fullStateBlockPath; /* caller is responsible for free */\n}\n\nuint_T rtwCAPI_GetStateWidth(const rtwCAPI_DimensionMap* dimMap,\n                             const uint_T*               dimArray,\n                             const rtwCAPI_States*       states,\n                             uint_T                      iState)\n{\n    uint_T mapIdx = rtwCAPI_GetStateDimensionIdx(states, iState);\n    uint_T numDims = rtwCAPI_GetNumDims(dimMap,mapIdx);\n    uint_T width = 1;\n    uint_T i = 0;\n    utAssert( numDims > 0 );\n    mapIdx = rtwCAPI_GetDimArrayIndex(dimMap, mapIdx);\n    for (i = 0; i < numDims; i++) {\n        width *= dimArray[mapIdx+i];\n    }\n    return width;\n}\n\n\n\n/** Function: rtwCAPI_GetStateRecordInfo =======================================\n *\n */\nconst char_T* rtwCAPI_GetStateRecordInfo(const rtwCAPI_ModelMappingInfo* mmi,\n                                         const char_T**    sigBlockName,\n                                         const char_T**    sigLabel,\n                                         const char_T**    sigName,\n                                         int_T*            sigWidth,\n                                         int_T*            sigDataType,\n                                         int_T*            logDataType,\n                                         int_T*            sigComplexity,\n                                         void**            sigDataAddr,\n                                         RTWLoggingFcnPtr* RTWLoggingPtrs,\n                                         boolean_T*        sigCrossMdlRef,\n                                         boolean_T*        sigInProtectedMdl,\n                                         const char_T**    sigPathAlias,\n                                         real_T*           sigSampleTime,\n                                         int_T*            sigHierInfoIdx,\n                                         uint_T*           sigFlatElemIdx,                                         \n                                         const rtwCAPI_ModelMappingInfo** sigMMI,\n                                         int_T*            sigIdx,\n                                         boolean_T         crossingModel,\n                                         boolean_T         isInProtectedMdl,\n                                         real_T*           contStateDeriv,\n                                         boolean_T         rtwLogging)\n{\n    int_T               i;\n    int_T               nCMMI;\n    int_T               nStates;\n    const char_T*       mmiPath;\n    size_t              mmiPathLen;\n    const rtwCAPI_States*  states;\n    const rtwCAPI_DimensionMap* dimMap;\n    const uint_T*       dimArray;\n    const rtwCAPI_DataTypeMap*  dataTypeMap;\n    void**              dataAddrMap;\n    RTWLoggingFcnPtr* RTWLoggingPtrsMap;\n    const char_T*       errstr = NULL;\n    uint8_T             isPointer = 0;\n\n    if (mmi == NULL) goto EXIT_POINT;\n    isInProtectedMdl = isInProtectedMdl || rtwCAPI_IsProtectedModel(mmi);\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        real_T* childContStateDeriv = NULL;\n\n        if (cMMI == NULL) continue;\n\n        if (contStateDeriv) {\n            int idx;\n\n            idx = rtwCAPI_MMIGetContStateStartIndex(cMMI);\n            if(idx == -1) continue;\n            \n            childContStateDeriv = &contStateDeriv[idx];\n        }\n        errstr = rtwCAPI_GetStateRecordInfo(cMMI,\n                                            sigBlockName,\n                                            sigLabel,\n                                            sigName,\n                                            sigWidth,\n                                            sigDataType,\n                                            logDataType,\n                                            sigComplexity,\n                                            sigDataAddr,\n                                            RTWLoggingPtrs,\n                                            sigCrossMdlRef,\n                                            sigInProtectedMdl,\n                                            sigPathAlias,\n                                            sigSampleTime,\n                                            sigHierInfoIdx,\n                                            sigFlatElemIdx,\n                                            sigMMI,\n                                            sigIdx,\n                                            0x1, /* true, */\n                                            isInProtectedMdl,\n                                            childContStateDeriv,\n                                            rtwLogging);\n        if (errstr != NULL) goto EXIT_POINT;\n    }\n\n    nStates = rtwCAPI_GetNumStates(mmi);\n    if (nStates < 1) goto EXIT_POINT;\n\n    mmiPath     = rtwCAPI_GetFullPath(mmi);\n    mmiPathLen  = (mmiPath==NULL)? 0 : strlen(mmiPath);\n    states      = rtwCAPI_GetStates(mmi);\n    dimMap      = rtwCAPI_GetDimensionMap(mmi);\n    dimArray    = rtwCAPI_GetDimensionArray(mmi);\n    dataTypeMap = rtwCAPI_GetDataTypeMap(mmi);\n    dataAddrMap = rtwCAPI_GetDataAddressMap(mmi);\n    RTWLoggingPtrsMap = rtwCAPI_GetRTWLoggingPtrsMap(mmi);\n\n    for (i = 0; i < nStates; ++i) {\n        uint_T      mapIdx;\n\n        /* If collecting continuous states, skip non-continuous states */\n        if (contStateDeriv && !rtwCAPI_IsAContinuousState(states,i)) continue;\n\n        /* For RTW logging, skip states that cannot be logged to MAT-File. */\n        if ((rtwLogging) &&\n            (rtwCAPI_CanLogStateToMATFile(dataTypeMap, states, i) == false)) continue;\n\n        /* BlockPath (caller is responsible for free) */\n        sigBlockName[*sigIdx] =\n            rtwCAPI_GetFullStateBlockPath(rtwCAPI_GetStateBlockPath(states,i),\n                                          mmiPath, mmiPathLen, crossingModel);\n        if (sigBlockName[*sigIdx] == NULL) {\n            errstr = rtwCAPI_mallocError;\n            goto EXIT_POINT;\n        }\n\n        /* Label */\n        if (rtwCAPI_IsAContinuousState(states,i)){\n            sigLabel[*sigIdx] = \"CSTATE\";\n        } else {\n            sigLabel[*sigIdx] = \"DSTATE\";\n        }\n        sigName[*sigIdx] = rtwCAPI_GetStateName(states, i);\n\n        /* Width */\n        sigWidth[*sigIdx] = rtwCAPI_GetStateWidth(dimMap, dimArray, states, i);\n\n        /* DataType and logDataType */\n        mapIdx = rtwCAPI_GetStateDataTypeIdx(states, i);\n        sigDataType[*sigIdx] = rtwCAPI_GetDataTypeSLId(dataTypeMap, mapIdx);\n        /* this mimics code in simulink.dll:DtGetDataTypeLoggingId() */\n        if (logDataType) {\n            switch (sigDataType[*sigIdx]) {\n              case SS_DOUBLE:\n              case SS_SINGLE:\n              case SS_INT8:\n              case SS_UINT8:\n              case SS_INT16:\n              case SS_UINT16:\n              case SS_INT32:\n              case SS_UINT32:\n              case SS_BOOLEAN:\n                logDataType[*sigIdx] = sigDataType[*sigIdx];\n                break;\n              case SS_ENUM_TYPE:\n                logDataType[*sigIdx] = SS_INT32;\n                break;\n              default:\n                logDataType[*sigIdx] = SS_DOUBLE;\n                break;\n            }\n        }\n\n        /* Complexity */\n        sigComplexity[*sigIdx] = rtwCAPI_GetDataIsComplex(dataTypeMap, mapIdx);\n\n        /* Data Access - Pointer or Direct*/\n        isPointer = ((uint8_T)rtwCAPI_GetDataIsPointer(dataTypeMap, mapIdx));\n\n        /* Address */\n        if (contStateDeriv) {\n            int_T csvIdx = rtwCAPI_GetContStateStartIndex(states,i);\n            utAssert(csvIdx >= 0);\n            sigDataAddr[*sigIdx] = &contStateDeriv[csvIdx];\n        } else {\n            mapIdx = rtwCAPI_GetStateAddrIdx(states,i);\n            rtwCAPI_GetSigAddrFromMap(isPointer, sigComplexity, sigDataType,\n                                      sigDataAddr, sigIdx, mapIdx, dataAddrMap);\n        }\n\n        /* Logging function pointer */\n        if (RTWLoggingPtrs) {\n            if (contStateDeriv || !RTWLoggingPtrsMap) {\n                RTWLoggingPtrs[*sigIdx] = NULL;\n            }\n            else {\n                mapIdx = rtwCAPI_GetStateAddrIdx(states, i);\n                RTWLoggingPtrs[*sigIdx] = RTWLoggingPtrsMap[mapIdx];\n            }\n        }\n\n        /* CrossingModelBoundary */\n        sigCrossMdlRef[*sigIdx] = crossingModel;\n\n        if (sigInProtectedMdl)\n        {\n            sigInProtectedMdl[*sigIdx] = isInProtectedMdl;\n        }\n\n        if (sigPathAlias && \n            rtwCAPI_GetStatePathAlias(states,i) != NULL && \n            rtwCAPI_GetStatePathAlias(states,i)[0] != '\\0') {\n            sigPathAlias[*sigIdx] =  \n                rtwCAPI_GetFullStateBlockPath(rtwCAPI_GetStatePathAlias(states,i),\n                                              mmiPath, mmiPathLen, crossingModel);\n        }\n        \n        /* Sample Time */\n        if (sigSampleTime) {\n            const rtwCAPI_SampleTimeMap* tsMap = rtwCAPI_GetSampleTimeMap(mmi);\n            int_T TID;\n            mapIdx = rtwCAPI_GetStateSampleTimeIdx(states, i);\n            TID = rtwCAPI_GetSampleTimeTID(tsMap, mapIdx);\n            if (TID >= 0) {\n                sigSampleTime[2*(*sigIdx)] =\n                    *((const real_T*)rtwCAPI_GetSamplePeriodPtr(tsMap,mapIdx));\n                sigSampleTime[2*(*sigIdx)+1] =\n                    *((const real_T*)rtwCAPI_GetSampleOffsetPtr(tsMap,mapIdx));\n            } else { /* triggered */\n                utAssert(TID==-1); \n                sigSampleTime[2*(*sigIdx)]   = -1.0;\n                sigSampleTime[2*(*sigIdx)+1] = -1.0;\n            }\n        }\n\n        /* HierInfoIdx and FlatElemIdx */\n        if (sigHierInfoIdx && sigFlatElemIdx)\n        {\n            sigHierInfoIdx[*sigIdx] = rtwCAPI_GetStateHierInfoIdx(states, i);\n            sigFlatElemIdx[*sigIdx] = rtwCAPI_GetStateFlatElemIdx(states, i);\n        }      \n\n        /* MMI for each state */\n        if (sigMMI)\n        {\n            sigMMI[*sigIdx] = mmi;\n        }  \n\n        ++(*sigIdx);\n    }\n\n  EXIT_POINT:\n    return(errstr);\n\n} /* rtwCAPI_GetStateRecordInfo */\n\n/* Signal Logging functions */\n\n/** Function: rtwCAPI_GetNumSigLogRecords ======================================\n *\n */\nint_T rtwCAPI_GetNumSigLogRecords(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nRecs;\n    int_T nCMMI;\n\n    if (mmi == NULL) return(0);\n\n    nRecs = rtwCAPI_GetNumSignals(mmi);\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        const rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        nRecs += rtwCAPI_GetNumSigLogRecords(cMMI);\n    }\n    return(nRecs);\n\n} /* rtwCAPI_GetNumSigLogRecords */\n\n\n/** Function: rtwCAPI_GetNumSigLogRecordsForRTWLogging =========================\n *\n */\nint_T rtwCAPI_GetNumSigLogRecordsForRTWLogging(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nRecs = 0;\n    int_T nSignals = 0;\n    int_T nCMMI;\n    const rtwCAPI_Signals *signals = NULL;\n    const rtwCAPI_DataTypeMap* dataTypeMap;\n\n    if (mmi == NULL) return(0);\n\n    nSignals = rtwCAPI_GetNumSignals(mmi);\n    signals = rtwCAPI_GetSignals(mmi);\n    dataTypeMap = rtwCAPI_GetDataTypeMap(mmi);\n\n    for (i = 0; i < nSignals; ++i) {\n        if (rtwCAPI_CanLogSignalToMATFile(dataTypeMap, signals, i)) {\n            ++nRecs;\n        }\n    }\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        const rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        nRecs += rtwCAPI_GetNumSigLogRecordsForRTWLogging(cMMI);\n    }\n\n    return(nRecs);\n\n} /* rtwCAPI_GetNumSigLogRecords */\n\n\n/** Function: rtwCAPI_GetSigLogRecordInfo ======================================\n *\n */\nconst char_T* rtwCAPI_GetSigLogRecordInfo(const rtwCAPI_ModelMappingInfo* mmi,\n                                          const char_T**    sigBlockName,\n                                          const char_T**    sigLabel,\n                                          int_T*            sigWidth,\n                                          int_T*            sigDataType,\n                                          int_T*            logDataType,\n                                          int_T*            sigComplexity,\n                                          void**            sigDataAddr,\n                                          boolean_T*        sigCrossMdlRef,\n                                          int_T*            sigIdx,\n                                          boolean_T         crossingModel,\n                                          boolean_T         rtwLogging)\n{\n    int_T               i;\n    int_T               nCMMI;\n    int_T               nSignals;\n    const char_T*       mmiPath;\n    size_t              mmiPathLen;\n    const rtwCAPI_Signals*  signals;\n    const rtwCAPI_DimensionMap* dimMap;\n    const uint_T*       dimArray;\n    const rtwCAPI_DataTypeMap*  dataTypeMap;\n    void**              dataAddrMap;\n    const char_T*       errstr = NULL;\n    uint8_T             isPointer = 0;\n    char*               blockPath = NULL;\n\n    if (mmi == NULL) goto EXIT_POINT;\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n\n        errstr = rtwCAPI_GetSigLogRecordInfo(cMMI,\n                                             sigBlockName,\n                                             sigLabel,\n                                             sigWidth,\n                                             sigDataType,\n                                             logDataType,\n                                             sigComplexity,\n                                             sigDataAddr,\n                                             sigCrossMdlRef,\n                                             sigIdx,\n                                             true,\n                                             rtwLogging);\n        if (errstr != NULL) goto EXIT_POINT;\n    }\n\n    nSignals = rtwCAPI_GetNumSignals(mmi);\n    if (nSignals < 1) goto EXIT_POINT;\n\n    mmiPath     = rtwCAPI_GetFullPath(mmi);\n    mmiPathLen  = (mmiPath==NULL)? 0 : strlen(mmiPath);\n    signals     = rtwCAPI_GetSignals(mmi);\n    dimMap      = rtwCAPI_GetDimensionMap(mmi);\n    dimArray    = rtwCAPI_GetDimensionArray(mmi);\n    dataTypeMap = rtwCAPI_GetDataTypeMap(mmi);\n    dataAddrMap = rtwCAPI_GetDataAddressMap(mmi);\n\n    for (i = 0; i < nSignals; ++i) {\n        uint_T mapIdx;\n        size_t sigPathLen;\n        char*  sigPath;\n\n        /* For RTW logging, skip states that cannot be logged to MAT-File. */\n        if ((rtwLogging) &&\n            (rtwCAPI_CanLogSignalToMATFile(dataTypeMap, signals, i) == false)) continue;\n\n        /* sigBlockPath = mmiPath + | + BlockPath + '\\0' */\n        /* If crossing a model boundary encode, otherwise do not */\n\n        if (crossingModel) {\n            blockPath = rtwCAPI_EncodePath(rtwCAPI_GetSignalBlockPath(signals, i));\n            if ( (blockPath == NULL) &&\n                 (rtwCAPI_GetSignalBlockPath(signals, i) != NULL)) {\n                errstr = rtwCAPI_mallocError;\n                goto EXIT_POINT;\n            }\n        } else {\n            const char* constBlockPath = rtwCAPI_GetSignalBlockPath(signals, i);\n            blockPath = (char*)utMalloc((strlen(constBlockPath)+1)*sizeof(char));\n            (void)strcpy(blockPath, constBlockPath);\n        }\n        utAssert(blockPath != NULL);\n        sigPathLen = ( (mmiPath==NULL) ?\n                                   strlen(blockPath) + 1 :\n                                   mmiPathLen + strlen(blockPath) + 2 );\n        sigPath    = (char*)utMalloc(sigPathLen*sizeof(char));\n        if (sigPath == NULL) {\n            errstr = rtwCAPI_mallocError;\n            goto EXIT_POINT;\n        }\n        if (mmiPath != NULL) {\n            (void)strcpy(sigPath, mmiPath);\n            sigPath[mmiPathLen]   = '|';\n            sigPath[mmiPathLen+1] =  '\\0';\n            (void)strcat(sigPath, blockPath);\n        } else {\n            (void)strcpy(sigPath, blockPath);\n            sigPath[sigPathLen-1] =  '\\0';\n        }\n       /* need to free for every iteration of the loop, but also have\n        * the free below EXIT_POINT in case of error */\n        utFree(blockPath);\n        blockPath = NULL;\n        utAssert(sigPath[sigPathLen-1] == '\\0');\n        sigBlockName[*sigIdx] = sigPath; /* caller is responsible for free */\n\n        /* Label */\n        sigLabel[*sigIdx] = rtwCAPI_GetSignalName(signals, i);\n\n        /* Width */\n        mapIdx = rtwCAPI_GetSignalDimensionIdx(signals, i);\n        utAssert( rtwCAPI_GetNumDims(dimMap,mapIdx) == 2 );\n        mapIdx = rtwCAPI_GetDimArrayIndex(dimMap, mapIdx);\n        sigWidth[*sigIdx] = dimArray[mapIdx] * dimArray[mapIdx+1];\n\n        /* DataType and logDataType */\n        mapIdx = rtwCAPI_GetSignalDataTypeIdx(signals, i);\n        sigDataType[*sigIdx] = rtwCAPI_GetDataTypeSLId(dataTypeMap, mapIdx);\n        /* this mimics code in simulink.dll:mapSigDataTypeToLogDataType */\n        switch (sigDataType[*sigIdx]) {\n          case SS_DOUBLE:\n          case SS_SINGLE:\n          case SS_INT8:\n          case SS_UINT8:\n          case SS_INT16:\n          case SS_UINT16:\n          case SS_INT32:\n          case SS_UINT32:\n          case SS_BOOLEAN:\n            logDataType[*sigIdx] = sigDataType[*sigIdx];\n            break;\n          case SS_ENUM_TYPE:\n            logDataType[*sigIdx] = SS_INT32;\n            break;\n          default:\n            logDataType[*sigIdx] = SS_DOUBLE;\n            break;\n        }\n\n        /* Complexity */\n        sigComplexity[*sigIdx] = rtwCAPI_GetDataIsComplex(dataTypeMap, mapIdx);\n\n        /* Data Access - Pointer or Direct*/\n        isPointer = ((uint8_T)rtwCAPI_GetDataIsPointer(dataTypeMap, mapIdx));\n\n        /* Address */\n        mapIdx = rtwCAPI_GetSignalAddrIdx(signals, i);\n\n        rtwCAPI_GetSigAddrFromMap(isPointer, sigComplexity, sigDataType,\n                                  sigDataAddr, sigIdx, mapIdx, dataAddrMap);\n\n        /* CrossingModelBoundary */\n        sigCrossMdlRef[*sigIdx] = crossingModel;\n\n        ++(*sigIdx);\n    }\n\n  EXIT_POINT:\n    utFree(blockPath);\n    return(errstr);\n\n} /* rtwCAPI_GetSigLogRecordInfo */\n\n\n/** Function: rtwCAPI_CountSysRan ==============================================\n *   Recursive function that counts the number of non-NULL pointers in the array\n *   of system ran dwork pointers, for the given MMI and below\n */\nvoid rtwCAPI_CountSysRan(const rtwCAPI_ModelMappingInfo *mmi,\n\t\t\t int                            *count)\n{\n    sysRanDType **sysRan;\n    int numSys;\n    int nCMMI;\n    int numSysRan = 0;\n    int i;\n\n    if (mmi == NULL) return;\n\n    sysRan = rtwCAPI_GetSystemRan(mmi);\n    numSys    = rtwCAPI_GetNumSystems(mmi);\n    nCMMI     = rtwCAPI_GetChildMMIArrayLen(mmi);\n\n    /* Recurse over children */\n    for (i = 0; i < nCMMI; i++) {\n        rtwCAPI_CountSysRan(rtwCAPI_GetChildMMI(mmi,i), &numSysRan);\n    }\n\n    /* Count number of dworks in this MMI - skip root */\n    for (i = 1; i< numSys; i++) {\n        if (sysRan[i] != NULL) numSysRan++;\n    }\n\n    *count += numSysRan;\n\n} /* end rtwCAPI_CountSysRan */\n\n\n/** Function: rtwCAPI_FillSysRan ===============================================\n *   Recursive function that fills in the system ran dwork pointers and their\n *   corresponding tids in the given array, for the given MMI and below.  The\n *   array to be filled in must be allocated outside\n */\nvoid rtwCAPI_FillSysRan(const rtwCAPI_ModelMappingInfo *mmi,\n\t\t\tsysRanDType                    **sysRan,\n\t\t\tint                            *sysTid,\n                        int                            *fillIdx)\n{\n    int       numSys;\n    sysRanDType **mmiSysRan;\n    int       nCMMI;\n    int       *mmiSysTid;\n    int       idx         = *fillIdx;\n    const int *mmiConSys;\n    int i;\n\n    if (mmi == NULL) return;\n\n    numSys      = rtwCAPI_GetNumSystems(mmi);\n    mmiSysRan = rtwCAPI_GetSystemRan(mmi);\n    nCMMI       = rtwCAPI_GetChildMMIArrayLen(mmi);\n    mmiSysTid  = rtwCAPI_GetSystemTid(mmi);\n    mmiConSys  = rtwCAPI_GetContextSystems(mmi);\n\n    /* Recurse over children */\n    for (i = 0; i < nCMMI; i++) {\n        rtwCAPI_FillSysRan(rtwCAPI_GetChildMMI(mmi,i), sysRan, sysTid, &idx);\n    }\n\n    /* Populate arrays with dwork pointers and tid - skip root */\n    for (i = 1; i< numSys; i++) {\n        if (mmiSysRan[i] != NULL) {\n            idx++;\n            sysRan[idx] = mmiSysRan[i];\n            sysTid[idx] = mmiSysTid[mmiConSys[i]];\n        }\n    }\n\n    *fillIdx = idx;\n\n} /* end rtwCAPI_FillSysRan */\n\n/* LocalWords:  CAPI bpath aaa Addr mmi CSTATE DSTATE Hier tids\n */\n"},{"name":"updown.c","type":"source","group":"legacy","path":"/Applications/MATLAB_R2024a.app/rtw/c/src/ext_mode/common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2020 The MathWorks, Inc.\n */\n#include <stdlib.h>\n#include <string.h>\n\n/*Real Time Workshop headers*/\n#include \"rtwtypes.h\"\n#include \"rtw_extmode.h\"\n#include \"sysran_types.h\"\n\n/* \n * String is dynamic in the following cases\n * - Rapid Accelerator mode\n */\n#ifdef IS_RAPID_ACCEL\n#define MW_DYNAMIC_STRING_SUPPORT\n#endif\n\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n#include \"mwstringutil.h\"\n/* \"assert\" is defined in updown_util.h below */ \n#undef assert\n#endif\n\n/* \n * Note: Local headers should be after external headers\n *       Otherwise, some macros may be re-defined\n *       One example is \"assert\" in updown_util.h\n *       mwstringutil.h inderectly re-define it\n */\n#include \"ext_types.h\"\n#include \"ext_share.h\"\n#include \"ext_svr.h\"\n#include \"ext_work.h\"\n#include \"updown_util.h\"\n#include \"dt_info.h\"\n\n/* DUMP_PKT is defined to be (0) below - why? See g2176068. */\n#if defined(VERBOSE) || (defined(DUMP_PKT) && DUMP_PKT)\n#include <stdio.h>\n#endif\n\n/* \n * Depending on the target's native word size and pointer size, interrupts\n * might need to be disabled around critical regions when accessing the \n * the external mode circular buffer. If, for example, reading a pointer \n * is not guaranteed to be an atomic operation on your target, then you  \n * need to define the preprocessor defines below to prevent interrupts  \n * around the critical regions.\n * \n * Here is a description of each of these preprocessor defines:\n * EXTMODE_PROTECT_CRITICAL_REGIONS: this should be defined if interrupts \n *      should be disabled around critical regions\n * EXTMODE_INTERRUPT_INC_HDR: this defines the include header file \n *      containing the declarations for the enabled/disable interrupts \n *      functions\n * EXTMODE_ENABLE_INTERRUPTS:  this defines the enable interrupts function\n * EXTMODE_DISABLE_INTERRUPTS: this defines the disable interrupts function\n *\n * If you define EXTMODE_PROTECT_CRITICAL_REGIONS, you need to define the \n * other above preprocessor defines, otherwise they are not required.\n */\n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n    #if !defined (EXTMODE_INTERRUPT_INC_HDR) || \\\n        !defined (EXTMODE_ENABLE_INTERRUPTS) || \\\n        !defined (EXTMODE_DISABLE_INTERRUPTS)\n        #error EXTMODE_INTERRUPT_INC_HDR, EXTMODE_ENABLE_INTERRUPTS and \\\n               EXTMODE_DISABLE_INTERRUPTS should be defined\n    #endif\n    /* \n     * include header file containing declarations for interrupt \n     * enable/disable functions \n     */    \n    #include EXTMODE_INTERRUPT_INC_HDR\n#endif\n\n/**********************\n * External Variables *\n **********************/\n#ifdef VXWORKS\n# include <sockLib.h>\n# include <inetLib.h>\n# include <selectLib.h>\nextern SEM_ID uploadSem;\n\n#endif\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\nboolean_T host_upstatus_is_uploading = false;\n\n/******************************************************************************\n * Parameter Download                                                         *\n ******************************************************************************/\n\n#ifdef VERBOSE\n/* Function: DType2Real_T ======================================================\n * Convert a built-in data type to a real_T value.  Return the real_T value\n * as well as a string (by reference) corresponding to the original data type.\n * If the data type is not recognized as a Simulink built-in data type, then\n * NULL is returned for the dTypeName and 0 is returned for the dTypeValue.\n */\nPRIVATE double DType2Double(\n    const char              *vPtr,\n    const int               dTypeIdx,\n    const DataTypeTransInfo *dtInfo,\n    const char              **dTypeName)\n{\n    real_T     outVal;\n    char * const *dTypeNames = (char * const *)dtGetDataTypeNames(dtInfo);\n    const char *thisName     = dTypeNames[dTypeIdx];\n\n    *dTypeName = thisName;\n\n    if (strcmp(thisName, \"real_T\") == 0) {\n        outVal = (real_T) (((const real_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"real32_T\") == 0) {\n        outVal = (real_T) (((const real32_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"int8_T\") == 0) {\n        outVal = (real_T) (((const int8_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"uint8_T\") == 0) {\n        outVal = (real_T) (((const uint8_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"int16_T\") == 0) {\n        outVal = (real_T) (((const int16_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"uint16_T\") == 0) {\n        outVal = (real_T) (((const uint16_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"int32_T\") == 0) {\n        outVal = (real_T) (((const int32_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"uint32_T\") == 0) {\n        outVal = (real_T) (((const uint32_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"boolean_T\") == 0) {\n        outVal = (real_T) (((const boolean_T*)vPtr)[0]);\n    } else {\n        outVal    = 0;\n        dTypeName = NULL;\n    }\n    return(outVal);\n} /* end DType2Double */\n#endif\n\n\n/* Function: SetParam ==========================================================\n * Install new parameters.\n *\n * NOTE: pbuf looks like:\n *  [NPARAMS\n *   B S W DI DATA   % pVal 0\n *   B S W DI DATA   % pVal 1\n *   B S W DI DATA   % pVal N\n *  ]\n *\n *  No assumptions about the alignment of pbuf may be made.\n *\n *  where,\n *      B   : Data type transition index.  Note that on the target the data\n *            type transition index provides both the base address (B)\n *              of the transition as well as whether or not\n *              that section of the array contains complex elements.\n *      S   : starting offset of the data from the DT_TRANS_IDX\n *      W   : number of elements for this param\n *      DI  : index into rtw data type table (inUse idx)\n *      DATA: the param values (in target format).\n *\n *  and,\n *      All values, excluding DATA, are int32_T.\n */\n#ifndef EXTMODE_DISABLEPARAMETERTUNING\nPUBLIC void SetParam(RTWExtModeInfo  *ei, const char *pbuf)\n{\n    int        i;\n    int32_T    nParams;\n    const char *bufPtr    = pbuf;\n    const int  B          = 0; /* index into dtype tran table (base address)  */\n    const int  SI         = 1; /* starting index - wrt to base address        */\n    const int  W          = 2; /* width of section (number of elements)       */\n    const int  DI         = 3; /* index into data type tables                 */\n    const int  tmpBufSize = sizeof(int32_T) * 4;\n    int32_T    tmpBuf[4];\n\n    const DataTypeTransInfo *dtInfo = (const DataTypeTransInfo *) rteiGetModelMappingInfo(ei);\n    const DataTypeTransitionTable *dtTable = dtGetParamDataTypeTrans(dtInfo);\n    const uint_T *dtSizes = dtGetDataTypeSizes(dtInfo);\n    \n#ifdef MW_DYNAMIC_STRING_SUPPORT\n    const char_T* *dtNames = dtGetDataTypeNames(dtInfo);\n#endif\n\n    /* unpack NPARAMS */\n    (void)memcpy(&nParams, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n    \n#ifdef VERBOSE\n    printf(\"\\nUpdating %d parameters....\\n\", nParams);\n#endif\n\n    /*\n     * Unpack the data and install the new parameters.\n     */\n    for (i=0; i<nParams; i++) {\n        int_T   elSize;\n        int_T   nBytes;\n        char_T  *start;\n        char_T  *tranAddress;\n        int_T   tranIsComplex;\n\n        /* unpack B SI W DI */\n        (void)memcpy(tmpBuf, bufPtr, tmpBufSize);\n        bufPtr += tmpBufSize;\n\n        /* \n         * Find starting address and size (nBytes) for this parameters \n         * section of memory.\n         */\n        tranAddress   = dtTransGetAddress(dtTable, tmpBuf[B]);\n        tranIsComplex = dtTransGetComplexFlag(dtTable, tmpBuf[B]);\n\n        elSize = dtSizes[tmpBuf[DI]] * (tranIsComplex ? 2 : 1);\n        nBytes = tmpBuf[W] * elSize;\n\n        /*\n         * String in rapid accelerator is:\n         *   - transferred as character stream, element size is sizeof(char_T)\n         *   - stored/operated as void *, element size is sizeof(void*)\n         * We need to use the later one to calculate \"start\" address\n         */\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n        if (strcmp(dtNames[tmpBuf[DI]], \"string\") == 0) {\n            elSize = sizeof(void*);\n        }\n#endif\n        start = tranAddress + (tmpBuf[SI] * elSize);\n\n        /* Install the params. */\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n        if (strcmp(dtNames[tmpBuf[DI]], \"string\") == 0) {\n            suInitializeString(start, bufPtr);\n            bufPtr += nBytes;\n        } else\n#endif\n        {\n            (void)memcpy(start, bufPtr, nBytes);\n            bufPtr += nBytes;\n        }\n\n#ifdef VERBOSE\n        /*\n         * It is safe to assume that once the params are installed into\n         * the param vector that they are properly aligned.  So we\n         * do our verbosity print-out here.\n         */\n        {\n            double     val;\n            const char *dTypeName;\n            const char *vPtr = (const char *)start;\n\n            val = DType2Double(start, tmpBuf[DI], dtInfo, &dTypeName);\n            printf(\"\\n\\tParam| \"\n                   \"DT_Trans: %d, index: %d, nEls: %d, data type: [%s, %d]\\n\",\n                   tmpBuf[B], tmpBuf[SI], tmpBuf[W],\n                   (dTypeName != NULL) ? dTypeName : \"\",tmpBuf[DI]);\n\n            if (!tranIsComplex) {\n                int j;\n                for (j=0; j<tmpBuf[W]; j++) {\n                    val = DType2Double(vPtr, tmpBuf[DI], dtInfo, &dTypeName);\n                    printf(\"\\t\\t%f\\n\", val);\n                    vPtr += dtSizes[tmpBuf[DI]];\n                }\n            } else {\n                int j;\n                for (j=0; j<tmpBuf[W]; j++) {\n                    val = DType2Double(vPtr, tmpBuf[DI], dtInfo, &dTypeName);\n                    printf(\"\\t\\t%f + \", val);\n                    vPtr += dtSizes[tmpBuf[DI]];\n\n                    val = DType2Double(vPtr, tmpBuf[DI], dtInfo, &dTypeName);\n                    printf(\"\\t\\t%fi\\n\", val);\n                    vPtr += dtSizes[tmpBuf[DI]];\n                }\n            }\n        }\n#endif\n    }\n} /* end SetParam */\n#endif /* ifndef EXTMODE_DISABLEPARAMETERTUNING */\n\n\n/******************************************************************************\n * Parameter Upload                                                           *\n ******************************************************************************/\n#include \"upsup_public.h\"\n#define DUMP_PKT (0)\n\n\n/*=============================================================================\n * Circular buffer stuff.\n *============================================================================*/\ntypedef struct BufMemList_tag {\n\n#if ASSERTS_ON\n    int_T  maxBufs;     /* for debugging                       */\n#endif\n    int_T  nActiveBufs; /* num non-empty bufs                  */\n    int_T  *tids;       /* tid associated with each active buf */\n    BufMem *bufs;       /* sections of each buffer to upload   */\n} BufMemList;\n\n\ntypedef struct CircularBuf_tag {\n    volatile int_T    empty;\n\n    int_T    bufSize;\n    char_T   *buf;\n    \n    char_T* volatile head;\n    char_T* volatile tail;\n\n    char_T   *newTail;\n\n    struct {\n        int_T count;\n    } preTrig;\n} CircularBuf;\n\n\n/*==============================================================================\n * Trigger stuff.\n *============================================================================*/\ntypedef enum {\n    TRIGGER_UNARMED,\n    TRIGGER_HOLDING_OFF,\n    TRIGGER_ARMED,\n    TRIGGER_DELAYED,\n    TRIGGER_FIRED,\n    TRIGGER_TERMINATING\n} TriggerState;\n\n\n/*==============================================================================\n * General stuff.\n *============================================================================*/\n\n/*\n * An UploadSection defines a contiguous section of the blockio or dwork\n * structure.  Each section consists of elements of the same data type and same\n * complexity.\n * 'start' should be a const pointer\n */\ntypedef struct UploadSection_tag {\n    void   *start;\n    int_T  nBytes;\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n    boolean_T isString;\n#endif\n} UploadSection;\n\n/*\n * An UploadMap is an array of UploadSections.  Typically a map consists of all\n * of the sections of the blockio or dwork structure that are relevant to a\n * given task.\n */\ntypedef struct UploadMap_tag {\n    int32_T    nSections;\n    UploadSection *sections;\n\n    int_T nBytes;  /* total number of bytes in this map */\n} UploadMap;\n\n\n/*\n * Each system contains a table of UploadMap's (one for each tid).  If no data\n * uploading is being done for a given tid, the uploadMap pointer is NULL.\n * The enableState field indicates whether the system in question is active.\n *\n * For a model with 5 total tids, the table looks like:\n *\n *               tid 0    tid 1    tid 2   tid 3   tid 4\n * uploadMap   -------------------------------------------\n *             |  ptr  |  NULL  |  NULL  |  ptr  |  NULL |\n *             ----|-------------------------|------------\n *                 |                         |\n *                 v                         v\n *              UploadMap                 UploadMap\n *              for tid 0                 for tid 3\n */\ntypedef struct SysUploadTable_tag {\n    int8_T    *enableState;\n    UploadMap **uploadMap;\n} SysUploadTable;\n\n\ntypedef struct TriggerInfo_tag {\n    TriggerState            state;\n    int_T                   tid;\n    int32_T                 duration;\n    int32_T                 holdOff;\n    int32_T                 delay;\n    int_T                   lookForRising;\n    int_T                   lookForFalling;\n    real_T                  level;\n    int_T                   count;\n    int_T                   overFlow;\n\n    UploadMap               trigSignals;\n    real_T                  *oldTrigSigVals;\n    int_T                   haveOldTrigSigVal;\n\n    struct {\n        int32_T    duration;\n        int32_T    count;\n\n        int_T      checkUnderFlow; /* ??? */\n    } preTrig;\n} TriggerInfo;\n\n\n/*\n * The BdUploadInfo contains all information regarding data logging.\n */\nstruct BdUploadInfo_tag {\n    int32_T        upInfoIdx;  /* index of upInfo in the array                 */\n    int32_T        nSys;       /* # of sys's for which data logging is active  */\n    SysUploadTable *sysTables; /* array of SysUploadTables                     */\n    CircularBuf    *circBufs;  /* circular buffers to store upload data        */\n    BufMemList     bufMemList; /* list of buffer memory holding data to upload */\n\n    TriggerInfo  trigInfo;\n};\n\n\n/*==============================================================================\n * Global upload data.\n */\n\n/*\n * Definitions that must match Simulink definitions.\n */\n\n#define UPLOAD_RISING_TRIGGER                   ((int32_T)  0)\n#define UPLOAD_FALLING_TRIGGER                  ((int32_T)  1)\n#define UPLOAD_EITHER_RISING_OR_FALLING_TRIGGER ((int32_T)  2)\n\n/*\n * Definitions.\n */\n#define TRIGMODE_ONESHOT (-1)\n\n#define NUM_UPINFOS   2\nstatic  BdUploadInfo  uploadInfoArray[NUM_UPINFOS];\n\n\n/* Function ====================================================================\n * Dump the signal selection packet (EXT_SELECT_SIGNALS).  The packet looks\n * like:\n *\n * upInfoIdx - Index of the UploadInfo. \n *\n * nSys - the number of systems that contain upload blocks (length of the\n *        (BdUploadInfo list)\n *\n * enableIdx - the index into the \"mode vector\" that tells whether or not\n *             a given system is active\n *\n * nTids - the number of tids in a system that contain upload blocks (number\n *         of non NULL entries in a SysUploadTable)\n *\n * nSections - the number of contiguous blockio or dwork sections that\n *             correspond to all blocks within a tid (number of sections in\n *             an UploadMap)\n *\n * B  - Index into data type transition table       - gives base address\n * S  - the starting index of a blockio section     - with respect to B\n * W  - the number of elements in a blockio section\n * DI - data type index - index into the rtw data type table\n *\n * target buf size - size of the upload buffer (to be allocated by target) for\n *                   a given tid\n *\n * Here's the packet format:\n *\n * [upInfoIdx\n *  \n *  nSys\n *\n *  enableIdx                           ---\n *  nTids                                 |\n *  tid nSections B S W DI B S W DI ...   | system\n *  tid nSections B S W DI B S W DI ...   |\n *                                      ---\n *  enableIdx                           ---\n *  nTids                                 |\n *  tid nSections B S W DI B S W DI ...   | system\n *  tid nSections B S W DI B S W DI ...   |\n *                                      ---\n *  target buf size for tid 0\n *  target buf size for tid 1\n *            .\n *            .\n *  target buf size for tid n\n * ]\n *\n * All elements are int32_T.\n */\n#if DUMP_PKT\nPRIVATE void DumpSelectSignalPkt(const char *pkt, int nRootTids)\n{\n    int32_T    i,j,k;\n    int32_T    upInfoIdx;\n    int32_T    nSys;\n    const char *bufPtr = pkt;\n\n    printf(\"Signal Select Pkt-----------\\n\");\n\n    /* upInfoIdx */\n    (void)memcpy(&upInfoIdx, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nupInfoIdx: %d\\n\",upInfoIdx);\n\n    /* nSys */\n    (void)memcpy(&nSys, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nnSys: %d\\n\",nSys);\n\n    for (i=0; i<nSys; i++) {\n        int32_T enableIdx, nTids;\n        \n        /* [enableIdx, nTids] */\n        (void)memcpy(&enableIdx, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        (void)memcpy(&nTids, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        printf(\"[enableIdx, nTids]: %d %d\\n\", enableIdx, nTids);\n\n        for (j=0; j<nTids; j++) {\n            int32_T tid;\n            int32_T nSections;\n\n            /* [tid nSections] */\n            (void)memcpy(&tid, bufPtr, sizeof(int32_T));\n            bufPtr += sizeof(int32_T);\n\n            (void)memcpy(&nSections, bufPtr, sizeof(int32_T));\n            bufPtr += sizeof(int32_T);\n\n            printf(\"[tid nSects]: %d %d\\n\", tid, nSections);\n\n            for (k=0; k<nSections; k++) {\n                const int B  = 0;\n                const int S  = 1;\n                const int W  = 2;\n                const int DI = 3;\n                int32_T   tmpBuf[4];\n\n                /* [B S W DI] */\n                (void)memcpy(&tmpBuf, bufPtr, sizeof(int32_T)*4);\n                bufPtr += (sizeof(int32_T) * 4);\n                \n                printf(\"%d %d %d %d\\n\",\n                    tmpBuf[B], tmpBuf[S], tmpBuf[W], tmpBuf[DI]);\n            }\n            printf(\"\\n\");\n        }\n        printf(\"\\n\");\n    }\n\n    /*\n     * Now the buffer sizes.\n     */\n    printf(\"bufSizes: \");\n    for (i=0; i<nRootTids; i++) {\n        int32_T bufSize;\n\n        printf(\"\\nbufSize[%d] of %d: \",i, nRootTids);\n\n        (void)memcpy(&bufSize, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        printf(\"%d\", bufSize);\n    }\n    printf(\"\\nEnd of select sigs pkt----\\n\");\n} /* end DumpSelectSignalPkt */\n#else\n#define DumpSelectSignalPkt(buf, nRootTids) /* do nothing */\n#endif\n\n\n/* Function ====================================================================\n * Dump the trigger selection packet (EXT_SELECT_TRIGGER).  The packet looks\n * like:\n *\n * upInfoIdx - Index of the UploadInfo. \n *\n * tid       - tid of the trigger signal\n *\n * duration  - The number of base rate steps for which the data logging event\n *             occurs.\n *\n * holdOff   - (-1), signifies that this trigger event is a one_shot, else we \n *             are in normal mode.  For normal mode the value indicates\n *             the number of base rate steps to wait between the end a data\n *             logging event and the re-arming of the trigger for the next data\n *             logging event.  The end of a data logging event is defined as\n *             when the last bit of data has been sent to the host (i.e.,\n *             immediately after the termination flag has been sent).\n *\n * delay     - The number of base rate steps to wait after the trigger event\n *             occurs and the before starting the data collection.  This can\n *             be either positive or negative (pre-trigger).  This field is\n *             ignored if the trigger source is manual.\n *\n * nsections - The sections of the blockio array to monitor for a trigger event.\n *             If the trigger event is not based on a signal, this is set to\n *             0 (e.g., the signal source is manual).\n *\n * sections  - \"B, S, W, DI\" description of a signal (see Signal Selection Pkt).\n *             These are the elements of the blockio vector that are monitored\n *             for trigger events when the trigger is based on a signal.  It is\n *             ignored if the trigger event is not based on a signal\n *             (nsections == 0).\n *\n * direction - If the triggering source is a signal, then this specifies the\n *             direction of the crossing (rising, falling or either).  If we\n *             are not triggering on a signal (nsections == 0), then this field\n *             is ignored.\n *\n * level     - If the triggering source is a signal, then this field specifies\n *             the level (value) of the crossing (0 by default).  If we are not\n *             triggering on a signal (nsections == 0), then this field is\n *             ignored.\n *\n * The packet looks like:\n * [tid duration holdOff delay nsections B S W DI B S W DI ... direction level]\n *\n * All fields are int32_T except for level, which is an SL_DOUBLE (real_T\n * on target).\n */\n#if DUMP_PKT\nPRIVATE void DumpSelectTriggerPkt(const char *pkt)\n{\n    int32_T    i;\n    int32_T    upInfoIdx, tid, duration, holdOff, delay, nSections;\n    int32_T    direction;\n    real_T     level;\n    const char *bufPtr = pkt;\n\n    printf(\"Trigger Select Pkt-----------\\n\");\n\n    /* upInfoIdx */\n    (void)memcpy(&upInfoIdx, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nupInfoIdx: %d\\n\",upInfoIdx);\n    \n    /* tid */\n    (void)memcpy(&tid, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\ntid: %d\\n\",tid);\n    \n    /* duration */\n    (void)memcpy(&duration, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nduration: %d\\n\",duration);\n\n    /* holdOff */\n    (void)memcpy(&holdOff, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nholdOff: %d\\n\",holdOff);\n\n    /* delay */\n    (void)memcpy(&delay, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\ndelay: %d\\n\",delay);\n\n    /* nsections */\n    (void)memcpy(&nSections, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"nSects: %d\\n\", nSections);\n\n    /* each section */\n    for (i=0; i<nSections; i++) {\n        const int B  = 0;\n        const int S  = 1;\n        const int W  = 2;\n        const int DI = 3;\n        int32_T   tmpBuf[4];\n\n        (void)memcpy(&tmpBuf, bufPtr, sizeof(int32_T)*4);\n        bufPtr += (sizeof(int32_T) * 4);\n        \n        printf(\"%d %d %d %d\\n\", tmpBuf[B], tmpBuf[S], tmpBuf[W], tmpBuf[DI]);\n    }\n    printf(\"\\n\");\n\n    /* direction */\n    (void)memcpy(&direction, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"direction: %d\\n\",direction);\n\n    /* level */\n    (void)memcpy(&level, bufPtr, sizeof(real_T));\n    bufPtr += sizeof(real_T);\n\n    printf(\"level: %f\\n\",level);\n} /* end DumpSelectTriggerPkt */\n#else\n#define DumpSelectTriggerPkt(buf) /* do nothing */\n#endif\n\n\n/* Function ====================================================================\n * Initialize a UploadSection.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPRIVATE void InitUploadSection(\n    RTWExtModeInfo *ei,\n    const int32_T  *buf,\n    UploadSection  *section)   /* out */\n{\n    int_T                         elSize;\n    int_T                         offset;\n    int_T                         nBytes;\n    char_T                        *tranAddress;\n    int_T                         tranIsComplex;\n    \n    const DataTypeTransInfo       *dtInfo  = (const DataTypeTransInfo *) rteiGetModelMappingInfo(ei);\n    const DataTypeTransitionTable *dtTable = dtGetBIODataTypeTrans(dtInfo);\n    const uint_T *dtSizes = dtGetDataTypeSizes(dtInfo);\n\n    const int BI = 0;  /* index into dtype tran table (base address)  */\n    const int SI = 1;  /* starting index - wrt to base address        */\n    const int W  = 2;  /* width of section (number of elements)       */\n    const int DI = 3;  /* index into data type tables                 */\n\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n    const char_T* *dtNames;\n#endif\n    \n    tranAddress   = dtTransGetAddress(dtTable, buf[BI]);\n    tranIsComplex = dtTransGetComplexFlag(dtTable, buf[BI]);\n\n    elSize = dtSizes[buf[DI]] * (tranIsComplex ? 2 : 1);\n    nBytes = buf[W] * elSize;\n    offset = buf[SI] * elSize;\n\n    section->start  = tranAddress + offset;\n    section->nBytes = nBytes;\n    \n#ifdef MW_DYNAMIC_STRING_SUPPORT\n    dtNames = dtGetDataTypeNames(dtInfo);\n    section->isString = strcmp(dtNames[buf[DI]], \"string\") == 0;\n#endif\n    \n} /* end InitUploadSection */\n\n\n/* Function ====================================================================\n * Initialize a SysUploadTable.  The callerBufPtr points to the current place in\n * the EXT_SELECT_SIGNALS pkt which should be the enableIdx field.  This\n * function moves the callerBufPtr to the next unread field of the packet.\n */\nPRIVATE boolean_T InitSysUploadTable(\n    RTWExtModeInfo *ei,\n    int_T          numSampTimes,\n    SysUploadTable *sysTable,\n    const char     **callerBufPtr) /* in/out */\n{\n    int_T        i;\n    int32_T      nTids;\n    const char_T *bufPtr = *callerBufPtr;\n    boolean_T    error   = EXT_NO_ERROR;\n\n    /*\n     * Set pointer to enable mode.\n     */\n    {\n        int32_T sysIdx;\n\n        /* read sysIdx */\n        (void)memcpy(&sysIdx, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        sysTable->enableState = rteiGetAddrOfSubSystemActiveVector(ei,sysIdx);\n    }\n\n    /*\n     * Allocate/initialize each tid's uploadMap.\n     */\n\n    /* ...read [nTids] */\n    (void)memcpy(&nTids, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    /* Allocate the array of pointers to UploadMaps. */\n    sysTable->uploadMap = (UploadMap **)calloc(numSampTimes, sizeof(UploadMap *));\n    if (sysTable->uploadMap == NULL) {\n        error = EXT_ERROR; goto EXIT_POINT;       \n    }\n\n    for (i=0; i<nTids; i++) {\n        int32_T   tid;\n        int32_T   section;\n        UploadMap *map;\n        \n        /* read tid */\n        (void)memcpy(&tid, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n        \n        /* allocate UploadMap */\n        assert(sysTable->uploadMap[tid] == NULL);\n        sysTable->uploadMap[tid] = (UploadMap *)calloc(1, sizeof(UploadMap));\n        if (sysTable->uploadMap[tid] == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;       \n        }\n        map = sysTable->uploadMap[tid];\n        \n        /* read nSections */\n        (void)memcpy(&map->nSections, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        /* Allocate the blockio sections. */\n        assert(map->sections == NULL);\n        if (map->nSections > 0) {\n           map->sections = (UploadSection *)calloc(map->nSections,sizeof(UploadSection));\n           if (map->sections == NULL) {\n               error = EXT_ERROR; goto EXIT_POINT;\n           }\n        }\n\n        /*\n         * Init the UploadSections.\n         */\n        for (section=0; section<map->nSections; section++) {\n            int32_T    tmpBuf[4];\n            UploadSection *uploadSection = &map->sections[section];\n\n            /* read [B S W DI] */\n            (void)memcpy(&tmpBuf, bufPtr, sizeof(int32_T)*4);\n            bufPtr += (sizeof(int32_T) * 4);\n\n            InitUploadSection(ei, tmpBuf, uploadSection);\n\n            /* keep track of total number of bytes in this map */\n            map->nBytes += uploadSection->nBytes;\n        }\n    }\n    \nEXIT_POINT:\n    *callerBufPtr = bufPtr;\n    return(error);\n} /* end InitSysUploadTable */\n\n/* Function ====================================================================\n * Initialize circular buffer fields and allocate required memory.\n */\nPRIVATE boolean_T UploadBufInit(CircularBuf *circBuf, int32_T size)\n{\n    boolean_T error = NO_ERR;\n\n    assert(circBuf->buf == NULL);\n\n    /*\n     * Size will be negative to indicate an error if host determines too much\n     * memory is needed (i.e. the size will not fit in an int32).\n     */\n    if (size < 0) {\n        error = EXT_ERROR; goto EXIT_POINT;\n    }\n\n    circBuf->empty = true;\n    if (size > 0) {\n        assert(circBuf->buf == NULL);\n        circBuf->buf = (char_T *)malloc(size);\n        if (circBuf->buf == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;\n        }\n    } else {\n        circBuf->buf = NULL;\n    }\n    circBuf->bufSize = size;\n    \n    circBuf->head = circBuf->buf;\n    circBuf->tail = circBuf->buf;\n\n    circBuf->newTail = NULL;\n\nEXIT_POINT:\n    return(error);\n} /* end UploadBufInit */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n/* Function ====================================================================\n * Free all dynamically allocated fields of the trigInfo structure.\n */\nPRIVATE void UploadDestroyTrigger(int32_T upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    TriggerInfo *trigInfo    = &uploadInfo->trigInfo;\n    UploadMap   *map         = &trigInfo->trigSignals;\n\n    if (map->sections != NULL) {\n        free(map->sections);\n        map->sections = NULL;\n    }\n\n    if (trigInfo->oldTrigSigVals != NULL) {\n        free(trigInfo->oldTrigSigVals);\n        trigInfo->oldTrigSigVals = NULL;\n    }\n\n    /*\n     * Reset trigger info.\n     */\n    trigInfo->state          = TRIGGER_UNARMED;\n    trigInfo->duration       = 0;\n    trigInfo->holdOff        = 0;\n    trigInfo->delay          = 0;\n    trigInfo->lookForRising  = true;\n    trigInfo->lookForFalling = false;\n    trigInfo->level          = (real_T)0;\n    trigInfo->count          = 0;\n    trigInfo->overFlow       = false;\n\n    trigInfo->trigSignals.nSections = 0;\n    trigInfo->trigSignals.sections  = NULL;\n    trigInfo->trigSignals.nBytes    = 0;\n\n    trigInfo->oldTrigSigVals    = NULL;\n    trigInfo->haveOldTrigSigVal = false;\n\n    trigInfo->preTrig.duration       = 0;\n    trigInfo->preTrig.count          = 0;\n    trigInfo->preTrig.checkUnderFlow = false;\n} /* end UploadDestroyTrigger */\n\n\n/* Function ====================================================================\n * Reset fields of the uploadinfo struct.\n */\nPUBLIC void UploadLogInfoReset(int32_T upInfoIdx)\n{\n    static boolean_T firstTime[NUM_UPINFOS] = {true, true};\n    BdUploadInfo     *uploadInfo = &uploadInfoArray[upInfoIdx];\n    \n    /*\n     * uploadInfoArray is declared as global static, so most compilers will\n     * initialize the memory to zero.  However, the tic6000 assigns this\n     * variable into uninitialized memory.  When this function is called for\n     * the first time, we attempt to free garbage pointers and crash.  By\n     * clearing unloadInfoArray explicitly the first time this function is\n     * called, we can ensure that this function will work for all compilers.\n     */\n    if (firstTime[upInfoIdx]) {\n        memset(uploadInfo, 0, sizeof(BdUploadInfo));\n        firstTime[upInfoIdx] = false;\n    }\n   \n    /* sysUploadTable */\n    uploadInfo->nSys      = 0;\n    uploadInfo->sysTables = NULL;\n\n    uploadInfo->circBufs = NULL;\n\n    uploadInfo->bufMemList.bufs = NULL;\n    uploadInfo->bufMemList.tids = NULL;\n\n    /* Reset trigger info */\n    UploadDestroyTrigger(upInfoIdx);\n\n} /* end UploadLogInfoReset */\n\n\n/* Function ====================================================================\n * Destroy all data associated with data logging.  Fields are re-initialized\n * and pointers NULL'ed out by UploadLogInfoReset().\n */\nPUBLIC void UploadLogInfoTerm(int32_T upInfoIdx, int_T numSampTimes)\n{\n    int_T i;\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    if (uploadInfo->nSys == 0) return; /* Nothing to terminate */\n\n    /*\n     * Free fields of the sysUpload tables and then the table itself.\n     */\n    for (i=0; i<uploadInfo->nSys; i++) {\n        int_T     tid;\n        UploadMap **uploadMap = uploadInfo->sysTables[i].uploadMap;\n        \n        for (tid=0; tid<numSampTimes; tid++) {\n            if (uploadMap[tid] != NULL) {\n                /* Free fields of uploadMap. */\n                free(uploadMap[tid]->sections);\n\n                /* Free the uploadMap. */\n                free(uploadMap[tid]);\n            }\n        }\n\n        free(uploadMap);\n    }\n\n    free(uploadInfo->sysTables);\n\n    /* Free circular buf fields and bufMemLists. */\n    if (uploadInfo->circBufs) {\n        for (i=0; i<numSampTimes; i++) {\n            free(uploadInfo->circBufs[i].buf);\n        }\n        free(uploadInfo->circBufs);\n    }\n\n    free(uploadInfo->bufMemList.bufs);\n    free(uploadInfo->bufMemList.tids);\n    \n    /*\n     * Free trigger info.\n     */\n    UploadDestroyTrigger(upInfoIdx);\n\n    /*\n     * Reset all vals to initial value and NULL out pointers.\n     */\n    UploadLogInfoReset(upInfoIdx);\n} /* end UploadLogInfoTerm */\n\n\n/* Function ====================================================================\n * Prepare for final flush of buffers.  This involves setting the trigger\n * state to appropriate values.\n */\nPUBLIC void UploadPrepareForFinalFlush(int32_T upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    switch(uploadInfo->trigInfo.state) {\n    case TRIGGER_FIRED:\n    case TRIGGER_TERMINATING:\n        /*\n         * 1) set trig state to \"terminating\" so that the eventual call to\n         *    UploadBufGetData knows to add the terminator flag to\n         *    the data stream.\n         * 2) set trig state to \"oneshot\" to prevent re-arming\n         */\n        uploadInfo->trigInfo.state   = TRIGGER_TERMINATING; /* 1 */\n        uploadInfo->trigInfo.holdOff = TRIGMODE_ONESHOT;    /* 2 */\n        break;\n\n    case TRIGGER_UNARMED:\n    case TRIGGER_HOLDING_OFF:\n    case TRIGGER_ARMED:\n    case TRIGGER_DELAYED:\n        /* do nothing */\n        break;\n    }\n\n#ifdef VXWORKS\n    /* Let upload server run to ensure that term pkt is sent to host. One\n       semGive() is for the background task and the other is for the explicit\n       call to rt_UploadServerWork() in DisconnectFromHost(). */\n    semGive(uploadSem);\n    semGive(uploadSem);\n#endif\n\t\n} /* end UploadPrepareForFinalFlush */\n\n\n/* Function ====================================================================\n * Initialize data uploading by processing the EXT_SELECT_SIGNALS packet\n * (which is passed in).  Return the error status.  See DumpSelectSignalPkt()\n * for a detailed description of the packet.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPUBLIC boolean_T UploadLogInfoInit(RTWExtModeInfo *ei,\n                                   int_T          numSampTimes,\n                                   const char     *pkt,\n                                   int32_T        upInfoIdx)\n{\n    int          nActiveTids;\n    int_T        i;\n    boolean_T    error   = EXT_NO_ERROR;\n    const char   *bufPtr = pkt;\n    BdUploadInfo *uploadInfo;\n\n    DumpSelectSignalPkt(pkt, numSampTimes);\n\n    /* Point to the correct uploadInfo */\n    uploadInfo           = &uploadInfoArray[upInfoIdx];\n    uploadInfo->upInfoIdx = upInfoIdx;\n\n    /* Free upInfo if fields are already allocated */\n    UploadLogInfoTerm(upInfoIdx, numSampTimes);\n\n    /* nSys */\n    (void)memcpy(&uploadInfo->nSys, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n    assert(uploadInfo->sysTables == NULL);\n    uploadInfo->sysTables = (SysUploadTable *)\n        calloc(uploadInfo->nSys, sizeof(SysUploadTable));\n    if (uploadInfo->sysTables == NULL) {\n        error = EXT_ERROR; goto EXIT_POINT;\n    }\n\n    /*\n     * Init each system table.\n     */\n    for (i=0; i<uploadInfo->nSys; i++) {\n        error = InitSysUploadTable(ei, numSampTimes,\n                                   &uploadInfo->sysTables[i], &bufPtr);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n    }\n\n    assert(uploadInfo->circBufs == NULL);\n    uploadInfo->circBufs = (CircularBuf *) calloc(numSampTimes,\n                                                  sizeof(CircularBuf));\n\n    /*\n     * Allocate the circular buffers.\n     */\n    nActiveTids = 0;\n    for (i=0; i<numSampTimes; i++) {\n        int32_T size;\n        \n        (void)memcpy(&size, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n        \n        error = UploadBufInit(&uploadInfo->circBufs[i], size);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n        nActiveTids += (size != 0);\n    }\n\n    /*\n     * Initialize/Allocate the bufMemLists - these are used by\n     * ext_svr to pull the appropriate data out of the buffers and send it\n     * to the host.\n     */\n#if ASSERTS_ON\n    uploadInfo->bufMemList.maxBufs = nActiveTids;\n#endif\n    uploadInfo->bufMemList.nActiveBufs = 0;\n\n    assert(uploadInfo->bufMemList.bufs == NULL);\n    uploadInfo->bufMemList.bufs = (BufMem *)malloc(nActiveTids*sizeof(BufMem));\n    if (uploadInfo->bufMemList.bufs == NULL) {\n        error = EXT_ERROR; goto EXIT_POINT;\n    }\n\n    assert(uploadInfo->bufMemList.tids == NULL);\n    uploadInfo->bufMemList.tids = (int_T *)malloc(nActiveTids*sizeof(int_T));\n    if (uploadInfo->bufMemList.tids == NULL) {\n        error = EXT_ERROR; goto EXIT_POINT;\n    }\n\nEXIT_POINT:\n    if (error != EXT_NO_ERROR) {\n        UploadLogInfoTerm(upInfoIdx, numSampTimes);\n    }\n    return(error);\n} /* end UploadLogInfoInit */\n\n\n/* Function ====================================================================\n * Initialize and configure the trigger attributes.  See DumpSelectTriggerPkt()\n * for a detailed description of the packet.\n */\nPUBLIC boolean_T UploadInitTrigger(RTWExtModeInfo *ei,\n                                   const char     *pkt,\n                                   int32_T         upInfoIdx)\n{\n    int_T       nSections;\n    int32_T     i32_tid;\n    int32_T     direction;\n    TriggerInfo *trigInfo;\n    boolean_T   error     = EXT_NO_ERROR;\n    const char  *bufPtr   = pkt;\n    \n    DumpSelectTriggerPkt(pkt);\n    \n    /* Select the trig Info */\n    trigInfo = &uploadInfoArray[upInfoIdx].trigInfo;\n\n    /* tid, duration, holdOff, delay and nsections */\n    (void)memcpy(&i32_tid, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n    trigInfo->tid = (int_T)i32_tid;\n\n    (void)memcpy(&trigInfo->duration, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    (void)memcpy(&trigInfo->holdOff, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    (void)memcpy(&trigInfo->delay, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    (void)memcpy(&trigInfo->trigSignals.nSections, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n    \n    nSections = trigInfo->trigSignals.nSections;\n\n    /*\n     * Init the UploadSections - if the trigger is signal based.\n     */\n    if (nSections > 0) {\n        /* trigger is signal based */\n        int       section;\n        UploadMap *map = &trigInfo->trigSignals;\n\n        assert(map->nBytes == 0);\n        assert(map->sections == NULL);\n        map->sections = (UploadSection *)malloc(nSections * sizeof(UploadSection));\n        if (map->sections == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;\n        }\n            \n        for (section=0; section<map->nSections; section++) {\n            int32_T       tmpBuf[4];\n            UploadSection *uploadSection = &map->sections[section];\n\n            /* read [B S W DI] */\n            (void)memcpy(&tmpBuf, bufPtr, sizeof(int32_T)*4);\n            bufPtr += (sizeof(int32_T) * 4);\n            \n            InitUploadSection(ei, tmpBuf, uploadSection);\n\n            /* keep track of total number of bytes in this map */\n            map->nBytes += uploadSection->nBytes;\n        }\n\n        /*\n         * Allocate space to hold the old values of the trigger signals.  Note\n         * that trigger signals are guaranteed to be of type SL_DOUBLE (real_T)\n         * and non-complex.\n         */\n        assert(trigInfo->oldTrigSigVals == NULL);\n        assert(trigInfo->oldTrigSigVals == NULL);\n        trigInfo->oldTrigSigVals = (real_T *)malloc(map->nBytes);\n        if (trigInfo->oldTrigSigVals == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;\n        }\n    }\n            \n    /* Direction. */\n    (void)memcpy(&direction, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    trigInfo->lookForRising  = \n        ((direction == UPLOAD_RISING_TRIGGER)  || \n         (direction == UPLOAD_EITHER_RISING_OR_FALLING_TRIGGER));\n\n    trigInfo->lookForFalling = \n        ((direction == UPLOAD_FALLING_TRIGGER) || \n         (direction == UPLOAD_EITHER_RISING_OR_FALLING_TRIGGER));\n    \n    /* level */\n    (void)memcpy(&trigInfo->level, bufPtr, sizeof(real_T));\n    bufPtr += sizeof(real_T);\n\n    /*\n     * Convert delay to pre-trigger duration.\n     */\n    if (trigInfo->delay < 0) {\n        trigInfo->preTrig.duration = -trigInfo->delay;\n        trigInfo->delay            = 0;\n    } else {\n        trigInfo->preTrig.duration = 0;\n    }\n\nEXIT_POINT:\n    if (error != EXT_NO_ERROR) {\n        UploadDestroyTrigger(upInfoIdx);\n    }\n    return(error);\n} /* end UploadInitTrigger */\n\n\n/* Function ====================================================================\n * Arm the trigger.\n */\nPUBLIC void UploadArmTrigger(int32_T upInfoIdx, int_T numSampTimes)\n{\n    int_T   tid;\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    assert((uploadInfo->trigInfo.state == TRIGGER_UNARMED) ||\n           (uploadInfo->trigInfo.state == TRIGGER_HOLDING_OFF));\n\n    host_upstatus_is_uploading = false;\n\n    /*\n     * Re-initialize.\n     */\n    uploadInfo->trigInfo.overFlow = false;\n    for (tid=0; tid<numSampTimes; tid++) {\n        CircularBuf *circBuf = &uploadInfo->circBufs[tid];\n        if (circBuf->bufSize > 0) {\n            circBuf->head = circBuf->buf;\n            circBuf->tail = circBuf->buf;\n\n            circBuf->newTail = NULL;\n            circBuf->empty   = true;\n        }\n    }\n\n    /* \n     * Re-initialize trigger fields.\n     */\n    uploadInfo->trigInfo.count             = 0;\n    uploadInfo->trigInfo.haveOldTrigSigVal = false;\n\n    /* \n     * Reset pre-trig counts for normal mode.\n     */\n    uploadInfo->trigInfo.preTrig.count = 0;\n\n    /* \n     * Re-arm after all initialization.  Make sure that trigInfo.state is\n     * set last since this routine may be interrupted.\n     */\n    uploadInfo->trigInfo.state = TRIGGER_ARMED;\n\n} /* end UploadArmTrigger */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/* Function ====================================================================\n * Terminate this data logging session by destroying the uploadInfo and\n * setting the trigger backed to the unarmed state.\n */\nPUBLIC void UploadEndLoggingSession(int32_T upInfoIdx, int_T numSampTimes)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    uploadInfo->trigInfo.state = TRIGGER_UNARMED;\n    UploadLogInfoTerm(upInfoIdx, numSampTimes);\n} /* end UploadEndLoggingSession */\n\n\n/* Function ====================================================================\n * Cancel this data logging session.\n */\nPUBLIC void UploadCancelLogging(int32_T upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    switch(uploadInfo->trigInfo.state) {\n\n    case TRIGGER_UNARMED:\n        break;\n\n    case TRIGGER_HOLDING_OFF:\n    case TRIGGER_ARMED:\n    case TRIGGER_DELAYED:\n    case TRIGGER_FIRED:\n        /*\n         * Move to TRIGGER_TERMINATING and ensure that we are no longer in\n         * \"normal\" mode (TRIGMODE_NORMAL) so that the trigger does not get\n         * re-armed.\n         */\n        uploadInfo->trigInfo.holdOff = TRIGMODE_ONESHOT;\n        uploadInfo->trigInfo.state   = TRIGGER_TERMINATING;\n#ifdef VXWORKS\n        /*\n         * Let upload server run to ensure that term pkt is sent to host (needed\n         * for all but the TRIGGERED_FIRED case since the upload server is\n         * inactive).\n         */\n        semGive(uploadSem);\n#endif\n        break;\n    \n    case TRIGGER_TERMINATING:\n        /*\n         * Ensure that we are no longer in \"normal\" mode (TRIGMODE_NORMAL) so\n         * that the trigger does not get re-armed.\n         */\n        uploadInfo->trigInfo.holdOff = TRIGMODE_ONESHOT;\n        break;\n    }\n} /* end UploadCancelLogEvent */\n\n\n/* Function ====================================================================\n * Called by ext_svr (background task), in order to perform tasks that need\n * to be done after each time that data has been sent to the host.  This\n * includes:\n *\n * o move the tail for the specified buffer forward\n * o detect the end of a data logging event so that the trigger state can\n *   be either set to unarmed (for one shot) or backed to armed (for normal\n *   mode).\n * \n * NOTE:  UploadBufGetData and UploadBufMoveTail must be called in pairs where the\n *        UploadBufGetData call precedes the UploadBufMoveTail call.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPUBLIC void UploadBufDataSent(const int_T tid, int32_T upInfoIdx)\n{   \n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    CircularBuf  *circBuf    = &uploadInfo->circBufs[tid];            \n\n    host_upstatus_is_uploading = true;\n    \n    /* Move the tail forward. */\n    circBuf->tail = circBuf->newTail;\n        \n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n    /* \n     * disable interrupts around this critical region. We need to \n     * guarantee that reading the head pointer is an atomic \n     * operation.\n     */\n    EXTMODE_DISABLE_INTERRUPTS;\n#endif\n    \n    /* \n     * Since we are moving the tail forward, we know that head == tail\n     * represents an empty buffer and not a full buffer.\n     */\n    circBuf->empty = (circBuf->tail == circBuf->head);\n    \n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n    /* re-enable interrupts */\n    EXTMODE_ENABLE_INTERRUPTS;\n#endif\n\n} /* end UploadBufDataSent */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/*\n * Macro =======================================================================\n * Move the tail of a circular buffer forward by one time step - accounting for\n * wrapping.\n */\n#define MOVE_TAIL_ONESTEP(circBuf, end)                            \\\n{                                                                  \\\n    int     nBytesPassedEnd;                                       \\\n    int     nBytesInStep;                                          \\\n    int32_T *nBytesPtr = (int32_T *)((circBuf)->tail)+1;           \\\n                                                                   \\\n    (void)memcpy(&nBytesInStep, nBytesPtr, sizeof(int32_T));       \\\n    nBytesInStep += (2*sizeof(int32_T));                           \\\n    assert(nBytesInStep > 0);                                      \\\n    (circBuf)->tail += (nBytesInStep);                             \\\n    nBytesPassedEnd = (int)((circBuf)->tail - (end));              \\\n    if (nBytesPassedEnd >= 0) {                                    \\\n        (circBuf)->tail = (circBuf)->buf + nBytesPassedEnd;        \\\n    }                                                              \\\n} /* end MOVE_TAIL_ONESTEP */\n\n\n/*\n * Macro =======================================================================\n * Copy data into the circular buffer.\n */\n#define CIRCBUF_COPY_DATA(bufMem, data)                         \\\n{                                                               \\\n    (void)memcpy((bufMem).section1, (data), (bufMem).nBytes1);  \\\n    if ((bufMem).section2 != NULL) {                            \\\n        char *tmp = ((char *)(data)) + (bufMem).nBytes1;        \\\n        (void)memcpy((bufMem).section2, tmp, (bufMem).nBytes2); \\\n    }                                                           \\\n} /* end CIRCBUF_COPY_DATA */\n\n\n/* Function ====================================================================\n * Assign sections in the circular buffer for the requested number of bytes\n * (i.e., fill in the bufMem struct).  If there is no room in the circular\n * buffer return an overflow error.\n *\n * NOTE: Do not move the CircularBuffers head forward in this function!  \n *       Only move the tmpHead forward.  The actual head is not advanced\n *       until the entire time point is successfully copied into the buffer.\n *\n *       This function modifies tmpHead to point at the next available \n *       location.\n *\n *       It is possible for tmpHead to equal the tail upon entry to this\n *       function.  This does not necessarily mean that the buffer is\n *       empty (unwrapped).  It could also mean that the buffer is exactly\n *       full (this is considered as wrapped).\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPRIVATE boolean_T UploadBufAssignMem(\n    CircularBuf  *circBuf,\n    int_T        nBytesToAdd,\n    char         **tmpHead,   /* in-out */\n    BufMem       *bufMem)     /* out */\n{\n    int_T       nBytesLeft;\n    boolean_T   overFlow  = false;\n    char        *end      = circBuf->buf + circBuf->bufSize; /* 1 passed end */\n\n    if ((*tmpHead > circBuf->tail) || circBuf->empty) {\n        /* buffer not wrapped */\n        nBytesLeft = (int_T)((end - *tmpHead) + (circBuf->tail - circBuf->buf));\n\n        if (nBytesLeft < nBytesToAdd) {\n            overFlow = true;\n            goto EXIT_POINT;\n        }\n\n        if ((*tmpHead + nBytesToAdd) < end) {\n            /* still not wrapped */\n            bufMem->nBytes1  = nBytesToAdd;\n            bufMem->section1 = *tmpHead;\n\n            bufMem->nBytes2  = 0;\n            bufMem->section2 = NULL;\n\n            *tmpHead += nBytesToAdd;\n        } else {\n            /* now we're wrapped */\n            bufMem->nBytes1  = (int_T)(end - *tmpHead);\n            bufMem->section1 = *tmpHead;\n\n            bufMem->nBytes2  = nBytesToAdd - bufMem->nBytes1;\n            bufMem->section2 = (bufMem->nBytes2 > 0) ? circBuf->buf : NULL;\n\n            *tmpHead = circBuf->buf + bufMem->nBytes2;\n        }  \n    } else {\n        /* wrapped */\n        nBytesLeft = (int_T)(circBuf->tail - *tmpHead);\n        if (nBytesLeft < nBytesToAdd) {\n            overFlow = true;\n            goto EXIT_POINT;\n        }\n\n        bufMem->nBytes1  = nBytesToAdd;\n        bufMem->section1 = *tmpHead;\n\n        bufMem->nBytes2  = 0;\n        bufMem->section2 = NULL;\n\n        *tmpHead += nBytesToAdd;\n    }\n    \nEXIT_POINT:\n    return(overFlow);\n} /* end UploadBufAssignMem */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/* Function ====================================================================\n * Check the trigger signals for crossings.  Return true if a trigger event is\n * encountered.  It is assumed that the trigger signals are real_T.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPRIVATE boolean_T UploadCheckTriggerSignals(int32_T upInfoIdx)\n{\n    int          i;\n    BdUploadInfo *uploadInfo      = &uploadInfoArray[upInfoIdx];\n    TriggerInfo  *trigInfo        = &uploadInfo->trigInfo;\n    real_T       *oldTrigSigVals  = trigInfo->oldTrigSigVals;\n    real_T       *oldSigPtr       = oldTrigSigVals;\n       \n    for (i=0; i<trigInfo->trigSignals.nSections; i++) {\n        UploadSection *section = &trigInfo->trigSignals.sections[i];\n        int_T         nEls     = section->nBytes / sizeof(real_T);\n\n        /*\n         * If we have a previous signal value to check, then see if we had\n         * a crossing.\n         */\n        if (trigInfo->haveOldTrigSigVal) {\n            int_T   j;\n            real_T  level   = trigInfo->level;\n            real_T  *rStart = (real_T *)section->start; /* guaranteed by host */\n            \n            for (j=0; j<nEls; j++) {\n                if (trigInfo->lookForRising && \n                    (((rStart[j] >= level) && (oldSigPtr[j] <  level)) ||\n                     ((rStart[j] >  level) && (oldSigPtr[j] == level)))) {\n                    return(true);\n                }\n                if (trigInfo->lookForFalling &&\n                    (((rStart[j] < level)  && (oldSigPtr[j] >= level)) ||\n                     ((rStart[j] == level) && (oldSigPtr[j] >  level)))) {\n                    return(true);\n                }\n            }\n        }\n\n        /*\n         * Update old signal values.\n         */\n        (void)memcpy(oldSigPtr, section->start, section->nBytes);\n        oldSigPtr += nEls;\n    }\n    assert(((unsigned char *)oldTrigSigVals) + trigInfo->trigSignals.nBytes == oldSigPtr);\n    trigInfo->haveOldTrigSigVal = true;\n    return(false);\n} /* end UploadCheckTriggerSignals */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n/* Function ====================================================================\n * If the trigger is in the TRIGGER_FIRED state or we are collecting data for\n * pre-triggering, add data, for each tid with a hit, to the upload buffers.  \n * This function is called from within the appropriate task, once per sample\n * hit.\n *\n * The format of the packet that is sent to the host is as follows:\n *\n * definitions:\n *      pktType - A qualifier indicating any special action that needs to be\n *                taken (e.g., a termination flag following the last data point,\n *                or a flag indicating that it is the first data point after\n *                a trigger event).\n *\n *      nBytes - total number of target bytes for this packet (including the\n *               nBytes field).  nBytes worth of data represents 1 full time\n *               step of the target simulation.\n *\n *      nSys - The number of systems for which this packet contains data.\n *\n *      tid - The tid with which this data is associated.\n *\n *      upInfoIdx - upInfo index\n *\n *      t - simulation time\n *\n *      sysId - The index into the BdUploadInfo.sysTables array so that we can\n *              map the target data back to the appropriate system.  This is\n *              NOT the descendant system index!\n *\n *      data - the target simulation data (in target format)\n *\n * The packet looks like:\n * [nBytes pktType nSys tid upInfoIdx t sysId [data] sysId [data]...]\n *     |                            | |         | |          |\n *     ----------------------------- ----------- ------------\n *          pkt header          sys data     sys data\n *\n * Ints are int32_T.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPUBLIC void UploadBufAddTimePoint(int_T tid, real_T taskTime,\n                                  int32_T upInfoIdx)\n{\n    int_T        preTrig;\n    int_T        overFlow;\n    TriggerInfo  *trigInfo;\n    CircularBuf  *circBuf;\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    overFlow   = false;\n    trigInfo   = &uploadInfo->trigInfo;\n    circBuf    = &uploadInfo->circBufs[tid];\n    \n    /*\n     * Check for transitions from the TRIGGER_ARMED state to either the\n     * TRIGGER_FIRED_STATE or the TRIGGER_DELAYED state.  We only do this\n     * if it is a sample hit for the trigger signal.  Note that this\n     * is the only place in the whole world that the trigger state can\n     * move from TRIGGER_ARMED_STATE to TRIGGER_DELAYED or TRIGGER_FIRED.\n     */\n    if (trigInfo->state == TRIGGER_ARMED) {\n        if (trigInfo->trigSignals.nSections == 0) {\n            /* short-circuit for manual trigger */\n            trigInfo->state = TRIGGER_FIRED;\n        } else\n            if ((tid == trigInfo->tid) &&\n                (UploadCheckTriggerSignals(upInfoIdx))) {\n                /* trig signal crossing */\n                if (trigInfo->delay == 0) {\n                    trigInfo->state = TRIGGER_FIRED;\n                    /* 0 unless pre-trig */\n                    trigInfo->count = trigInfo->preTrig.count;\n                } else {\n                    trigInfo->state = TRIGGER_DELAYED;\n                    assert(trigInfo->count == 0);\n                    \n                    /* We will be skipping this step, so the delay count is 1. */\n                    trigInfo->count = 1;\n                }\n            }\n    }\n    \n    preTrig = (trigInfo->state == TRIGGER_ARMED) &&\n        (trigInfo->preTrig.duration > 0);\n    \n    /*\n     * Handle adding data to the collection buffers - if needed.\n     */\n    if (((trigInfo->state == TRIGGER_FIRED) || preTrig) &&\n        /* bufSize == 0 means no signals in this tid */\n        circBuf->bufSize != 0) {\n        \n        int32_T     i;\n        BufMem      bufMem;\n        BufMem      pktStart;\n        int_T       size;\n        char_T *tmpHead    = circBuf->head;\n        const int_T PKT_TYPE_IDX = 0;\n        const int_T NBYTES_IDX   = 1;\n        const int_T NSYS_IDX     = 2;\n        const int_T TID_IDX      = 3;\n        const int_T UPINFO_IDX   = 4;\n\n        int32_T intHdr[5] = {0, 0, 0, 0, 0};\n        intHdr[UPINFO_IDX] = upInfoIdx;\n        \n        if (preTrig && (trigInfo->preTrig.count==trigInfo->preTrig.duration)) {\n            /* Advance the tail (we don't need the oldest point anymore). */\n            char *end = circBuf->buf + circBuf->bufSize;\n            MOVE_TAIL_ONESTEP(circBuf, end);\n            trigInfo->preTrig.count--;\n        }\n        \n        /*\n         * Save some space for the 5 integer values that make up the packet\n         * header: [pktType nBytes nSys tid upInfoIdx].\n         * The values are filled in later.\n         */\n        size = 5*sizeof(int32_T);\n        overFlow = UploadBufAssignMem(circBuf, size, &tmpHead, &pktStart);\n        if (overFlow) goto EXIT_POINT;\n\n        /*\n         * We do not want to include the packet type and number of bytes\n         * in the size calculation.  Size should represent the payload of\n         * this packet.  The packet type and number of bytes represent the\n         * packet header and are not included in the payload size.\n         */\n        size -= 2*sizeof(int32_T);\n        intHdr[NBYTES_IDX] += size;\n        \n        /* time */\n        overFlow =\n            UploadBufAssignMem(circBuf, sizeof(real_T), &tmpHead, &bufMem);\n        if (overFlow) goto EXIT_POINT;\n        intHdr[NBYTES_IDX] += sizeof(real_T);\n        \n        CIRCBUF_COPY_DATA(bufMem, &taskTime);\n\n        /*\n         * Check each system for an UploadMap. \n         */\n        for (i=0; i<uploadInfo->nSys; i++) {\n            const SysUploadTable *sysTable =\n                (const SysUploadTable *)&uploadInfo->sysTables[i];\n            \n            if ( (*sysTable->enableState != SUBSYS_RAN_BC_DISABLE) && \n                 (*sysTable->enableState != SUBSYS_RAN_BC_ENABLE_TO_DISABLE) ) {\n                UploadMap *map = sysTable->uploadMap[tid];\n\n                if (map != NULL) {\n                    int_T section;\n                    intHdr[NSYS_IDX]++;\n                    \n                    /* Add system index */\n                    size = sizeof(int32_T);\n                    overFlow =\n                        UploadBufAssignMem(circBuf, size, &tmpHead, &bufMem);\n                    if (overFlow) goto EXIT_POINT;\n                    intHdr[NBYTES_IDX] += size;\n                    \n                    CIRCBUF_COPY_DATA(bufMem, &i);\n                    \n                    /* Add data values */\n                    for (section=0; section<map->nSections; section++) {\n                        UploadSection *sect = &map->sections[section];\n                        \n#ifdef MW_DYNAMIC_STRING_SUPPORT\n                        if (sect->isString) {\n                            /* String data is [nBytes \"abc...\\0\"] */\n                            const void* strPtr = *(void**)sect->start;\n                            /* Add number of bytes of the string, including null-terminator */\n                            int32_T strNBytes = suStrlen(strPtr) + 1;\n                            char *tmpStr;\n                            \n                            overFlow = UploadBufAssignMem(circBuf, size, &tmpHead, &bufMem);\n                            if (overFlow) goto EXIT_POINT;\n                            intHdr[NBYTES_IDX] += size;\n                            CIRCBUF_COPY_DATA(bufMem, &strNBytes);\n\n                            /* Add character bytes */\n                            overFlow = UploadBufAssignMem(circBuf, strNBytes, &tmpHead, &bufMem);\n                            if (overFlow) goto EXIT_POINT;\n                            intHdr[NBYTES_IDX] += strNBytes;\n                            \n                            tmpStr = suToCStr(strPtr);\n                            CIRCBUF_COPY_DATA(bufMem, tmpStr);\n                            suFreeCStr(tmpStr);\n                        } else\n#endif\n                        \n                        {\n                            /* Regular cases */\n                            overFlow = UploadBufAssignMem(\n                                circBuf, sect->nBytes, &tmpHead, &bufMem);\n                            if (overFlow) goto EXIT_POINT;\n                            intHdr[NBYTES_IDX] += sect->nBytes;\n                            \n                            CIRCBUF_COPY_DATA(bufMem, sect->start);\n                        }\n                    }\n                }\n            }\n        }\n\n        /* If no systems were active then, do nothing. */\n        if (intHdr[NSYS_IDX] == 0) goto EXIT_POINT;\n        \n        /*\n         * Go back and finish the header: [nBytes pktType nSys tid]\n         */\n        \n        /* ...pktType */\n        intHdr[PKT_TYPE_IDX] = EXT_UPLOAD_LOGGING_DATA;\n\n        /* ...tid */\n        intHdr[TID_IDX] = tid;\n        CIRCBUF_COPY_DATA(pktStart, intHdr);\n\n        /*\n         * Time point successfully added to queue.\n         */\n        circBuf->head  = tmpHead;\n        circBuf->empty = false;\n        \n        if (preTrig) {\n            trigInfo->preTrig.count++;\n        }\n    }\n\nEXIT_POINT:\n    if (!preTrig) {\n        if (overFlow) {\n            trigInfo->overFlow = true;\n            trigInfo->state    = TRIGGER_TERMINATING;\n        }\n#ifdef VXWORKS\n        else if (trigInfo->state == TRIGGER_FIRED) {\n            /* allow upload server to run - if data needs to be uploaded */\n            semGive(uploadSem);\n        }\n#endif\n    } \n} /* end UploadBufAddTimePoint */\n\n\n/* Function ====================================================================\n * Called at the base rate, controls the state of data logging including:\n *   - monitoring the trigger signal for a trigger event\n *   - managing transition of most trigger states\n *      o a separate function (UploadCheckEndTrigger manages the duration\n *        count and the transition from fired to terminating at the end\n *        of the data collection event).\n *\n * NOTE:\n *  o This function should be called after mdlOutputs for the base rate\n */\nPUBLIC void UploadCheckTrigger(int32_T upInfoIdx, int_T numSampTimes)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    TriggerInfo  *trigInfo   = &uploadInfo->trigInfo;\n\n    if (trigInfo->state == TRIGGER_UNARMED) return;\n\n    if (trigInfo->state == TRIGGER_HOLDING_OFF) {\n        if (trigInfo->count++ == trigInfo->holdOff) {\n            UploadArmTrigger(upInfoIdx, numSampTimes);\n        } else {\n            return;\n        }\n    }\n\n    /*\n     * Transitions from the TRIGGER_ARMED_STATE to the TRIGGER_DELAYED\n     * state or to the TRIGGER_FIRED_STATE are checked for and realized\n     * within the task (tid) associated with the trigger signal.\n     * See UploadBufAddTimePoint().\n     */ \n    \n    /*\n     * Look for transitions from the TRIGGER_DELAYED state.  The TRIGGER_FIRED\n     * state always follows the TRIGGER_DELAYED state.\n     *\n     * NOTE: the trigInfo count field is first used to count the trigger delay\n     *       and then used to count the trigger duration\n     */\n    if (trigInfo->state == TRIGGER_DELAYED) {\n        if (trigInfo->count++ >= trigInfo->delay) {\n            trigInfo->count = trigInfo->preTrig.count; /* 0 unless pre-trig */\n            trigInfo->state = TRIGGER_FIRED;\n            if (trigInfo->preTrig.duration > 0) {\n                trigInfo->preTrig.checkUnderFlow = true;\n            }\n#ifdef VERBOSE\n            printf(\"\\nTrigger fired!\\n\");\n#endif\n        }\n    }\n} /* end UploadCheckTrigger */\n\n\n/* Function ====================================================================\n * Called at the base rate, controls the state of data logging wrt\n *  o incrementing the duration count\n *  o managing the transition to the trigger terminating state\n *\n * NOTES:\n *  o Call this function at the very end of a step.\n *  o Also see UploadCheckTrigger()\n */\nPUBLIC void UploadCheckEndTrigger(int32_T upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    TriggerInfo *trigInfo    = &uploadInfo->trigInfo;\n\n    if (trigInfo->state == TRIGGER_UNARMED) return;\n\n    /*\n     * Increment duration count and terminate the data logging event if\n     * the duration has been met.\n     */\n    if (trigInfo->state == TRIGGER_FIRED) {\n        trigInfo->count++;\n        if (trigInfo->count == trigInfo->duration) {\n            trigInfo->state = TRIGGER_TERMINATING;\n        }\n    }\n\n#ifdef VXWORKS\n    if (trigInfo->state == TRIGGER_TERMINATING) {\n        /* Let upload server run to ensure that term pkt is sent to host. */\n        semGive(uploadSem);\n    }\n#endif\n} /* end UploadCheckEndTrigger */\n\n\n/* Function ===================================================================\n * Search through the upload buffers and fill out the internal copy of the\n * buffer list.  It contains a list of all buffer memory (1 entry per non-empty\n * tid buffer) that needs to be sent to the host.  Fill out the fields of the\n * specified ExtBufMemList (passed in by ext_svr) to provide public, read-only\n * access.\n */\nPRIVATE void SetExtBufListFields(ExtBufMemList *extBufList,\n                                 int32_T       upInfoIdx,\n                                 int_T         numSampTimes)\n{\n    int_T       tid;\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    BufMemList   *bufList    = &uploadInfo->bufMemList;\n\n    bufList->nActiveBufs = 0;\n\n    for (tid=0; tid<numSampTimes; tid++) {\n        CircularBuf *circBuf = &uploadInfo->circBufs[tid];\n\n        if (!circBuf->empty) {\n            BufMem  *bufMem;\n            char_T  *head;\n            char_T  *tail   = circBuf->tail;\n            int_T   size    = circBuf->bufSize;\n\n            \n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n            /* \n             * disable interrupts around this critical region. We need to \n             * guarantee that reading the head pointer is an atomic \n             * operation.\n             */\n            EXTMODE_DISABLE_INTERRUPTS;\n#endif\n\n            head = circBuf->head;\n\n            \n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n            /* re-enable interrupts */\n            EXTMODE_ENABLE_INTERRUPTS;\n#endif\n\n            /* Validate that head/tail ptrs are within allocated range. */\n            assert((head >= circBuf->buf) && (tail >= circBuf->buf));\n            assert((head < circBuf->buf + circBuf->bufSize) &&\n                   (tail < circBuf->buf + circBuf->bufSize));\n\n            bufMem = &bufList->bufs[bufList->nActiveBufs];\n            bufList->tids[bufList->nActiveBufs] = tid;\n            assert(bufList->nActiveBufs < bufList->maxBufs);\n            bufList->nActiveBufs++;\n\n            bufMem->section1 = tail;\n            circBuf->newTail = head;\n\n            if (head > tail) {\n                /* not wrapped - only one section required */\n                bufMem->nBytes1  = (int_T)(head - tail);\n\n                bufMem->nBytes2  = 0;\n                bufMem->section2 = NULL;\n            } else {\n                /* wrapped - 2 sections required */\n                bufMem->nBytes1 = (int_T)(circBuf->buf + size - tail);\n\n                bufMem->nBytes2  = (int_T)(head - circBuf->buf);\n                bufMem->section2 = circBuf->buf;\n            }\n        }\n    }\n\n    /*\n     * Provide ext_svr with readonly access to the bufMemList.\n     */\n    extBufList->nActiveBufs = bufList->nActiveBufs;\n    extBufList->bufs        = (const BufMem *)bufList->bufs;\n    extBufList->tids        = (const int_T *)bufList->tids;\n} /* end SetExtBufListFields */\n\n\n/* Function ===================================================================\n * Set the internal copy of the buffer list to \"empty\" & fill out the fields\n * of the specified ExtBufMemList (passed in by ext_svr) to provide public,\n * read only access.\n */\nPRIVATE void SetExtBufListFieldsForEmptyList(ExtBufMemList *extBufList,\n                                             int32_T       upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    BufMemList   *bufList    = &uploadInfo->bufMemList;\n\n    bufList->nActiveBufs = 0;\n\n    extBufList->nActiveBufs = bufList->nActiveBufs;\n    extBufList->bufs        = (const BufMem *)NULL;\n} /* end SetExtBufListFieldsForEmptyList */\n\n\n/* Function ====================================================================\n * Called by ext_svr (background task), this function checks all buffers for\n * data and returns a list of buffer memory to be sent to the host.\n */\nPUBLIC void UploadBufGetData(ExtBufMemList *extBufList,\n                             int32_T       upInfoIdx,\n                             int_T         numSampTimes)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    TriggerInfo  *trigInfo   = &uploadInfo->trigInfo;\n    TriggerState trigState = trigInfo->state;\n \n    if ((trigState == TRIGGER_FIRED) ||\n        (trigState == TRIGGER_TERMINATING)) {\n\n        /* Make sure we start with an empty list */\n        SetExtBufListFieldsForEmptyList(extBufList, upInfoIdx);\n        SetExtBufListFields(extBufList, upInfoIdx, numSampTimes);\n\n        /*\n         * If all bufs are empty and we are terminating then we're now done!\n         */\n        if ((extBufList->nActiveBufs == 0) &&\n            (trigState == TRIGGER_TERMINATING)) {\n\n            host_upstatus_is_uploading = false;\n\n            if (trigInfo->holdOff == TRIGMODE_ONESHOT) {\n                SendPktToHost(EXT_TERMINATE_LOG_SESSION, sizeof(int32_T),\n                              (char *)&upInfoIdx);\n                UploadEndLoggingSession(upInfoIdx, numSampTimes);\n            } else {\n                SendPktToHost(EXT_TERMINATE_LOG_EVENT, sizeof(int32_T),\n                              (char *)&upInfoIdx);\n                trigInfo->count = 0;\n                trigInfo->state = TRIGGER_HOLDING_OFF;\n            }\n        }\n    } else {\n        SetExtBufListFieldsForEmptyList(extBufList, upInfoIdx);\n    }\n} /* end UploadBufGetData */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n/* [EOF] updown.c */\n\n/* LocalWords:  DType pbuf NPARAMS dtype tran Els EXTMODE HDR abc\n * LocalWords:  DISABLEPARAMETERTUNING bufs buf blockio tids sys's nbuf sigs\n * LocalWords:  tid's DISABLESIGNALMONITORING uploadinfo NULL'ed vals oneshot\n * LocalWords:  sem svr TRIGMODE ONESTEP CIRCBUF tmp\n */\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};